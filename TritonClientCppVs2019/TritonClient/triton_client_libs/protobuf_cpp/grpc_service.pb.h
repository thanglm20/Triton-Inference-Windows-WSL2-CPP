// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpc_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpc_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "model_config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpc_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpc_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpc_5fservice_2eproto;
namespace inference {
class CudaSharedMemoryRegisterRequest;
struct CudaSharedMemoryRegisterRequestDefaultTypeInternal;
extern CudaSharedMemoryRegisterRequestDefaultTypeInternal _CudaSharedMemoryRegisterRequest_default_instance_;
class CudaSharedMemoryRegisterResponse;
struct CudaSharedMemoryRegisterResponseDefaultTypeInternal;
extern CudaSharedMemoryRegisterResponseDefaultTypeInternal _CudaSharedMemoryRegisterResponse_default_instance_;
class CudaSharedMemoryStatusRequest;
struct CudaSharedMemoryStatusRequestDefaultTypeInternal;
extern CudaSharedMemoryStatusRequestDefaultTypeInternal _CudaSharedMemoryStatusRequest_default_instance_;
class CudaSharedMemoryStatusResponse;
struct CudaSharedMemoryStatusResponseDefaultTypeInternal;
extern CudaSharedMemoryStatusResponseDefaultTypeInternal _CudaSharedMemoryStatusResponse_default_instance_;
class CudaSharedMemoryStatusResponse_RegionStatus;
struct CudaSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal;
extern CudaSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal _CudaSharedMemoryStatusResponse_RegionStatus_default_instance_;
class CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse;
struct CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal;
extern CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal _CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_;
class CudaSharedMemoryUnregisterRequest;
struct CudaSharedMemoryUnregisterRequestDefaultTypeInternal;
extern CudaSharedMemoryUnregisterRequestDefaultTypeInternal _CudaSharedMemoryUnregisterRequest_default_instance_;
class CudaSharedMemoryUnregisterResponse;
struct CudaSharedMemoryUnregisterResponseDefaultTypeInternal;
extern CudaSharedMemoryUnregisterResponseDefaultTypeInternal _CudaSharedMemoryUnregisterResponse_default_instance_;
class InferBatchStatistics;
struct InferBatchStatisticsDefaultTypeInternal;
extern InferBatchStatisticsDefaultTypeInternal _InferBatchStatistics_default_instance_;
class InferParameter;
struct InferParameterDefaultTypeInternal;
extern InferParameterDefaultTypeInternal _InferParameter_default_instance_;
class InferStatistics;
struct InferStatisticsDefaultTypeInternal;
extern InferStatisticsDefaultTypeInternal _InferStatistics_default_instance_;
class InferTensorContents;
struct InferTensorContentsDefaultTypeInternal;
extern InferTensorContentsDefaultTypeInternal _InferTensorContents_default_instance_;
class LogSettingsRequest;
struct LogSettingsRequestDefaultTypeInternal;
extern LogSettingsRequestDefaultTypeInternal _LogSettingsRequest_default_instance_;
class LogSettingsRequest_SettingValue;
struct LogSettingsRequest_SettingValueDefaultTypeInternal;
extern LogSettingsRequest_SettingValueDefaultTypeInternal _LogSettingsRequest_SettingValue_default_instance_;
class LogSettingsRequest_SettingsEntry_DoNotUse;
struct LogSettingsRequest_SettingsEntry_DoNotUseDefaultTypeInternal;
extern LogSettingsRequest_SettingsEntry_DoNotUseDefaultTypeInternal _LogSettingsRequest_SettingsEntry_DoNotUse_default_instance_;
class LogSettingsResponse;
struct LogSettingsResponseDefaultTypeInternal;
extern LogSettingsResponseDefaultTypeInternal _LogSettingsResponse_default_instance_;
class LogSettingsResponse_SettingValue;
struct LogSettingsResponse_SettingValueDefaultTypeInternal;
extern LogSettingsResponse_SettingValueDefaultTypeInternal _LogSettingsResponse_SettingValue_default_instance_;
class LogSettingsResponse_SettingsEntry_DoNotUse;
struct LogSettingsResponse_SettingsEntry_DoNotUseDefaultTypeInternal;
extern LogSettingsResponse_SettingsEntry_DoNotUseDefaultTypeInternal _LogSettingsResponse_SettingsEntry_DoNotUse_default_instance_;
class MemoryUsage;
struct MemoryUsageDefaultTypeInternal;
extern MemoryUsageDefaultTypeInternal _MemoryUsage_default_instance_;
class ModelConfigRequest;
struct ModelConfigRequestDefaultTypeInternal;
extern ModelConfigRequestDefaultTypeInternal _ModelConfigRequest_default_instance_;
class ModelConfigResponse;
struct ModelConfigResponseDefaultTypeInternal;
extern ModelConfigResponseDefaultTypeInternal _ModelConfigResponse_default_instance_;
class ModelInferRequest;
struct ModelInferRequestDefaultTypeInternal;
extern ModelInferRequestDefaultTypeInternal _ModelInferRequest_default_instance_;
class ModelInferRequest_InferInputTensor;
struct ModelInferRequest_InferInputTensorDefaultTypeInternal;
extern ModelInferRequest_InferInputTensorDefaultTypeInternal _ModelInferRequest_InferInputTensor_default_instance_;
class ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse;
struct ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse_default_instance_;
class ModelInferRequest_InferRequestedOutputTensor;
struct ModelInferRequest_InferRequestedOutputTensorDefaultTypeInternal;
extern ModelInferRequest_InferRequestedOutputTensorDefaultTypeInternal _ModelInferRequest_InferRequestedOutputTensor_default_instance_;
class ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse;
struct ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse_default_instance_;
class ModelInferRequest_ParametersEntry_DoNotUse;
struct ModelInferRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferRequest_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferRequest_ParametersEntry_DoNotUse_default_instance_;
class ModelInferResponse;
struct ModelInferResponseDefaultTypeInternal;
extern ModelInferResponseDefaultTypeInternal _ModelInferResponse_default_instance_;
class ModelInferResponse_InferOutputTensor;
struct ModelInferResponse_InferOutputTensorDefaultTypeInternal;
extern ModelInferResponse_InferOutputTensorDefaultTypeInternal _ModelInferResponse_InferOutputTensor_default_instance_;
class ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse;
struct ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse_default_instance_;
class ModelInferResponse_ParametersEntry_DoNotUse;
struct ModelInferResponse_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferResponse_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferResponse_ParametersEntry_DoNotUse_default_instance_;
class ModelMetadataRequest;
struct ModelMetadataRequestDefaultTypeInternal;
extern ModelMetadataRequestDefaultTypeInternal _ModelMetadataRequest_default_instance_;
class ModelMetadataResponse;
struct ModelMetadataResponseDefaultTypeInternal;
extern ModelMetadataResponseDefaultTypeInternal _ModelMetadataResponse_default_instance_;
class ModelMetadataResponse_TensorMetadata;
struct ModelMetadataResponse_TensorMetadataDefaultTypeInternal;
extern ModelMetadataResponse_TensorMetadataDefaultTypeInternal _ModelMetadataResponse_TensorMetadata_default_instance_;
class ModelReadyRequest;
struct ModelReadyRequestDefaultTypeInternal;
extern ModelReadyRequestDefaultTypeInternal _ModelReadyRequest_default_instance_;
class ModelReadyResponse;
struct ModelReadyResponseDefaultTypeInternal;
extern ModelReadyResponseDefaultTypeInternal _ModelReadyResponse_default_instance_;
class ModelRepositoryParameter;
struct ModelRepositoryParameterDefaultTypeInternal;
extern ModelRepositoryParameterDefaultTypeInternal _ModelRepositoryParameter_default_instance_;
class ModelStatistics;
struct ModelStatisticsDefaultTypeInternal;
extern ModelStatisticsDefaultTypeInternal _ModelStatistics_default_instance_;
class ModelStatisticsRequest;
struct ModelStatisticsRequestDefaultTypeInternal;
extern ModelStatisticsRequestDefaultTypeInternal _ModelStatisticsRequest_default_instance_;
class ModelStatisticsResponse;
struct ModelStatisticsResponseDefaultTypeInternal;
extern ModelStatisticsResponseDefaultTypeInternal _ModelStatisticsResponse_default_instance_;
class ModelStreamInferResponse;
struct ModelStreamInferResponseDefaultTypeInternal;
extern ModelStreamInferResponseDefaultTypeInternal _ModelStreamInferResponse_default_instance_;
class RepositoryIndexRequest;
struct RepositoryIndexRequestDefaultTypeInternal;
extern RepositoryIndexRequestDefaultTypeInternal _RepositoryIndexRequest_default_instance_;
class RepositoryIndexResponse;
struct RepositoryIndexResponseDefaultTypeInternal;
extern RepositoryIndexResponseDefaultTypeInternal _RepositoryIndexResponse_default_instance_;
class RepositoryIndexResponse_ModelIndex;
struct RepositoryIndexResponse_ModelIndexDefaultTypeInternal;
extern RepositoryIndexResponse_ModelIndexDefaultTypeInternal _RepositoryIndexResponse_ModelIndex_default_instance_;
class RepositoryModelLoadRequest;
struct RepositoryModelLoadRequestDefaultTypeInternal;
extern RepositoryModelLoadRequestDefaultTypeInternal _RepositoryModelLoadRequest_default_instance_;
class RepositoryModelLoadRequest_ParametersEntry_DoNotUse;
struct RepositoryModelLoadRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern RepositoryModelLoadRequest_ParametersEntry_DoNotUseDefaultTypeInternal _RepositoryModelLoadRequest_ParametersEntry_DoNotUse_default_instance_;
class RepositoryModelLoadResponse;
struct RepositoryModelLoadResponseDefaultTypeInternal;
extern RepositoryModelLoadResponseDefaultTypeInternal _RepositoryModelLoadResponse_default_instance_;
class RepositoryModelUnloadRequest;
struct RepositoryModelUnloadRequestDefaultTypeInternal;
extern RepositoryModelUnloadRequestDefaultTypeInternal _RepositoryModelUnloadRequest_default_instance_;
class RepositoryModelUnloadRequest_ParametersEntry_DoNotUse;
struct RepositoryModelUnloadRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern RepositoryModelUnloadRequest_ParametersEntry_DoNotUseDefaultTypeInternal _RepositoryModelUnloadRequest_ParametersEntry_DoNotUse_default_instance_;
class RepositoryModelUnloadResponse;
struct RepositoryModelUnloadResponseDefaultTypeInternal;
extern RepositoryModelUnloadResponseDefaultTypeInternal _RepositoryModelUnloadResponse_default_instance_;
class ServerLiveRequest;
struct ServerLiveRequestDefaultTypeInternal;
extern ServerLiveRequestDefaultTypeInternal _ServerLiveRequest_default_instance_;
class ServerLiveResponse;
struct ServerLiveResponseDefaultTypeInternal;
extern ServerLiveResponseDefaultTypeInternal _ServerLiveResponse_default_instance_;
class ServerMetadataRequest;
struct ServerMetadataRequestDefaultTypeInternal;
extern ServerMetadataRequestDefaultTypeInternal _ServerMetadataRequest_default_instance_;
class ServerMetadataResponse;
struct ServerMetadataResponseDefaultTypeInternal;
extern ServerMetadataResponseDefaultTypeInternal _ServerMetadataResponse_default_instance_;
class ServerReadyRequest;
struct ServerReadyRequestDefaultTypeInternal;
extern ServerReadyRequestDefaultTypeInternal _ServerReadyRequest_default_instance_;
class ServerReadyResponse;
struct ServerReadyResponseDefaultTypeInternal;
extern ServerReadyResponseDefaultTypeInternal _ServerReadyResponse_default_instance_;
class StatisticDuration;
struct StatisticDurationDefaultTypeInternal;
extern StatisticDurationDefaultTypeInternal _StatisticDuration_default_instance_;
class SystemSharedMemoryRegisterRequest;
struct SystemSharedMemoryRegisterRequestDefaultTypeInternal;
extern SystemSharedMemoryRegisterRequestDefaultTypeInternal _SystemSharedMemoryRegisterRequest_default_instance_;
class SystemSharedMemoryRegisterResponse;
struct SystemSharedMemoryRegisterResponseDefaultTypeInternal;
extern SystemSharedMemoryRegisterResponseDefaultTypeInternal _SystemSharedMemoryRegisterResponse_default_instance_;
class SystemSharedMemoryStatusRequest;
struct SystemSharedMemoryStatusRequestDefaultTypeInternal;
extern SystemSharedMemoryStatusRequestDefaultTypeInternal _SystemSharedMemoryStatusRequest_default_instance_;
class SystemSharedMemoryStatusResponse;
struct SystemSharedMemoryStatusResponseDefaultTypeInternal;
extern SystemSharedMemoryStatusResponseDefaultTypeInternal _SystemSharedMemoryStatusResponse_default_instance_;
class SystemSharedMemoryStatusResponse_RegionStatus;
struct SystemSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal;
extern SystemSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal _SystemSharedMemoryStatusResponse_RegionStatus_default_instance_;
class SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse;
struct SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal;
extern SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal _SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_;
class SystemSharedMemoryUnregisterRequest;
struct SystemSharedMemoryUnregisterRequestDefaultTypeInternal;
extern SystemSharedMemoryUnregisterRequestDefaultTypeInternal _SystemSharedMemoryUnregisterRequest_default_instance_;
class SystemSharedMemoryUnregisterResponse;
struct SystemSharedMemoryUnregisterResponseDefaultTypeInternal;
extern SystemSharedMemoryUnregisterResponseDefaultTypeInternal _SystemSharedMemoryUnregisterResponse_default_instance_;
class TraceSettingRequest;
struct TraceSettingRequestDefaultTypeInternal;
extern TraceSettingRequestDefaultTypeInternal _TraceSettingRequest_default_instance_;
class TraceSettingRequest_SettingValue;
struct TraceSettingRequest_SettingValueDefaultTypeInternal;
extern TraceSettingRequest_SettingValueDefaultTypeInternal _TraceSettingRequest_SettingValue_default_instance_;
class TraceSettingRequest_SettingsEntry_DoNotUse;
struct TraceSettingRequest_SettingsEntry_DoNotUseDefaultTypeInternal;
extern TraceSettingRequest_SettingsEntry_DoNotUseDefaultTypeInternal _TraceSettingRequest_SettingsEntry_DoNotUse_default_instance_;
class TraceSettingResponse;
struct TraceSettingResponseDefaultTypeInternal;
extern TraceSettingResponseDefaultTypeInternal _TraceSettingResponse_default_instance_;
class TraceSettingResponse_SettingValue;
struct TraceSettingResponse_SettingValueDefaultTypeInternal;
extern TraceSettingResponse_SettingValueDefaultTypeInternal _TraceSettingResponse_SettingValue_default_instance_;
class TraceSettingResponse_SettingsEntry_DoNotUse;
struct TraceSettingResponse_SettingsEntry_DoNotUseDefaultTypeInternal;
extern TraceSettingResponse_SettingsEntry_DoNotUseDefaultTypeInternal _TraceSettingResponse_SettingsEntry_DoNotUse_default_instance_;
}  // namespace inference
PROTOBUF_NAMESPACE_OPEN
template<> ::inference::CudaSharedMemoryRegisterRequest* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryRegisterRequest>(Arena*);
template<> ::inference::CudaSharedMemoryRegisterResponse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryRegisterResponse>(Arena*);
template<> ::inference::CudaSharedMemoryStatusRequest* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusRequest>(Arena*);
template<> ::inference::CudaSharedMemoryStatusResponse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusResponse>(Arena*);
template<> ::inference::CudaSharedMemoryStatusResponse_RegionStatus* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusResponse_RegionStatus>(Arena*);
template<> ::inference::CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse>(Arena*);
template<> ::inference::CudaSharedMemoryUnregisterRequest* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryUnregisterRequest>(Arena*);
template<> ::inference::CudaSharedMemoryUnregisterResponse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryUnregisterResponse>(Arena*);
template<> ::inference::InferBatchStatistics* Arena::CreateMaybeMessage<::inference::InferBatchStatistics>(Arena*);
template<> ::inference::InferParameter* Arena::CreateMaybeMessage<::inference::InferParameter>(Arena*);
template<> ::inference::InferStatistics* Arena::CreateMaybeMessage<::inference::InferStatistics>(Arena*);
template<> ::inference::InferTensorContents* Arena::CreateMaybeMessage<::inference::InferTensorContents>(Arena*);
template<> ::inference::LogSettingsRequest* Arena::CreateMaybeMessage<::inference::LogSettingsRequest>(Arena*);
template<> ::inference::LogSettingsRequest_SettingValue* Arena::CreateMaybeMessage<::inference::LogSettingsRequest_SettingValue>(Arena*);
template<> ::inference::LogSettingsRequest_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::LogSettingsRequest_SettingsEntry_DoNotUse>(Arena*);
template<> ::inference::LogSettingsResponse* Arena::CreateMaybeMessage<::inference::LogSettingsResponse>(Arena*);
template<> ::inference::LogSettingsResponse_SettingValue* Arena::CreateMaybeMessage<::inference::LogSettingsResponse_SettingValue>(Arena*);
template<> ::inference::LogSettingsResponse_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::LogSettingsResponse_SettingsEntry_DoNotUse>(Arena*);
template<> ::inference::MemoryUsage* Arena::CreateMaybeMessage<::inference::MemoryUsage>(Arena*);
template<> ::inference::ModelConfigRequest* Arena::CreateMaybeMessage<::inference::ModelConfigRequest>(Arena*);
template<> ::inference::ModelConfigResponse* Arena::CreateMaybeMessage<::inference::ModelConfigResponse>(Arena*);
template<> ::inference::ModelInferRequest* Arena::CreateMaybeMessage<::inference::ModelInferRequest>(Arena*);
template<> ::inference::ModelInferRequest_InferInputTensor* Arena::CreateMaybeMessage<::inference::ModelInferRequest_InferInputTensor>(Arena*);
template<> ::inference::ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInferRequest_InferRequestedOutputTensor* Arena::CreateMaybeMessage<::inference::ModelInferRequest_InferRequestedOutputTensor>(Arena*);
template<> ::inference::ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInferRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInferResponse* Arena::CreateMaybeMessage<::inference::ModelInferResponse>(Arena*);
template<> ::inference::ModelInferResponse_InferOutputTensor* Arena::CreateMaybeMessage<::inference::ModelInferResponse_InferOutputTensor>(Arena*);
template<> ::inference::ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInferResponse_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferResponse_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelMetadataRequest* Arena::CreateMaybeMessage<::inference::ModelMetadataRequest>(Arena*);
template<> ::inference::ModelMetadataResponse* Arena::CreateMaybeMessage<::inference::ModelMetadataResponse>(Arena*);
template<> ::inference::ModelMetadataResponse_TensorMetadata* Arena::CreateMaybeMessage<::inference::ModelMetadataResponse_TensorMetadata>(Arena*);
template<> ::inference::ModelReadyRequest* Arena::CreateMaybeMessage<::inference::ModelReadyRequest>(Arena*);
template<> ::inference::ModelReadyResponse* Arena::CreateMaybeMessage<::inference::ModelReadyResponse>(Arena*);
template<> ::inference::ModelRepositoryParameter* Arena::CreateMaybeMessage<::inference::ModelRepositoryParameter>(Arena*);
template<> ::inference::ModelStatistics* Arena::CreateMaybeMessage<::inference::ModelStatistics>(Arena*);
template<> ::inference::ModelStatisticsRequest* Arena::CreateMaybeMessage<::inference::ModelStatisticsRequest>(Arena*);
template<> ::inference::ModelStatisticsResponse* Arena::CreateMaybeMessage<::inference::ModelStatisticsResponse>(Arena*);
template<> ::inference::ModelStreamInferResponse* Arena::CreateMaybeMessage<::inference::ModelStreamInferResponse>(Arena*);
template<> ::inference::RepositoryIndexRequest* Arena::CreateMaybeMessage<::inference::RepositoryIndexRequest>(Arena*);
template<> ::inference::RepositoryIndexResponse* Arena::CreateMaybeMessage<::inference::RepositoryIndexResponse>(Arena*);
template<> ::inference::RepositoryIndexResponse_ModelIndex* Arena::CreateMaybeMessage<::inference::RepositoryIndexResponse_ModelIndex>(Arena*);
template<> ::inference::RepositoryModelLoadRequest* Arena::CreateMaybeMessage<::inference::RepositoryModelLoadRequest>(Arena*);
template<> ::inference::RepositoryModelLoadRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::RepositoryModelLoadRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::RepositoryModelLoadResponse* Arena::CreateMaybeMessage<::inference::RepositoryModelLoadResponse>(Arena*);
template<> ::inference::RepositoryModelUnloadRequest* Arena::CreateMaybeMessage<::inference::RepositoryModelUnloadRequest>(Arena*);
template<> ::inference::RepositoryModelUnloadRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::RepositoryModelUnloadRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::RepositoryModelUnloadResponse* Arena::CreateMaybeMessage<::inference::RepositoryModelUnloadResponse>(Arena*);
template<> ::inference::ServerLiveRequest* Arena::CreateMaybeMessage<::inference::ServerLiveRequest>(Arena*);
template<> ::inference::ServerLiveResponse* Arena::CreateMaybeMessage<::inference::ServerLiveResponse>(Arena*);
template<> ::inference::ServerMetadataRequest* Arena::CreateMaybeMessage<::inference::ServerMetadataRequest>(Arena*);
template<> ::inference::ServerMetadataResponse* Arena::CreateMaybeMessage<::inference::ServerMetadataResponse>(Arena*);
template<> ::inference::ServerReadyRequest* Arena::CreateMaybeMessage<::inference::ServerReadyRequest>(Arena*);
template<> ::inference::ServerReadyResponse* Arena::CreateMaybeMessage<::inference::ServerReadyResponse>(Arena*);
template<> ::inference::StatisticDuration* Arena::CreateMaybeMessage<::inference::StatisticDuration>(Arena*);
template<> ::inference::SystemSharedMemoryRegisterRequest* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryRegisterRequest>(Arena*);
template<> ::inference::SystemSharedMemoryRegisterResponse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryRegisterResponse>(Arena*);
template<> ::inference::SystemSharedMemoryStatusRequest* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusRequest>(Arena*);
template<> ::inference::SystemSharedMemoryStatusResponse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusResponse>(Arena*);
template<> ::inference::SystemSharedMemoryStatusResponse_RegionStatus* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusResponse_RegionStatus>(Arena*);
template<> ::inference::SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse>(Arena*);
template<> ::inference::SystemSharedMemoryUnregisterRequest* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryUnregisterRequest>(Arena*);
template<> ::inference::SystemSharedMemoryUnregisterResponse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryUnregisterResponse>(Arena*);
template<> ::inference::TraceSettingRequest* Arena::CreateMaybeMessage<::inference::TraceSettingRequest>(Arena*);
template<> ::inference::TraceSettingRequest_SettingValue* Arena::CreateMaybeMessage<::inference::TraceSettingRequest_SettingValue>(Arena*);
template<> ::inference::TraceSettingRequest_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::TraceSettingRequest_SettingsEntry_DoNotUse>(Arena*);
template<> ::inference::TraceSettingResponse* Arena::CreateMaybeMessage<::inference::TraceSettingResponse>(Arena*);
template<> ::inference::TraceSettingResponse_SettingValue* Arena::CreateMaybeMessage<::inference::TraceSettingResponse_SettingValue>(Arena*);
template<> ::inference::TraceSettingResponse_SettingsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::TraceSettingResponse_SettingsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace inference {

// ===================================================================

class ServerLiveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ServerLiveRequest) */ {
 public:
  inline ServerLiveRequest() : ServerLiveRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ServerLiveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerLiveRequest(const ServerLiveRequest& from);
  ServerLiveRequest(ServerLiveRequest&& from) noexcept
    : ServerLiveRequest() {
    *this = ::std::move(from);
  }

  inline ServerLiveRequest& operator=(const ServerLiveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerLiveRequest& operator=(ServerLiveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerLiveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerLiveRequest* internal_default_instance() {
    return reinterpret_cast<const ServerLiveRequest*>(
               &_ServerLiveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServerLiveRequest& a, ServerLiveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerLiveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerLiveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerLiveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerLiveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerLiveRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerLiveRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerLiveRequest";
  }
  protected:
  explicit ServerLiveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ServerLiveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerLiveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ServerLiveResponse) */ {
 public:
  inline ServerLiveResponse() : ServerLiveResponse(nullptr) {}
  ~ServerLiveResponse() override;
  explicit PROTOBUF_CONSTEXPR ServerLiveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerLiveResponse(const ServerLiveResponse& from);
  ServerLiveResponse(ServerLiveResponse&& from) noexcept
    : ServerLiveResponse() {
    *this = ::std::move(from);
  }

  inline ServerLiveResponse& operator=(const ServerLiveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerLiveResponse& operator=(ServerLiveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerLiveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerLiveResponse* internal_default_instance() {
    return reinterpret_cast<const ServerLiveResponse*>(
               &_ServerLiveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerLiveResponse& a, ServerLiveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerLiveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerLiveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerLiveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerLiveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerLiveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerLiveResponse& from) {
    ServerLiveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerLiveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerLiveResponse";
  }
  protected:
  explicit ServerLiveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveFieldNumber = 1,
  };
  // bool live = 1;
  void clear_live();
  bool live() const;
  void set_live(bool value);
  private:
  bool _internal_live() const;
  void _internal_set_live(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ServerLiveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool live_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerReadyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ServerReadyRequest) */ {
 public:
  inline ServerReadyRequest() : ServerReadyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ServerReadyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerReadyRequest(const ServerReadyRequest& from);
  ServerReadyRequest(ServerReadyRequest&& from) noexcept
    : ServerReadyRequest() {
    *this = ::std::move(from);
  }

  inline ServerReadyRequest& operator=(const ServerReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerReadyRequest& operator=(ServerReadyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerReadyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerReadyRequest* internal_default_instance() {
    return reinterpret_cast<const ServerReadyRequest*>(
               &_ServerReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServerReadyRequest& a, ServerReadyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerReadyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerReadyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerReadyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerReadyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerReadyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerReadyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerReadyRequest";
  }
  protected:
  explicit ServerReadyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ServerReadyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerReadyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ServerReadyResponse) */ {
 public:
  inline ServerReadyResponse() : ServerReadyResponse(nullptr) {}
  ~ServerReadyResponse() override;
  explicit PROTOBUF_CONSTEXPR ServerReadyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerReadyResponse(const ServerReadyResponse& from);
  ServerReadyResponse(ServerReadyResponse&& from) noexcept
    : ServerReadyResponse() {
    *this = ::std::move(from);
  }

  inline ServerReadyResponse& operator=(const ServerReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerReadyResponse& operator=(ServerReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerReadyResponse* internal_default_instance() {
    return reinterpret_cast<const ServerReadyResponse*>(
               &_ServerReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerReadyResponse& a, ServerReadyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerReadyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerReadyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerReadyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerReadyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerReadyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerReadyResponse& from) {
    ServerReadyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerReadyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerReadyResponse";
  }
  protected:
  explicit ServerReadyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ServerReadyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelReadyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelReadyRequest) */ {
 public:
  inline ModelReadyRequest() : ModelReadyRequest(nullptr) {}
  ~ModelReadyRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelReadyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelReadyRequest(const ModelReadyRequest& from);
  ModelReadyRequest(ModelReadyRequest&& from) noexcept
    : ModelReadyRequest() {
    *this = ::std::move(from);
  }

  inline ModelReadyRequest& operator=(const ModelReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelReadyRequest& operator=(ModelReadyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelReadyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelReadyRequest* internal_default_instance() {
    return reinterpret_cast<const ModelReadyRequest*>(
               &_ModelReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelReadyRequest& a, ModelReadyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelReadyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelReadyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelReadyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelReadyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelReadyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelReadyRequest& from) {
    ModelReadyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelReadyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelReadyRequest";
  }
  protected:
  explicit ModelReadyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelReadyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelReadyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelReadyResponse) */ {
 public:
  inline ModelReadyResponse() : ModelReadyResponse(nullptr) {}
  ~ModelReadyResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelReadyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelReadyResponse(const ModelReadyResponse& from);
  ModelReadyResponse(ModelReadyResponse&& from) noexcept
    : ModelReadyResponse() {
    *this = ::std::move(from);
  }

  inline ModelReadyResponse& operator=(const ModelReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelReadyResponse& operator=(ModelReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelReadyResponse* internal_default_instance() {
    return reinterpret_cast<const ModelReadyResponse*>(
               &_ModelReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModelReadyResponse& a, ModelReadyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelReadyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelReadyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelReadyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelReadyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelReadyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelReadyResponse& from) {
    ModelReadyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelReadyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelReadyResponse";
  }
  protected:
  explicit ModelReadyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelReadyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ServerMetadataRequest) */ {
 public:
  inline ServerMetadataRequest() : ServerMetadataRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ServerMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMetadataRequest(const ServerMetadataRequest& from);
  ServerMetadataRequest(ServerMetadataRequest&& from) noexcept
    : ServerMetadataRequest() {
    *this = ::std::move(from);
  }

  inline ServerMetadataRequest& operator=(const ServerMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMetadataRequest& operator=(ServerMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const ServerMetadataRequest*>(
               &_ServerMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServerMetadataRequest& a, ServerMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerMetadataRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerMetadataRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerMetadataRequest";
  }
  protected:
  explicit ServerMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ServerMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ServerMetadataResponse) */ {
 public:
  inline ServerMetadataResponse() : ServerMetadataResponse(nullptr) {}
  ~ServerMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR ServerMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMetadataResponse(const ServerMetadataResponse& from);
  ServerMetadataResponse(ServerMetadataResponse&& from) noexcept
    : ServerMetadataResponse() {
    *this = ::std::move(from);
  }

  inline ServerMetadataResponse& operator=(const ServerMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMetadataResponse& operator=(ServerMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const ServerMetadataResponse*>(
               &_ServerMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServerMetadataResponse& a, ServerMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMetadataResponse& from) {
    ServerMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerMetadataResponse";
  }
  protected:
  explicit ServerMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 3,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated string extensions = 3;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  const std::string& extensions(int index) const;
  std::string* mutable_extensions(int index);
  void set_extensions(int index, const std::string& value);
  void set_extensions(int index, std::string&& value);
  void set_extensions(int index, const char* value);
  void set_extensions(int index, const char* value, size_t size);
  std::string* add_extensions();
  void add_extensions(const std::string& value);
  void add_extensions(std::string&& value);
  void add_extensions(const char* value);
  void add_extensions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extensions();
  private:
  const std::string& _internal_extensions(int index) const;
  std::string* _internal_add_extensions();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ServerMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelMetadataRequest) */ {
 public:
  inline ModelMetadataRequest() : ModelMetadataRequest(nullptr) {}
  ~ModelMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetadataRequest(const ModelMetadataRequest& from);
  ModelMetadataRequest(ModelMetadataRequest&& from) noexcept
    : ModelMetadataRequest() {
    *this = ::std::move(from);
  }

  inline ModelMetadataRequest& operator=(const ModelMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetadataRequest& operator=(ModelMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const ModelMetadataRequest*>(
               &_ModelMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModelMetadataRequest& a, ModelMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetadataRequest& from) {
    ModelMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelMetadataRequest";
  }
  protected:
  explicit ModelMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetadataResponse_TensorMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelMetadataResponse.TensorMetadata) */ {
 public:
  inline ModelMetadataResponse_TensorMetadata() : ModelMetadataResponse_TensorMetadata(nullptr) {}
  ~ModelMetadataResponse_TensorMetadata() override;
  explicit PROTOBUF_CONSTEXPR ModelMetadataResponse_TensorMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetadataResponse_TensorMetadata(const ModelMetadataResponse_TensorMetadata& from);
  ModelMetadataResponse_TensorMetadata(ModelMetadataResponse_TensorMetadata&& from) noexcept
    : ModelMetadataResponse_TensorMetadata() {
    *this = ::std::move(from);
  }

  inline ModelMetadataResponse_TensorMetadata& operator=(const ModelMetadataResponse_TensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetadataResponse_TensorMetadata& operator=(ModelMetadataResponse_TensorMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetadataResponse_TensorMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetadataResponse_TensorMetadata* internal_default_instance() {
    return reinterpret_cast<const ModelMetadataResponse_TensorMetadata*>(
               &_ModelMetadataResponse_TensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelMetadataResponse_TensorMetadata& a, ModelMetadataResponse_TensorMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetadataResponse_TensorMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetadataResponse_TensorMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetadataResponse_TensorMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetadataResponse_TensorMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetadataResponse_TensorMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetadataResponse_TensorMetadata& from) {
    ModelMetadataResponse_TensorMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetadataResponse_TensorMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelMetadataResponse.TensorMetadata";
  }
  protected:
  explicit ModelMetadataResponse_TensorMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kNameFieldNumber = 1,
    kDatatypeFieldNumber = 2,
  };
  // repeated int64 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string datatype = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelMetadataResponse.TensorMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelMetadataResponse) */ {
 public:
  inline ModelMetadataResponse() : ModelMetadataResponse(nullptr) {}
  ~ModelMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetadataResponse(const ModelMetadataResponse& from);
  ModelMetadataResponse(ModelMetadataResponse&& from) noexcept
    : ModelMetadataResponse() {
    *this = ::std::move(from);
  }

  inline ModelMetadataResponse& operator=(const ModelMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetadataResponse& operator=(ModelMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const ModelMetadataResponse*>(
               &_ModelMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModelMetadataResponse& a, ModelMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetadataResponse& from) {
    ModelMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelMetadataResponse";
  }
  protected:
  explicit ModelMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelMetadataResponse_TensorMetadata TensorMetadata;

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 2,
    kInputsFieldNumber = 4,
    kOutputsFieldNumber = 5,
    kNameFieldNumber = 1,
    kPlatformFieldNumber = 3,
  };
  // repeated string versions = 2;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // repeated .inference.ModelMetadataResponse.TensorMetadata inputs = 4;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::inference::ModelMetadataResponse_TensorMetadata* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
      mutable_inputs();
  private:
  const ::inference::ModelMetadataResponse_TensorMetadata& _internal_inputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* _internal_add_inputs();
  public:
  const ::inference::ModelMetadataResponse_TensorMetadata& inputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
      inputs() const;

  // repeated .inference.ModelMetadataResponse.TensorMetadata outputs = 5;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::ModelMetadataResponse_TensorMetadata* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
      mutable_outputs();
  private:
  const ::inference::ModelMetadataResponse_TensorMetadata& _internal_outputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* _internal_add_outputs();
  public:
  const ::inference::ModelMetadataResponse_TensorMetadata& outputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
      outputs() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string platform = 3;
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata > outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferParameter) */ {
 public:
  inline InferParameter() : InferParameter(nullptr) {}
  ~InferParameter() override;
  explicit PROTOBUF_CONSTEXPR InferParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferParameter(const InferParameter& from);
  InferParameter(InferParameter&& from) noexcept
    : InferParameter() {
    *this = ::std::move(from);
  }

  inline InferParameter& operator=(const InferParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferParameter& operator=(InferParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferParameter& default_instance() {
    return *internal_default_instance();
  }
  enum ParameterChoiceCase {
    kBoolParam = 1,
    kInt64Param = 2,
    kStringParam = 3,
    kDoubleParam = 4,
    kUint64Param = 5,
    PARAMETER_CHOICE_NOT_SET = 0,
  };

  static inline const InferParameter* internal_default_instance() {
    return reinterpret_cast<const InferParameter*>(
               &_InferParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InferParameter& a, InferParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(InferParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferParameter& from) {
    InferParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferParameter";
  }
  protected:
  explicit InferParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolParamFieldNumber = 1,
    kInt64ParamFieldNumber = 2,
    kStringParamFieldNumber = 3,
    kDoubleParamFieldNumber = 4,
    kUint64ParamFieldNumber = 5,
  };
  // bool bool_param = 1;
  bool has_bool_param() const;
  private:
  bool _internal_has_bool_param() const;
  public:
  void clear_bool_param();
  bool bool_param() const;
  void set_bool_param(bool value);
  private:
  bool _internal_bool_param() const;
  void _internal_set_bool_param(bool value);
  public:

  // int64 int64_param = 2;
  bool has_int64_param() const;
  private:
  bool _internal_has_int64_param() const;
  public:
  void clear_int64_param();
  int64_t int64_param() const;
  void set_int64_param(int64_t value);
  private:
  int64_t _internal_int64_param() const;
  void _internal_set_int64_param(int64_t value);
  public:

  // string string_param = 3;
  bool has_string_param() const;
  private:
  bool _internal_has_string_param() const;
  public:
  void clear_string_param();
  const std::string& string_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_param();
  PROTOBUF_NODISCARD std::string* release_string_param();
  void set_allocated_string_param(std::string* string_param);
  private:
  const std::string& _internal_string_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_param(const std::string& value);
  std::string* _internal_mutable_string_param();
  public:

  // double double_param = 4;
  bool has_double_param() const;
  private:
  bool _internal_has_double_param() const;
  public:
  void clear_double_param();
  double double_param() const;
  void set_double_param(double value);
  private:
  double _internal_double_param() const;
  void _internal_set_double_param(double value);
  public:

  // uint64 uint64_param = 5;
  bool has_uint64_param() const;
  private:
  bool _internal_has_uint64_param() const;
  public:
  void clear_uint64_param();
  uint64_t uint64_param() const;
  void set_uint64_param(uint64_t value);
  private:
  uint64_t _internal_uint64_param() const;
  void _internal_set_uint64_param(uint64_t value);
  public:

  void clear_parameter_choice();
  ParameterChoiceCase parameter_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.InferParameter)
 private:
  class _Internal;
  void set_has_bool_param();
  void set_has_int64_param();
  void set_has_string_param();
  void set_has_double_param();
  void set_has_uint64_param();

  inline bool has_parameter_choice() const;
  inline void clear_has_parameter_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ParameterChoiceUnion {
      constexpr ParameterChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool bool_param_;
      int64_t int64_param_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_param_;
      double double_param_;
      uint64_t uint64_param_;
    } parameter_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferTensorContents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferTensorContents) */ {
 public:
  inline InferTensorContents() : InferTensorContents(nullptr) {}
  ~InferTensorContents() override;
  explicit PROTOBUF_CONSTEXPR InferTensorContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferTensorContents(const InferTensorContents& from);
  InferTensorContents(InferTensorContents&& from) noexcept
    : InferTensorContents() {
    *this = ::std::move(from);
  }

  inline InferTensorContents& operator=(const InferTensorContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferTensorContents& operator=(InferTensorContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferTensorContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferTensorContents* internal_default_instance() {
    return reinterpret_cast<const InferTensorContents*>(
               &_InferTensorContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InferTensorContents& a, InferTensorContents& b) {
    a.Swap(&b);
  }
  inline void Swap(InferTensorContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferTensorContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferTensorContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferTensorContents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferTensorContents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferTensorContents& from) {
    InferTensorContents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferTensorContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferTensorContents";
  }
  protected:
  explicit InferTensorContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolContentsFieldNumber = 1,
    kIntContentsFieldNumber = 2,
    kInt64ContentsFieldNumber = 3,
    kUintContentsFieldNumber = 4,
    kUint64ContentsFieldNumber = 5,
    kFp32ContentsFieldNumber = 6,
    kFp64ContentsFieldNumber = 7,
    kBytesContentsFieldNumber = 8,
  };
  // repeated bool bool_contents = 1;
  int bool_contents_size() const;
  private:
  int _internal_bool_contents_size() const;
  public:
  void clear_bool_contents();
  private:
  bool _internal_bool_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_bool_contents() const;
  void _internal_add_bool_contents(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_bool_contents();
  public:
  bool bool_contents(int index) const;
  void set_bool_contents(int index, bool value);
  void add_bool_contents(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      bool_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_bool_contents();

  // repeated int32 int_contents = 2;
  int int_contents_size() const;
  private:
  int _internal_int_contents_size() const;
  public:
  void clear_int_contents();
  private:
  int32_t _internal_int_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_int_contents() const;
  void _internal_add_int_contents(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_int_contents();
  public:
  int32_t int_contents(int index) const;
  void set_int_contents(int index, int32_t value);
  void add_int_contents(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      int_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_int_contents();

  // repeated int64 int64_contents = 3;
  int int64_contents_size() const;
  private:
  int _internal_int64_contents_size() const;
  public:
  void clear_int64_contents();
  private:
  int64_t _internal_int64_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_int64_contents() const;
  void _internal_add_int64_contents(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_int64_contents();
  public:
  int64_t int64_contents(int index) const;
  void set_int64_contents(int index, int64_t value);
  void add_int64_contents(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      int64_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_int64_contents();

  // repeated uint32 uint_contents = 4;
  int uint_contents_size() const;
  private:
  int _internal_uint_contents_size() const;
  public:
  void clear_uint_contents();
  private:
  uint32_t _internal_uint_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_uint_contents() const;
  void _internal_add_uint_contents(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_uint_contents();
  public:
  uint32_t uint_contents(int index) const;
  void set_uint_contents(int index, uint32_t value);
  void add_uint_contents(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      uint_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_uint_contents();

  // repeated uint64 uint64_contents = 5;
  int uint64_contents_size() const;
  private:
  int _internal_uint64_contents_size() const;
  public:
  void clear_uint64_contents();
  private:
  uint64_t _internal_uint64_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_uint64_contents() const;
  void _internal_add_uint64_contents(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_uint64_contents();
  public:
  uint64_t uint64_contents(int index) const;
  void set_uint64_contents(int index, uint64_t value);
  void add_uint64_contents(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      uint64_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_uint64_contents();

  // repeated float fp32_contents = 6;
  int fp32_contents_size() const;
  private:
  int _internal_fp32_contents_size() const;
  public:
  void clear_fp32_contents();
  private:
  float _internal_fp32_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fp32_contents() const;
  void _internal_add_fp32_contents(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fp32_contents();
  public:
  float fp32_contents(int index) const;
  void set_fp32_contents(int index, float value);
  void add_fp32_contents(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fp32_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fp32_contents();

  // repeated double fp64_contents = 7;
  int fp64_contents_size() const;
  private:
  int _internal_fp64_contents_size() const;
  public:
  void clear_fp64_contents();
  private:
  double _internal_fp64_contents(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_fp64_contents() const;
  void _internal_add_fp64_contents(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_fp64_contents();
  public:
  double fp64_contents(int index) const;
  void set_fp64_contents(int index, double value);
  void add_fp64_contents(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      fp64_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_fp64_contents();

  // repeated bytes bytes_contents = 8;
  int bytes_contents_size() const;
  private:
  int _internal_bytes_contents_size() const;
  public:
  void clear_bytes_contents();
  const std::string& bytes_contents(int index) const;
  std::string* mutable_bytes_contents(int index);
  void set_bytes_contents(int index, const std::string& value);
  void set_bytes_contents(int index, std::string&& value);
  void set_bytes_contents(int index, const char* value);
  void set_bytes_contents(int index, const void* value, size_t size);
  std::string* add_bytes_contents();
  void add_bytes_contents(const std::string& value);
  void add_bytes_contents(std::string&& value);
  void add_bytes_contents(const char* value);
  void add_bytes_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bytes_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bytes_contents();
  private:
  const std::string& _internal_bytes_contents(int index) const;
  std::string* _internal_add_bytes_contents();
  public:

  // @@protoc_insertion_point(class_scope:inference.InferTensorContents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > bool_contents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > int_contents_;
    mutable std::atomic<int> _int_contents_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > int64_contents_;
    mutable std::atomic<int> _int64_contents_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > uint_contents_;
    mutable std::atomic<int> _uint_contents_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > uint64_contents_;
    mutable std::atomic<int> _uint64_contents_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fp32_contents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > fp64_contents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bytes_contents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse& other);
  static const ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse*>(&_ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferRequest.InferInputTensor.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferRequest_InferInputTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferRequest.InferInputTensor) */ {
 public:
  inline ModelInferRequest_InferInputTensor() : ModelInferRequest_InferInputTensor(nullptr) {}
  ~ModelInferRequest_InferInputTensor() override;
  explicit PROTOBUF_CONSTEXPR ModelInferRequest_InferInputTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferRequest_InferInputTensor(const ModelInferRequest_InferInputTensor& from);
  ModelInferRequest_InferInputTensor(ModelInferRequest_InferInputTensor&& from) noexcept
    : ModelInferRequest_InferInputTensor() {
    *this = ::std::move(from);
  }

  inline ModelInferRequest_InferInputTensor& operator=(const ModelInferRequest_InferInputTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferRequest_InferInputTensor& operator=(ModelInferRequest_InferInputTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferRequest_InferInputTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferRequest_InferInputTensor* internal_default_instance() {
    return reinterpret_cast<const ModelInferRequest_InferInputTensor*>(
               &_ModelInferRequest_InferInputTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ModelInferRequest_InferInputTensor& a, ModelInferRequest_InferInputTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferRequest_InferInputTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferRequest_InferInputTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferRequest_InferInputTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferRequest_InferInputTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferRequest_InferInputTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferRequest_InferInputTensor& from) {
    ModelInferRequest_InferInputTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferRequest_InferInputTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferRequest.InferInputTensor";
  }
  protected:
  explicit ModelInferRequest_InferInputTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kParametersFieldNumber = 4,
    kNameFieldNumber = 1,
    kDatatypeFieldNumber = 2,
    kContentsFieldNumber = 5,
  };
  // repeated int64 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string datatype = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // .inference.InferTensorContents contents = 5;
  bool has_contents() const;
  private:
  bool _internal_has_contents() const;
  public:
  void clear_contents();
  const ::inference::InferTensorContents& contents() const;
  PROTOBUF_NODISCARD ::inference::InferTensorContents* release_contents();
  ::inference::InferTensorContents* mutable_contents();
  void set_allocated_contents(::inference::InferTensorContents* contents);
  private:
  const ::inference::InferTensorContents& _internal_contents() const;
  ::inference::InferTensorContents* _internal_mutable_contents();
  public:
  void unsafe_arena_set_allocated_contents(
      ::inference::InferTensorContents* contents);
  ::inference::InferTensorContents* unsafe_arena_release_contents();

  // @@protoc_insertion_point(class_scope:inference.ModelInferRequest.InferInputTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferRequest_InferInputTensor_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    ::inference::InferTensorContents* contents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse& other);
  static const ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse*>(&_ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferRequest.InferRequestedOutputTensor.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferRequest_InferRequestedOutputTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferRequest.InferRequestedOutputTensor) */ {
 public:
  inline ModelInferRequest_InferRequestedOutputTensor() : ModelInferRequest_InferRequestedOutputTensor(nullptr) {}
  ~ModelInferRequest_InferRequestedOutputTensor() override;
  explicit PROTOBUF_CONSTEXPR ModelInferRequest_InferRequestedOutputTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferRequest_InferRequestedOutputTensor(const ModelInferRequest_InferRequestedOutputTensor& from);
  ModelInferRequest_InferRequestedOutputTensor(ModelInferRequest_InferRequestedOutputTensor&& from) noexcept
    : ModelInferRequest_InferRequestedOutputTensor() {
    *this = ::std::move(from);
  }

  inline ModelInferRequest_InferRequestedOutputTensor& operator=(const ModelInferRequest_InferRequestedOutputTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferRequest_InferRequestedOutputTensor& operator=(ModelInferRequest_InferRequestedOutputTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferRequest_InferRequestedOutputTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferRequest_InferRequestedOutputTensor* internal_default_instance() {
    return reinterpret_cast<const ModelInferRequest_InferRequestedOutputTensor*>(
               &_ModelInferRequest_InferRequestedOutputTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ModelInferRequest_InferRequestedOutputTensor& a, ModelInferRequest_InferRequestedOutputTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferRequest_InferRequestedOutputTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferRequest_InferRequestedOutputTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferRequest_InferRequestedOutputTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferRequest_InferRequestedOutputTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferRequest_InferRequestedOutputTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferRequest_InferRequestedOutputTensor& from) {
    ModelInferRequest_InferRequestedOutputTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferRequest_InferRequestedOutputTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferRequest.InferRequestedOutputTensor";
  }
  protected:
  explicit ModelInferRequest_InferRequestedOutputTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, .inference.InferParameter> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInferRequest.InferRequestedOutputTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferRequest_InferRequestedOutputTensor_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferRequest_ParametersEntry_DoNotUse& other);
  static const ModelInferRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferRequest_ParametersEntry_DoNotUse*>(&_ModelInferRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferRequest.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferRequest) */ {
 public:
  inline ModelInferRequest() : ModelInferRequest(nullptr) {}
  ~ModelInferRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelInferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferRequest(const ModelInferRequest& from);
  ModelInferRequest(ModelInferRequest&& from) noexcept
    : ModelInferRequest() {
    *this = ::std::move(from);
  }

  inline ModelInferRequest& operator=(const ModelInferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferRequest& operator=(ModelInferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferRequest* internal_default_instance() {
    return reinterpret_cast<const ModelInferRequest*>(
               &_ModelInferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ModelInferRequest& a, ModelInferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferRequest& from) {
    ModelInferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferRequest";
  }
  protected:
  explicit ModelInferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelInferRequest_InferInputTensor InferInputTensor;
  typedef ModelInferRequest_InferRequestedOutputTensor InferRequestedOutputTensor;

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kInputsFieldNumber = 5,
    kOutputsFieldNumber = 6,
    kRawInputContentsFieldNumber = 7,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // repeated .inference.ModelInferRequest.InferInputTensor inputs = 5;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::inference::ModelInferRequest_InferInputTensor* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferInputTensor >*
      mutable_inputs();
  private:
  const ::inference::ModelInferRequest_InferInputTensor& _internal_inputs(int index) const;
  ::inference::ModelInferRequest_InferInputTensor* _internal_add_inputs();
  public:
  const ::inference::ModelInferRequest_InferInputTensor& inputs(int index) const;
  ::inference::ModelInferRequest_InferInputTensor* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferInputTensor >&
      inputs() const;

  // repeated .inference.ModelInferRequest.InferRequestedOutputTensor outputs = 6;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::ModelInferRequest_InferRequestedOutputTensor* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferRequestedOutputTensor >*
      mutable_outputs();
  private:
  const ::inference::ModelInferRequest_InferRequestedOutputTensor& _internal_outputs(int index) const;
  ::inference::ModelInferRequest_InferRequestedOutputTensor* _internal_add_outputs();
  public:
  const ::inference::ModelInferRequest_InferRequestedOutputTensor& outputs(int index) const;
  ::inference::ModelInferRequest_InferRequestedOutputTensor* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferRequestedOutputTensor >&
      outputs() const;

  // repeated bytes raw_input_contents = 7;
  int raw_input_contents_size() const;
  private:
  int _internal_raw_input_contents_size() const;
  public:
  void clear_raw_input_contents();
  const std::string& raw_input_contents(int index) const;
  std::string* mutable_raw_input_contents(int index);
  void set_raw_input_contents(int index, const std::string& value);
  void set_raw_input_contents(int index, std::string&& value);
  void set_raw_input_contents(int index, const char* value);
  void set_raw_input_contents(int index, const void* value, size_t size);
  std::string* add_raw_input_contents();
  void add_raw_input_contents(const std::string& value);
  void add_raw_input_contents(std::string&& value);
  void add_raw_input_contents(const char* value);
  void add_raw_input_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_input_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_input_contents();
  private:
  const std::string& _internal_raw_input_contents(int index) const;
  std::string* _internal_add_raw_input_contents();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferRequest_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferInputTensor > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferRequestedOutputTensor > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_input_contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse& other);
  static const ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse*>(&_ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferResponse.InferOutputTensor.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferResponse_InferOutputTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferResponse.InferOutputTensor) */ {
 public:
  inline ModelInferResponse_InferOutputTensor() : ModelInferResponse_InferOutputTensor(nullptr) {}
  ~ModelInferResponse_InferOutputTensor() override;
  explicit PROTOBUF_CONSTEXPR ModelInferResponse_InferOutputTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferResponse_InferOutputTensor(const ModelInferResponse_InferOutputTensor& from);
  ModelInferResponse_InferOutputTensor(ModelInferResponse_InferOutputTensor&& from) noexcept
    : ModelInferResponse_InferOutputTensor() {
    *this = ::std::move(from);
  }

  inline ModelInferResponse_InferOutputTensor& operator=(const ModelInferResponse_InferOutputTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferResponse_InferOutputTensor& operator=(ModelInferResponse_InferOutputTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferResponse_InferOutputTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferResponse_InferOutputTensor* internal_default_instance() {
    return reinterpret_cast<const ModelInferResponse_InferOutputTensor*>(
               &_ModelInferResponse_InferOutputTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ModelInferResponse_InferOutputTensor& a, ModelInferResponse_InferOutputTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferResponse_InferOutputTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferResponse_InferOutputTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferResponse_InferOutputTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferResponse_InferOutputTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferResponse_InferOutputTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferResponse_InferOutputTensor& from) {
    ModelInferResponse_InferOutputTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferResponse_InferOutputTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferResponse.InferOutputTensor";
  }
  protected:
  explicit ModelInferResponse_InferOutputTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kParametersFieldNumber = 4,
    kNameFieldNumber = 1,
    kDatatypeFieldNumber = 2,
    kContentsFieldNumber = 5,
  };
  // repeated int64 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string datatype = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // .inference.InferTensorContents contents = 5;
  bool has_contents() const;
  private:
  bool _internal_has_contents() const;
  public:
  void clear_contents();
  const ::inference::InferTensorContents& contents() const;
  PROTOBUF_NODISCARD ::inference::InferTensorContents* release_contents();
  ::inference::InferTensorContents* mutable_contents();
  void set_allocated_contents(::inference::InferTensorContents* contents);
  private:
  const ::inference::InferTensorContents& _internal_contents() const;
  ::inference::InferTensorContents* _internal_mutable_contents();
  public:
  void unsafe_arena_set_allocated_contents(
      ::inference::InferTensorContents* contents);
  ::inference::InferTensorContents* unsafe_arena_release_contents();

  // @@protoc_insertion_point(class_scope:inference.ModelInferResponse.InferOutputTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferResponse_InferOutputTensor_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    ::inference::InferTensorContents* contents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferResponse_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferResponse_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferResponse_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferResponse_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferResponse_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferResponse_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferResponse_ParametersEntry_DoNotUse& other);
  static const ModelInferResponse_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferResponse_ParametersEntry_DoNotUse*>(&_ModelInferResponse_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferResponse.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferResponse) */ {
 public:
  inline ModelInferResponse() : ModelInferResponse(nullptr) {}
  ~ModelInferResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelInferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferResponse(const ModelInferResponse& from);
  ModelInferResponse(ModelInferResponse&& from) noexcept
    : ModelInferResponse() {
    *this = ::std::move(from);
  }

  inline ModelInferResponse& operator=(const ModelInferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferResponse& operator=(ModelInferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferResponse* internal_default_instance() {
    return reinterpret_cast<const ModelInferResponse*>(
               &_ModelInferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ModelInferResponse& a, ModelInferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferResponse& from) {
    ModelInferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferResponse";
  }
  protected:
  explicit ModelInferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelInferResponse_InferOutputTensor InferOutputTensor;

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kOutputsFieldNumber = 5,
    kRawOutputContentsFieldNumber = 6,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // repeated .inference.ModelInferResponse.InferOutputTensor outputs = 5;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::ModelInferResponse_InferOutputTensor* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferResponse_InferOutputTensor >*
      mutable_outputs();
  private:
  const ::inference::ModelInferResponse_InferOutputTensor& _internal_outputs(int index) const;
  ::inference::ModelInferResponse_InferOutputTensor* _internal_add_outputs();
  public:
  const ::inference::ModelInferResponse_InferOutputTensor& outputs(int index) const;
  ::inference::ModelInferResponse_InferOutputTensor* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferResponse_InferOutputTensor >&
      outputs() const;

  // repeated bytes raw_output_contents = 6;
  int raw_output_contents_size() const;
  private:
  int _internal_raw_output_contents_size() const;
  public:
  void clear_raw_output_contents();
  const std::string& raw_output_contents(int index) const;
  std::string* mutable_raw_output_contents(int index);
  void set_raw_output_contents(int index, const std::string& value);
  void set_raw_output_contents(int index, std::string&& value);
  void set_raw_output_contents(int index, const char* value);
  void set_raw_output_contents(int index, const void* value, size_t size);
  std::string* add_raw_output_contents();
  void add_raw_output_contents(const std::string& value);
  void add_raw_output_contents(std::string&& value);
  void add_raw_output_contents(const char* value);
  void add_raw_output_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_output_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_output_contents();
  private:
  const std::string& _internal_raw_output_contents(int index) const;
  std::string* _internal_add_raw_output_contents();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferResponse_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferResponse_InferOutputTensor > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_output_contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStreamInferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStreamInferResponse) */ {
 public:
  inline ModelStreamInferResponse() : ModelStreamInferResponse(nullptr) {}
  ~ModelStreamInferResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelStreamInferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStreamInferResponse(const ModelStreamInferResponse& from);
  ModelStreamInferResponse(ModelStreamInferResponse&& from) noexcept
    : ModelStreamInferResponse() {
    *this = ::std::move(from);
  }

  inline ModelStreamInferResponse& operator=(const ModelStreamInferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStreamInferResponse& operator=(ModelStreamInferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStreamInferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStreamInferResponse* internal_default_instance() {
    return reinterpret_cast<const ModelStreamInferResponse*>(
               &_ModelStreamInferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ModelStreamInferResponse& a, ModelStreamInferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStreamInferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStreamInferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStreamInferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStreamInferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStreamInferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStreamInferResponse& from) {
    ModelStreamInferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStreamInferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStreamInferResponse";
  }
  protected:
  explicit ModelStreamInferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
    kInferResponseFieldNumber = 2,
  };
  // string error_message = 1;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .inference.ModelInferResponse infer_response = 2;
  bool has_infer_response() const;
  private:
  bool _internal_has_infer_response() const;
  public:
  void clear_infer_response();
  const ::inference::ModelInferResponse& infer_response() const;
  PROTOBUF_NODISCARD ::inference::ModelInferResponse* release_infer_response();
  ::inference::ModelInferResponse* mutable_infer_response();
  void set_allocated_infer_response(::inference::ModelInferResponse* infer_response);
  private:
  const ::inference::ModelInferResponse& _internal_infer_response() const;
  ::inference::ModelInferResponse* _internal_mutable_infer_response();
  public:
  void unsafe_arena_set_allocated_infer_response(
      ::inference::ModelInferResponse* infer_response);
  ::inference::ModelInferResponse* unsafe_arena_release_infer_response();

  // @@protoc_insertion_point(class_scope:inference.ModelStreamInferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::inference::ModelInferResponse* infer_response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelConfigRequest) */ {
 public:
  inline ModelConfigRequest() : ModelConfigRequest(nullptr) {}
  ~ModelConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelConfigRequest(const ModelConfigRequest& from);
  ModelConfigRequest(ModelConfigRequest&& from) noexcept
    : ModelConfigRequest() {
    *this = ::std::move(from);
  }

  inline ModelConfigRequest& operator=(const ModelConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfigRequest& operator=(ModelConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ModelConfigRequest*>(
               &_ModelConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ModelConfigRequest& a, ModelConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelConfigRequest& from) {
    ModelConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelConfigRequest";
  }
  protected:
  explicit ModelConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelConfigResponse) */ {
 public:
  inline ModelConfigResponse() : ModelConfigResponse(nullptr) {}
  ~ModelConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelConfigResponse(const ModelConfigResponse& from);
  ModelConfigResponse(ModelConfigResponse&& from) noexcept
    : ModelConfigResponse() {
    *this = ::std::move(from);
  }

  inline ModelConfigResponse& operator=(const ModelConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfigResponse& operator=(ModelConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ModelConfigResponse*>(
               &_ModelConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ModelConfigResponse& a, ModelConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelConfigResponse& from) {
    ModelConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelConfigResponse";
  }
  protected:
  explicit ModelConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .inference.ModelConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::inference::ModelConfig& config() const;
  PROTOBUF_NODISCARD ::inference::ModelConfig* release_config();
  ::inference::ModelConfig* mutable_config();
  void set_allocated_config(::inference::ModelConfig* config);
  private:
  const ::inference::ModelConfig& _internal_config() const;
  ::inference::ModelConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::inference::ModelConfig* config);
  ::inference::ModelConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:inference.ModelConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::inference::ModelConfig* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStatisticsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStatisticsRequest) */ {
 public:
  inline ModelStatisticsRequest() : ModelStatisticsRequest(nullptr) {}
  ~ModelStatisticsRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelStatisticsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatisticsRequest(const ModelStatisticsRequest& from);
  ModelStatisticsRequest(ModelStatisticsRequest&& from) noexcept
    : ModelStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline ModelStatisticsRequest& operator=(const ModelStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatisticsRequest& operator=(ModelStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const ModelStatisticsRequest*>(
               &_ModelStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ModelStatisticsRequest& a, ModelStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatisticsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatisticsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatisticsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatisticsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStatisticsRequest& from) {
    ModelStatisticsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatisticsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStatisticsRequest";
  }
  protected:
  explicit ModelStatisticsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelStatisticsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class StatisticDuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.StatisticDuration) */ {
 public:
  inline StatisticDuration() : StatisticDuration(nullptr) {}
  ~StatisticDuration() override;
  explicit PROTOBUF_CONSTEXPR StatisticDuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatisticDuration(const StatisticDuration& from);
  StatisticDuration(StatisticDuration&& from) noexcept
    : StatisticDuration() {
    *this = ::std::move(from);
  }

  inline StatisticDuration& operator=(const StatisticDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatisticDuration& operator=(StatisticDuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatisticDuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatisticDuration* internal_default_instance() {
    return reinterpret_cast<const StatisticDuration*>(
               &_StatisticDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(StatisticDuration& a, StatisticDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(StatisticDuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatisticDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatisticDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatisticDuration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatisticDuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatisticDuration& from) {
    StatisticDuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatisticDuration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.StatisticDuration";
  }
  protected:
  explicit StatisticDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
    kNsFieldNumber = 2,
  };
  // uint64 count = 1;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // uint64 ns = 2;
  void clear_ns();
  uint64_t ns() const;
  void set_ns(uint64_t value);
  private:
  uint64_t _internal_ns() const;
  void _internal_set_ns(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.StatisticDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t count_;
    uint64_t ns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferStatistics) */ {
 public:
  inline InferStatistics() : InferStatistics(nullptr) {}
  ~InferStatistics() override;
  explicit PROTOBUF_CONSTEXPR InferStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferStatistics(const InferStatistics& from);
  InferStatistics(InferStatistics&& from) noexcept
    : InferStatistics() {
    *this = ::std::move(from);
  }

  inline InferStatistics& operator=(const InferStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferStatistics& operator=(InferStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferStatistics* internal_default_instance() {
    return reinterpret_cast<const InferStatistics*>(
               &_InferStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(InferStatistics& a, InferStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(InferStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferStatistics& from) {
    InferStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferStatistics";
  }
  protected:
  explicit InferStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailFieldNumber = 2,
    kQueueFieldNumber = 3,
    kComputeInputFieldNumber = 4,
    kComputeInferFieldNumber = 5,
    kComputeOutputFieldNumber = 6,
    kCacheHitFieldNumber = 7,
    kCacheMissFieldNumber = 8,
  };
  // .inference.StatisticDuration success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  const ::inference::StatisticDuration& success() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_success();
  ::inference::StatisticDuration* mutable_success();
  void set_allocated_success(::inference::StatisticDuration* success);
  private:
  const ::inference::StatisticDuration& _internal_success() const;
  ::inference::StatisticDuration* _internal_mutable_success();
  public:
  void unsafe_arena_set_allocated_success(
      ::inference::StatisticDuration* success);
  ::inference::StatisticDuration* unsafe_arena_release_success();

  // .inference.StatisticDuration fail = 2;
  bool has_fail() const;
  private:
  bool _internal_has_fail() const;
  public:
  void clear_fail();
  const ::inference::StatisticDuration& fail() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_fail();
  ::inference::StatisticDuration* mutable_fail();
  void set_allocated_fail(::inference::StatisticDuration* fail);
  private:
  const ::inference::StatisticDuration& _internal_fail() const;
  ::inference::StatisticDuration* _internal_mutable_fail();
  public:
  void unsafe_arena_set_allocated_fail(
      ::inference::StatisticDuration* fail);
  ::inference::StatisticDuration* unsafe_arena_release_fail();

  // .inference.StatisticDuration queue = 3;
  bool has_queue() const;
  private:
  bool _internal_has_queue() const;
  public:
  void clear_queue();
  const ::inference::StatisticDuration& queue() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_queue();
  ::inference::StatisticDuration* mutable_queue();
  void set_allocated_queue(::inference::StatisticDuration* queue);
  private:
  const ::inference::StatisticDuration& _internal_queue() const;
  ::inference::StatisticDuration* _internal_mutable_queue();
  public:
  void unsafe_arena_set_allocated_queue(
      ::inference::StatisticDuration* queue);
  ::inference::StatisticDuration* unsafe_arena_release_queue();

  // .inference.StatisticDuration compute_input = 4;
  bool has_compute_input() const;
  private:
  bool _internal_has_compute_input() const;
  public:
  void clear_compute_input();
  const ::inference::StatisticDuration& compute_input() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_compute_input();
  ::inference::StatisticDuration* mutable_compute_input();
  void set_allocated_compute_input(::inference::StatisticDuration* compute_input);
  private:
  const ::inference::StatisticDuration& _internal_compute_input() const;
  ::inference::StatisticDuration* _internal_mutable_compute_input();
  public:
  void unsafe_arena_set_allocated_compute_input(
      ::inference::StatisticDuration* compute_input);
  ::inference::StatisticDuration* unsafe_arena_release_compute_input();

  // .inference.StatisticDuration compute_infer = 5;
  bool has_compute_infer() const;
  private:
  bool _internal_has_compute_infer() const;
  public:
  void clear_compute_infer();
  const ::inference::StatisticDuration& compute_infer() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_compute_infer();
  ::inference::StatisticDuration* mutable_compute_infer();
  void set_allocated_compute_infer(::inference::StatisticDuration* compute_infer);
  private:
  const ::inference::StatisticDuration& _internal_compute_infer() const;
  ::inference::StatisticDuration* _internal_mutable_compute_infer();
  public:
  void unsafe_arena_set_allocated_compute_infer(
      ::inference::StatisticDuration* compute_infer);
  ::inference::StatisticDuration* unsafe_arena_release_compute_infer();

  // .inference.StatisticDuration compute_output = 6;
  bool has_compute_output() const;
  private:
  bool _internal_has_compute_output() const;
  public:
  void clear_compute_output();
  const ::inference::StatisticDuration& compute_output() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_compute_output();
  ::inference::StatisticDuration* mutable_compute_output();
  void set_allocated_compute_output(::inference::StatisticDuration* compute_output);
  private:
  const ::inference::StatisticDuration& _internal_compute_output() const;
  ::inference::StatisticDuration* _internal_mutable_compute_output();
  public:
  void unsafe_arena_set_allocated_compute_output(
      ::inference::StatisticDuration* compute_output);
  ::inference::StatisticDuration* unsafe_arena_release_compute_output();

  // .inference.StatisticDuration cache_hit = 7;
  bool has_cache_hit() const;
  private:
  bool _internal_has_cache_hit() const;
  public:
  void clear_cache_hit();
  const ::inference::StatisticDuration& cache_hit() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_cache_hit();
  ::inference::StatisticDuration* mutable_cache_hit();
  void set_allocated_cache_hit(::inference::StatisticDuration* cache_hit);
  private:
  const ::inference::StatisticDuration& _internal_cache_hit() const;
  ::inference::StatisticDuration* _internal_mutable_cache_hit();
  public:
  void unsafe_arena_set_allocated_cache_hit(
      ::inference::StatisticDuration* cache_hit);
  ::inference::StatisticDuration* unsafe_arena_release_cache_hit();

  // .inference.StatisticDuration cache_miss = 8;
  bool has_cache_miss() const;
  private:
  bool _internal_has_cache_miss() const;
  public:
  void clear_cache_miss();
  const ::inference::StatisticDuration& cache_miss() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_cache_miss();
  ::inference::StatisticDuration* mutable_cache_miss();
  void set_allocated_cache_miss(::inference::StatisticDuration* cache_miss);
  private:
  const ::inference::StatisticDuration& _internal_cache_miss() const;
  ::inference::StatisticDuration* _internal_mutable_cache_miss();
  public:
  void unsafe_arena_set_allocated_cache_miss(
      ::inference::StatisticDuration* cache_miss);
  ::inference::StatisticDuration* unsafe_arena_release_cache_miss();

  // @@protoc_insertion_point(class_scope:inference.InferStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::inference::StatisticDuration* success_;
    ::inference::StatisticDuration* fail_;
    ::inference::StatisticDuration* queue_;
    ::inference::StatisticDuration* compute_input_;
    ::inference::StatisticDuration* compute_infer_;
    ::inference::StatisticDuration* compute_output_;
    ::inference::StatisticDuration* cache_hit_;
    ::inference::StatisticDuration* cache_miss_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferBatchStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferBatchStatistics) */ {
 public:
  inline InferBatchStatistics() : InferBatchStatistics(nullptr) {}
  ~InferBatchStatistics() override;
  explicit PROTOBUF_CONSTEXPR InferBatchStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferBatchStatistics(const InferBatchStatistics& from);
  InferBatchStatistics(InferBatchStatistics&& from) noexcept
    : InferBatchStatistics() {
    *this = ::std::move(from);
  }

  inline InferBatchStatistics& operator=(const InferBatchStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferBatchStatistics& operator=(InferBatchStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferBatchStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferBatchStatistics* internal_default_instance() {
    return reinterpret_cast<const InferBatchStatistics*>(
               &_InferBatchStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(InferBatchStatistics& a, InferBatchStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(InferBatchStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferBatchStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferBatchStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferBatchStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferBatchStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferBatchStatistics& from) {
    InferBatchStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferBatchStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferBatchStatistics";
  }
  protected:
  explicit InferBatchStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComputeInputFieldNumber = 2,
    kComputeInferFieldNumber = 3,
    kComputeOutputFieldNumber = 4,
    kBatchSizeFieldNumber = 1,
  };
  // .inference.StatisticDuration compute_input = 2;
  bool has_compute_input() const;
  private:
  bool _internal_has_compute_input() const;
  public:
  void clear_compute_input();
  const ::inference::StatisticDuration& compute_input() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_compute_input();
  ::inference::StatisticDuration* mutable_compute_input();
  void set_allocated_compute_input(::inference::StatisticDuration* compute_input);
  private:
  const ::inference::StatisticDuration& _internal_compute_input() const;
  ::inference::StatisticDuration* _internal_mutable_compute_input();
  public:
  void unsafe_arena_set_allocated_compute_input(
      ::inference::StatisticDuration* compute_input);
  ::inference::StatisticDuration* unsafe_arena_release_compute_input();

  // .inference.StatisticDuration compute_infer = 3;
  bool has_compute_infer() const;
  private:
  bool _internal_has_compute_infer() const;
  public:
  void clear_compute_infer();
  const ::inference::StatisticDuration& compute_infer() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_compute_infer();
  ::inference::StatisticDuration* mutable_compute_infer();
  void set_allocated_compute_infer(::inference::StatisticDuration* compute_infer);
  private:
  const ::inference::StatisticDuration& _internal_compute_infer() const;
  ::inference::StatisticDuration* _internal_mutable_compute_infer();
  public:
  void unsafe_arena_set_allocated_compute_infer(
      ::inference::StatisticDuration* compute_infer);
  ::inference::StatisticDuration* unsafe_arena_release_compute_infer();

  // .inference.StatisticDuration compute_output = 4;
  bool has_compute_output() const;
  private:
  bool _internal_has_compute_output() const;
  public:
  void clear_compute_output();
  const ::inference::StatisticDuration& compute_output() const;
  PROTOBUF_NODISCARD ::inference::StatisticDuration* release_compute_output();
  ::inference::StatisticDuration* mutable_compute_output();
  void set_allocated_compute_output(::inference::StatisticDuration* compute_output);
  private:
  const ::inference::StatisticDuration& _internal_compute_output() const;
  ::inference::StatisticDuration* _internal_mutable_compute_output();
  public:
  void unsafe_arena_set_allocated_compute_output(
      ::inference::StatisticDuration* compute_output);
  ::inference::StatisticDuration* unsafe_arena_release_compute_output();

  // uint64 batch_size = 1;
  void clear_batch_size();
  uint64_t batch_size() const;
  void set_batch_size(uint64_t value);
  private:
  uint64_t _internal_batch_size() const;
  void _internal_set_batch_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.InferBatchStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::inference::StatisticDuration* compute_input_;
    ::inference::StatisticDuration* compute_infer_;
    ::inference::StatisticDuration* compute_output_;
    uint64_t batch_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class MemoryUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.MemoryUsage) */ {
 public:
  inline MemoryUsage() : MemoryUsage(nullptr) {}
  ~MemoryUsage() override;
  explicit PROTOBUF_CONSTEXPR MemoryUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoryUsage(const MemoryUsage& from);
  MemoryUsage(MemoryUsage&& from) noexcept
    : MemoryUsage() {
    *this = ::std::move(from);
  }

  inline MemoryUsage& operator=(const MemoryUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryUsage& operator=(MemoryUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoryUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryUsage* internal_default_instance() {
    return reinterpret_cast<const MemoryUsage*>(
               &_MemoryUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MemoryUsage& a, MemoryUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoryUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemoryUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemoryUsage& from) {
    MemoryUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoryUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.MemoryUsage";
  }
  protected:
  explicit MemoryUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kByteSizeFieldNumber = 3,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // int64 id = 2;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // uint64 byte_size = 3;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.MemoryUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int64_t id_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStatistics) */ {
 public:
  inline ModelStatistics() : ModelStatistics(nullptr) {}
  ~ModelStatistics() override;
  explicit PROTOBUF_CONSTEXPR ModelStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatistics(const ModelStatistics& from);
  ModelStatistics(ModelStatistics&& from) noexcept
    : ModelStatistics() {
    *this = ::std::move(from);
  }

  inline ModelStatistics& operator=(const ModelStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatistics& operator=(ModelStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatistics* internal_default_instance() {
    return reinterpret_cast<const ModelStatistics*>(
               &_ModelStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ModelStatistics& a, ModelStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStatistics& from) {
    ModelStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStatistics";
  }
  protected:
  explicit ModelStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchStatsFieldNumber = 7,
    kMemoryUsageFieldNumber = 8,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kInferenceStatsFieldNumber = 6,
    kLastInferenceFieldNumber = 3,
    kInferenceCountFieldNumber = 4,
    kExecutionCountFieldNumber = 5,
  };
  // repeated .inference.InferBatchStatistics batch_stats = 7;
  int batch_stats_size() const;
  private:
  int _internal_batch_stats_size() const;
  public:
  void clear_batch_stats();
  ::inference::InferBatchStatistics* mutable_batch_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferBatchStatistics >*
      mutable_batch_stats();
  private:
  const ::inference::InferBatchStatistics& _internal_batch_stats(int index) const;
  ::inference::InferBatchStatistics* _internal_add_batch_stats();
  public:
  const ::inference::InferBatchStatistics& batch_stats(int index) const;
  ::inference::InferBatchStatistics* add_batch_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferBatchStatistics >&
      batch_stats() const;

  // repeated .inference.MemoryUsage memory_usage = 8;
  int memory_usage_size() const;
  private:
  int _internal_memory_usage_size() const;
  public:
  void clear_memory_usage();
  ::inference::MemoryUsage* mutable_memory_usage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::MemoryUsage >*
      mutable_memory_usage();
  private:
  const ::inference::MemoryUsage& _internal_memory_usage(int index) const;
  ::inference::MemoryUsage* _internal_add_memory_usage();
  public:
  const ::inference::MemoryUsage& memory_usage(int index) const;
  ::inference::MemoryUsage* add_memory_usage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::MemoryUsage >&
      memory_usage() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .inference.InferStatistics inference_stats = 6;
  bool has_inference_stats() const;
  private:
  bool _internal_has_inference_stats() const;
  public:
  void clear_inference_stats();
  const ::inference::InferStatistics& inference_stats() const;
  PROTOBUF_NODISCARD ::inference::InferStatistics* release_inference_stats();
  ::inference::InferStatistics* mutable_inference_stats();
  void set_allocated_inference_stats(::inference::InferStatistics* inference_stats);
  private:
  const ::inference::InferStatistics& _internal_inference_stats() const;
  ::inference::InferStatistics* _internal_mutable_inference_stats();
  public:
  void unsafe_arena_set_allocated_inference_stats(
      ::inference::InferStatistics* inference_stats);
  ::inference::InferStatistics* unsafe_arena_release_inference_stats();

  // uint64 last_inference = 3;
  void clear_last_inference();
  uint64_t last_inference() const;
  void set_last_inference(uint64_t value);
  private:
  uint64_t _internal_last_inference() const;
  void _internal_set_last_inference(uint64_t value);
  public:

  // uint64 inference_count = 4;
  void clear_inference_count();
  uint64_t inference_count() const;
  void set_inference_count(uint64_t value);
  private:
  uint64_t _internal_inference_count() const;
  void _internal_set_inference_count(uint64_t value);
  public:

  // uint64 execution_count = 5;
  void clear_execution_count();
  uint64_t execution_count() const;
  void set_execution_count(uint64_t value);
  private:
  uint64_t _internal_execution_count() const;
  void _internal_set_execution_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferBatchStatistics > batch_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::MemoryUsage > memory_usage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::inference::InferStatistics* inference_stats_;
    uint64_t last_inference_;
    uint64_t inference_count_;
    uint64_t execution_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStatisticsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStatisticsResponse) */ {
 public:
  inline ModelStatisticsResponse() : ModelStatisticsResponse(nullptr) {}
  ~ModelStatisticsResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelStatisticsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatisticsResponse(const ModelStatisticsResponse& from);
  ModelStatisticsResponse(ModelStatisticsResponse&& from) noexcept
    : ModelStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline ModelStatisticsResponse& operator=(const ModelStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatisticsResponse& operator=(ModelStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const ModelStatisticsResponse*>(
               &_ModelStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ModelStatisticsResponse& a, ModelStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatisticsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatisticsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatisticsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatisticsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStatisticsResponse& from) {
    ModelStatisticsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatisticsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStatisticsResponse";
  }
  protected:
  explicit ModelStatisticsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelStatsFieldNumber = 1,
  };
  // repeated .inference.ModelStatistics model_stats = 1;
  int model_stats_size() const;
  private:
  int _internal_model_stats_size() const;
  public:
  void clear_model_stats();
  ::inference::ModelStatistics* mutable_model_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >*
      mutable_model_stats();
  private:
  const ::inference::ModelStatistics& _internal_model_stats(int index) const;
  ::inference::ModelStatistics* _internal_add_model_stats();
  public:
  const ::inference::ModelStatistics& model_stats(int index) const;
  ::inference::ModelStatistics* add_model_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >&
      model_stats() const;

  // @@protoc_insertion_point(class_scope:inference.ModelStatisticsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics > model_stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelRepositoryParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRepositoryParameter) */ {
 public:
  inline ModelRepositoryParameter() : ModelRepositoryParameter(nullptr) {}
  ~ModelRepositoryParameter() override;
  explicit PROTOBUF_CONSTEXPR ModelRepositoryParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRepositoryParameter(const ModelRepositoryParameter& from);
  ModelRepositoryParameter(ModelRepositoryParameter&& from) noexcept
    : ModelRepositoryParameter() {
    *this = ::std::move(from);
  }

  inline ModelRepositoryParameter& operator=(const ModelRepositoryParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRepositoryParameter& operator=(ModelRepositoryParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRepositoryParameter& default_instance() {
    return *internal_default_instance();
  }
  enum ParameterChoiceCase {
    kBoolParam = 1,
    kInt64Param = 2,
    kStringParam = 3,
    kBytesParam = 4,
    PARAMETER_CHOICE_NOT_SET = 0,
  };

  static inline const ModelRepositoryParameter* internal_default_instance() {
    return reinterpret_cast<const ModelRepositoryParameter*>(
               &_ModelRepositoryParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ModelRepositoryParameter& a, ModelRepositoryParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRepositoryParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRepositoryParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelRepositoryParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelRepositoryParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelRepositoryParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelRepositoryParameter& from) {
    ModelRepositoryParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRepositoryParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRepositoryParameter";
  }
  protected:
  explicit ModelRepositoryParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolParamFieldNumber = 1,
    kInt64ParamFieldNumber = 2,
    kStringParamFieldNumber = 3,
    kBytesParamFieldNumber = 4,
  };
  // bool bool_param = 1;
  bool has_bool_param() const;
  private:
  bool _internal_has_bool_param() const;
  public:
  void clear_bool_param();
  bool bool_param() const;
  void set_bool_param(bool value);
  private:
  bool _internal_bool_param() const;
  void _internal_set_bool_param(bool value);
  public:

  // int64 int64_param = 2;
  bool has_int64_param() const;
  private:
  bool _internal_has_int64_param() const;
  public:
  void clear_int64_param();
  int64_t int64_param() const;
  void set_int64_param(int64_t value);
  private:
  int64_t _internal_int64_param() const;
  void _internal_set_int64_param(int64_t value);
  public:

  // string string_param = 3;
  bool has_string_param() const;
  private:
  bool _internal_has_string_param() const;
  public:
  void clear_string_param();
  const std::string& string_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_param();
  PROTOBUF_NODISCARD std::string* release_string_param();
  void set_allocated_string_param(std::string* string_param);
  private:
  const std::string& _internal_string_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_param(const std::string& value);
  std::string* _internal_mutable_string_param();
  public:

  // bytes bytes_param = 4;
  bool has_bytes_param() const;
  private:
  bool _internal_has_bytes_param() const;
  public:
  void clear_bytes_param();
  const std::string& bytes_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytes_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytes_param();
  PROTOBUF_NODISCARD std::string* release_bytes_param();
  void set_allocated_bytes_param(std::string* bytes_param);
  private:
  const std::string& _internal_bytes_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_param(const std::string& value);
  std::string* _internal_mutable_bytes_param();
  public:

  void clear_parameter_choice();
  ParameterChoiceCase parameter_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelRepositoryParameter)
 private:
  class _Internal;
  void set_has_bool_param();
  void set_has_int64_param();
  void set_has_string_param();
  void set_has_bytes_param();

  inline bool has_parameter_choice() const;
  inline void clear_has_parameter_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ParameterChoiceUnion {
      constexpr ParameterChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool bool_param_;
      int64_t int64_param_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_param_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_param_;
    } parameter_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.RepositoryIndexRequest) */ {
 public:
  inline RepositoryIndexRequest() : RepositoryIndexRequest(nullptr) {}
  ~RepositoryIndexRequest() override;
  explicit PROTOBUF_CONSTEXPR RepositoryIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryIndexRequest(const RepositoryIndexRequest& from);
  RepositoryIndexRequest(RepositoryIndexRequest&& from) noexcept
    : RepositoryIndexRequest() {
    *this = ::std::move(from);
  }

  inline RepositoryIndexRequest& operator=(const RepositoryIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryIndexRequest& operator=(RepositoryIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryIndexRequest* internal_default_instance() {
    return reinterpret_cast<const RepositoryIndexRequest*>(
               &_RepositoryIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RepositoryIndexRequest& a, RepositoryIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepositoryIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepositoryIndexRequest& from) {
    RepositoryIndexRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositoryIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryIndexRequest";
  }
  protected:
  explicit RepositoryIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoryNameFieldNumber = 1,
    kReadyFieldNumber = 2,
  };
  // string repository_name = 1;
  void clear_repository_name();
  const std::string& repository_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repository_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repository_name();
  PROTOBUF_NODISCARD std::string* release_repository_name();
  void set_allocated_repository_name(std::string* repository_name);
  private:
  const std::string& _internal_repository_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repository_name(const std::string& value);
  std::string* _internal_mutable_repository_name();
  public:

  // bool ready = 2;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.RepositoryIndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repository_name_;
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryIndexResponse_ModelIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.RepositoryIndexResponse.ModelIndex) */ {
 public:
  inline RepositoryIndexResponse_ModelIndex() : RepositoryIndexResponse_ModelIndex(nullptr) {}
  ~RepositoryIndexResponse_ModelIndex() override;
  explicit PROTOBUF_CONSTEXPR RepositoryIndexResponse_ModelIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryIndexResponse_ModelIndex(const RepositoryIndexResponse_ModelIndex& from);
  RepositoryIndexResponse_ModelIndex(RepositoryIndexResponse_ModelIndex&& from) noexcept
    : RepositoryIndexResponse_ModelIndex() {
    *this = ::std::move(from);
  }

  inline RepositoryIndexResponse_ModelIndex& operator=(const RepositoryIndexResponse_ModelIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryIndexResponse_ModelIndex& operator=(RepositoryIndexResponse_ModelIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryIndexResponse_ModelIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryIndexResponse_ModelIndex* internal_default_instance() {
    return reinterpret_cast<const RepositoryIndexResponse_ModelIndex*>(
               &_RepositoryIndexResponse_ModelIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RepositoryIndexResponse_ModelIndex& a, RepositoryIndexResponse_ModelIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryIndexResponse_ModelIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryIndexResponse_ModelIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryIndexResponse_ModelIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryIndexResponse_ModelIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepositoryIndexResponse_ModelIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepositoryIndexResponse_ModelIndex& from) {
    RepositoryIndexResponse_ModelIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositoryIndexResponse_ModelIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryIndexResponse.ModelIndex";
  }
  protected:
  explicit RepositoryIndexResponse_ModelIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kStateFieldNumber = 3,
    kReasonFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string state = 3;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string reason = 4;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:inference.RepositoryIndexResponse.ModelIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryIndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.RepositoryIndexResponse) */ {
 public:
  inline RepositoryIndexResponse() : RepositoryIndexResponse(nullptr) {}
  ~RepositoryIndexResponse() override;
  explicit PROTOBUF_CONSTEXPR RepositoryIndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryIndexResponse(const RepositoryIndexResponse& from);
  RepositoryIndexResponse(RepositoryIndexResponse&& from) noexcept
    : RepositoryIndexResponse() {
    *this = ::std::move(from);
  }

  inline RepositoryIndexResponse& operator=(const RepositoryIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryIndexResponse& operator=(RepositoryIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryIndexResponse* internal_default_instance() {
    return reinterpret_cast<const RepositoryIndexResponse*>(
               &_RepositoryIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RepositoryIndexResponse& a, RepositoryIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryIndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryIndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryIndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepositoryIndexResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepositoryIndexResponse& from) {
    RepositoryIndexResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositoryIndexResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryIndexResponse";
  }
  protected:
  explicit RepositoryIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RepositoryIndexResponse_ModelIndex ModelIndex;

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
  };
  // repeated .inference.RepositoryIndexResponse.ModelIndex models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::inference::RepositoryIndexResponse_ModelIndex* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::RepositoryIndexResponse_ModelIndex >*
      mutable_models();
  private:
  const ::inference::RepositoryIndexResponse_ModelIndex& _internal_models(int index) const;
  ::inference::RepositoryIndexResponse_ModelIndex* _internal_add_models();
  public:
  const ::inference::RepositoryIndexResponse_ModelIndex& models(int index) const;
  ::inference::RepositoryIndexResponse_ModelIndex* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::RepositoryIndexResponse_ModelIndex >&
      models() const;

  // @@protoc_insertion_point(class_scope:inference.RepositoryIndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::RepositoryIndexResponse_ModelIndex > models_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryModelLoadRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RepositoryModelLoadRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelRepositoryParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RepositoryModelLoadRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelRepositoryParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  RepositoryModelLoadRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RepositoryModelLoadRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RepositoryModelLoadRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RepositoryModelLoadRequest_ParametersEntry_DoNotUse& other);
  static const RepositoryModelLoadRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RepositoryModelLoadRequest_ParametersEntry_DoNotUse*>(&_RepositoryModelLoadRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.RepositoryModelLoadRequest.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class RepositoryModelLoadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.RepositoryModelLoadRequest) */ {
 public:
  inline RepositoryModelLoadRequest() : RepositoryModelLoadRequest(nullptr) {}
  ~RepositoryModelLoadRequest() override;
  explicit PROTOBUF_CONSTEXPR RepositoryModelLoadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryModelLoadRequest(const RepositoryModelLoadRequest& from);
  RepositoryModelLoadRequest(RepositoryModelLoadRequest&& from) noexcept
    : RepositoryModelLoadRequest() {
    *this = ::std::move(from);
  }

  inline RepositoryModelLoadRequest& operator=(const RepositoryModelLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryModelLoadRequest& operator=(RepositoryModelLoadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryModelLoadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryModelLoadRequest* internal_default_instance() {
    return reinterpret_cast<const RepositoryModelLoadRequest*>(
               &_RepositoryModelLoadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(RepositoryModelLoadRequest& a, RepositoryModelLoadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryModelLoadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryModelLoadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryModelLoadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryModelLoadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepositoryModelLoadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepositoryModelLoadRequest& from) {
    RepositoryModelLoadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositoryModelLoadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryModelLoadRequest";
  }
  protected:
  explicit RepositoryModelLoadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kRepositoryNameFieldNumber = 1,
    kModelNameFieldNumber = 2,
  };
  // map<string, .inference.ModelRepositoryParameter> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
      mutable_parameters();

  // string repository_name = 1;
  void clear_repository_name();
  const std::string& repository_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repository_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repository_name();
  PROTOBUF_NODISCARD std::string* release_repository_name();
  void set_allocated_repository_name(std::string* repository_name);
  private:
  const std::string& _internal_repository_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repository_name(const std::string& value);
  std::string* _internal_mutable_repository_name();
  public:

  // string model_name = 2;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.RepositoryModelLoadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RepositoryModelLoadRequest_ParametersEntry_DoNotUse,
        std::string, ::inference::ModelRepositoryParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repository_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryModelLoadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.RepositoryModelLoadResponse) */ {
 public:
  inline RepositoryModelLoadResponse() : RepositoryModelLoadResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RepositoryModelLoadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryModelLoadResponse(const RepositoryModelLoadResponse& from);
  RepositoryModelLoadResponse(RepositoryModelLoadResponse&& from) noexcept
    : RepositoryModelLoadResponse() {
    *this = ::std::move(from);
  }

  inline RepositoryModelLoadResponse& operator=(const RepositoryModelLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryModelLoadResponse& operator=(RepositoryModelLoadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryModelLoadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryModelLoadResponse* internal_default_instance() {
    return reinterpret_cast<const RepositoryModelLoadResponse*>(
               &_RepositoryModelLoadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RepositoryModelLoadResponse& a, RepositoryModelLoadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryModelLoadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryModelLoadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryModelLoadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryModelLoadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RepositoryModelLoadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RepositoryModelLoadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryModelLoadResponse";
  }
  protected:
  explicit RepositoryModelLoadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.RepositoryModelLoadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryModelUnloadRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RepositoryModelUnloadRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelRepositoryParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RepositoryModelUnloadRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelRepositoryParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  RepositoryModelUnloadRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RepositoryModelUnloadRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RepositoryModelUnloadRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RepositoryModelUnloadRequest_ParametersEntry_DoNotUse& other);
  static const RepositoryModelUnloadRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RepositoryModelUnloadRequest_ParametersEntry_DoNotUse*>(&_RepositoryModelUnloadRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.RepositoryModelUnloadRequest.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class RepositoryModelUnloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.RepositoryModelUnloadRequest) */ {
 public:
  inline RepositoryModelUnloadRequest() : RepositoryModelUnloadRequest(nullptr) {}
  ~RepositoryModelUnloadRequest() override;
  explicit PROTOBUF_CONSTEXPR RepositoryModelUnloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryModelUnloadRequest(const RepositoryModelUnloadRequest& from);
  RepositoryModelUnloadRequest(RepositoryModelUnloadRequest&& from) noexcept
    : RepositoryModelUnloadRequest() {
    *this = ::std::move(from);
  }

  inline RepositoryModelUnloadRequest& operator=(const RepositoryModelUnloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryModelUnloadRequest& operator=(RepositoryModelUnloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryModelUnloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryModelUnloadRequest* internal_default_instance() {
    return reinterpret_cast<const RepositoryModelUnloadRequest*>(
               &_RepositoryModelUnloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(RepositoryModelUnloadRequest& a, RepositoryModelUnloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryModelUnloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryModelUnloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryModelUnloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryModelUnloadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepositoryModelUnloadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepositoryModelUnloadRequest& from) {
    RepositoryModelUnloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositoryModelUnloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryModelUnloadRequest";
  }
  protected:
  explicit RepositoryModelUnloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kRepositoryNameFieldNumber = 1,
    kModelNameFieldNumber = 2,
  };
  // map<string, .inference.ModelRepositoryParameter> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
      mutable_parameters();

  // string repository_name = 1;
  void clear_repository_name();
  const std::string& repository_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repository_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repository_name();
  PROTOBUF_NODISCARD std::string* release_repository_name();
  void set_allocated_repository_name(std::string* repository_name);
  private:
  const std::string& _internal_repository_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repository_name(const std::string& value);
  std::string* _internal_mutable_repository_name();
  public:

  // string model_name = 2;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.RepositoryModelUnloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RepositoryModelUnloadRequest_ParametersEntry_DoNotUse,
        std::string, ::inference::ModelRepositoryParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repository_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RepositoryModelUnloadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.RepositoryModelUnloadResponse) */ {
 public:
  inline RepositoryModelUnloadResponse() : RepositoryModelUnloadResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RepositoryModelUnloadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositoryModelUnloadResponse(const RepositoryModelUnloadResponse& from);
  RepositoryModelUnloadResponse(RepositoryModelUnloadResponse&& from) noexcept
    : RepositoryModelUnloadResponse() {
    *this = ::std::move(from);
  }

  inline RepositoryModelUnloadResponse& operator=(const RepositoryModelUnloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositoryModelUnloadResponse& operator=(RepositoryModelUnloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositoryModelUnloadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositoryModelUnloadResponse* internal_default_instance() {
    return reinterpret_cast<const RepositoryModelUnloadResponse*>(
               &_RepositoryModelUnloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(RepositoryModelUnloadResponse& a, RepositoryModelUnloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositoryModelUnloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositoryModelUnloadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositoryModelUnloadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositoryModelUnloadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RepositoryModelUnloadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RepositoryModelUnloadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.RepositoryModelUnloadResponse";
  }
  protected:
  explicit RepositoryModelUnloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.RepositoryModelUnloadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryStatusRequest) */ {
 public:
  inline SystemSharedMemoryStatusRequest() : SystemSharedMemoryStatusRequest(nullptr) {}
  ~SystemSharedMemoryStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryStatusRequest(const SystemSharedMemoryStatusRequest& from);
  SystemSharedMemoryStatusRequest(SystemSharedMemoryStatusRequest&& from) noexcept
    : SystemSharedMemoryStatusRequest() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryStatusRequest& operator=(const SystemSharedMemoryStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryStatusRequest& operator=(SystemSharedMemoryStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryStatusRequest*>(
               &_SystemSharedMemoryStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SystemSharedMemoryStatusRequest& a, SystemSharedMemoryStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryStatusRequest& from) {
    SystemSharedMemoryStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryStatusRequest";
  }
  protected:
  explicit SystemSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryStatusResponse_RegionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryStatusResponse.RegionStatus) */ {
 public:
  inline SystemSharedMemoryStatusResponse_RegionStatus() : SystemSharedMemoryStatusResponse_RegionStatus(nullptr) {}
  ~SystemSharedMemoryStatusResponse_RegionStatus() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryStatusResponse_RegionStatus(const SystemSharedMemoryStatusResponse_RegionStatus& from);
  SystemSharedMemoryStatusResponse_RegionStatus(SystemSharedMemoryStatusResponse_RegionStatus&& from) noexcept
    : SystemSharedMemoryStatusResponse_RegionStatus() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryStatusResponse_RegionStatus& operator=(const SystemSharedMemoryStatusResponse_RegionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryStatusResponse_RegionStatus& operator=(SystemSharedMemoryStatusResponse_RegionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryStatusResponse_RegionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryStatusResponse_RegionStatus* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryStatusResponse_RegionStatus*>(
               &_SystemSharedMemoryStatusResponse_RegionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SystemSharedMemoryStatusResponse_RegionStatus& a, SystemSharedMemoryStatusResponse_RegionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryStatusResponse_RegionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryStatusResponse_RegionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryStatusResponse_RegionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryStatusResponse_RegionStatus& from) {
    SystemSharedMemoryStatusResponse_RegionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryStatusResponse_RegionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryStatusResponse.RegionStatus";
  }
  protected:
  explicit SystemSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kByteSizeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 offset = 3;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 byte_size = 4;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryStatusResponse.RegionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t offset_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse& other);
  static const SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse*>(&_SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.SystemSharedMemoryStatusResponse.RegionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class SystemSharedMemoryStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryStatusResponse) */ {
 public:
  inline SystemSharedMemoryStatusResponse() : SystemSharedMemoryStatusResponse(nullptr) {}
  ~SystemSharedMemoryStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryStatusResponse(const SystemSharedMemoryStatusResponse& from);
  SystemSharedMemoryStatusResponse(SystemSharedMemoryStatusResponse&& from) noexcept
    : SystemSharedMemoryStatusResponse() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryStatusResponse& operator=(const SystemSharedMemoryStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryStatusResponse& operator=(SystemSharedMemoryStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryStatusResponse*>(
               &_SystemSharedMemoryStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(SystemSharedMemoryStatusResponse& a, SystemSharedMemoryStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryStatusResponse& from) {
    SystemSharedMemoryStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryStatusResponse";
  }
  protected:
  explicit SystemSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SystemSharedMemoryStatusResponse_RegionStatus RegionStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
  };
  // map<string, .inference.SystemSharedMemoryStatusResponse.RegionStatus> regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
      _internal_regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
      _internal_mutable_regions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
      regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
      mutable_regions();

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse,
        std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> regions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryRegisterRequest) */ {
 public:
  inline SystemSharedMemoryRegisterRequest() : SystemSharedMemoryRegisterRequest(nullptr) {}
  ~SystemSharedMemoryRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryRegisterRequest(const SystemSharedMemoryRegisterRequest& from);
  SystemSharedMemoryRegisterRequest(SystemSharedMemoryRegisterRequest&& from) noexcept
    : SystemSharedMemoryRegisterRequest() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryRegisterRequest& operator=(const SystemSharedMemoryRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryRegisterRequest& operator=(SystemSharedMemoryRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryRegisterRequest*>(
               &_SystemSharedMemoryRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(SystemSharedMemoryRegisterRequest& a, SystemSharedMemoryRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryRegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryRegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryRegisterRequest& from) {
    SystemSharedMemoryRegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryRegisterRequest";
  }
  protected:
  explicit SystemSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kByteSizeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 offset = 3;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 byte_size = 4;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t offset_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryRegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryRegisterResponse) */ {
 public:
  inline SystemSharedMemoryRegisterResponse() : SystemSharedMemoryRegisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryRegisterResponse(const SystemSharedMemoryRegisterResponse& from);
  SystemSharedMemoryRegisterResponse(SystemSharedMemoryRegisterResponse&& from) noexcept
    : SystemSharedMemoryRegisterResponse() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryRegisterResponse& operator=(const SystemSharedMemoryRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryRegisterResponse& operator=(SystemSharedMemoryRegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryRegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryRegisterResponse* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryRegisterResponse*>(
               &_SystemSharedMemoryRegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(SystemSharedMemoryRegisterResponse& a, SystemSharedMemoryRegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryRegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryRegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryRegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryRegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SystemSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SystemSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryRegisterResponse";
  }
  protected:
  explicit SystemSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryRegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryUnregisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryUnregisterRequest) */ {
 public:
  inline SystemSharedMemoryUnregisterRequest() : SystemSharedMemoryUnregisterRequest(nullptr) {}
  ~SystemSharedMemoryUnregisterRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryUnregisterRequest(const SystemSharedMemoryUnregisterRequest& from);
  SystemSharedMemoryUnregisterRequest(SystemSharedMemoryUnregisterRequest&& from) noexcept
    : SystemSharedMemoryUnregisterRequest() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryUnregisterRequest& operator=(const SystemSharedMemoryUnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryUnregisterRequest& operator=(SystemSharedMemoryUnregisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryUnregisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryUnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryUnregisterRequest*>(
               &_SystemSharedMemoryUnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(SystemSharedMemoryUnregisterRequest& a, SystemSharedMemoryUnregisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryUnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryUnregisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryUnregisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryUnregisterRequest& from) {
    SystemSharedMemoryUnregisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryUnregisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryUnregisterRequest";
  }
  protected:
  explicit SystemSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryUnregisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryUnregisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryUnregisterResponse) */ {
 public:
  inline SystemSharedMemoryUnregisterResponse() : SystemSharedMemoryUnregisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryUnregisterResponse(const SystemSharedMemoryUnregisterResponse& from);
  SystemSharedMemoryUnregisterResponse(SystemSharedMemoryUnregisterResponse&& from) noexcept
    : SystemSharedMemoryUnregisterResponse() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryUnregisterResponse& operator=(const SystemSharedMemoryUnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryUnregisterResponse& operator=(SystemSharedMemoryUnregisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryUnregisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryUnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryUnregisterResponse*>(
               &_SystemSharedMemoryUnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(SystemSharedMemoryUnregisterResponse& a, SystemSharedMemoryUnregisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryUnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryUnregisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SystemSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SystemSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryUnregisterResponse";
  }
  protected:
  explicit SystemSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryUnregisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryStatusRequest) */ {
 public:
  inline CudaSharedMemoryStatusRequest() : CudaSharedMemoryStatusRequest(nullptr) {}
  ~CudaSharedMemoryStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryStatusRequest(const CudaSharedMemoryStatusRequest& from);
  CudaSharedMemoryStatusRequest(CudaSharedMemoryStatusRequest&& from) noexcept
    : CudaSharedMemoryStatusRequest() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryStatusRequest& operator=(const CudaSharedMemoryStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryStatusRequest& operator=(CudaSharedMemoryStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryStatusRequest* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryStatusRequest*>(
               &_CudaSharedMemoryStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CudaSharedMemoryStatusRequest& a, CudaSharedMemoryStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryStatusRequest& from) {
    CudaSharedMemoryStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryStatusRequest";
  }
  protected:
  explicit CudaSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryStatusResponse_RegionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryStatusResponse.RegionStatus) */ {
 public:
  inline CudaSharedMemoryStatusResponse_RegionStatus() : CudaSharedMemoryStatusResponse_RegionStatus(nullptr) {}
  ~CudaSharedMemoryStatusResponse_RegionStatus() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryStatusResponse_RegionStatus(const CudaSharedMemoryStatusResponse_RegionStatus& from);
  CudaSharedMemoryStatusResponse_RegionStatus(CudaSharedMemoryStatusResponse_RegionStatus&& from) noexcept
    : CudaSharedMemoryStatusResponse_RegionStatus() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryStatusResponse_RegionStatus& operator=(const CudaSharedMemoryStatusResponse_RegionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryStatusResponse_RegionStatus& operator=(CudaSharedMemoryStatusResponse_RegionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryStatusResponse_RegionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryStatusResponse_RegionStatus* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryStatusResponse_RegionStatus*>(
               &_CudaSharedMemoryStatusResponse_RegionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CudaSharedMemoryStatusResponse_RegionStatus& a, CudaSharedMemoryStatusResponse_RegionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryStatusResponse_RegionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryStatusResponse_RegionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryStatusResponse_RegionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryStatusResponse_RegionStatus& from) {
    CudaSharedMemoryStatusResponse_RegionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryStatusResponse_RegionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryStatusResponse.RegionStatus";
  }
  protected:
  explicit CudaSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kByteSizeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 device_id = 2;
  void clear_device_id();
  uint64_t device_id() const;
  void set_device_id(uint64_t value);
  private:
  uint64_t _internal_device_id() const;
  void _internal_set_device_id(uint64_t value);
  public:

  // uint64 byte_size = 3;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryStatusResponse.RegionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t device_id_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse& other);
  static const CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse*>(&_CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.CudaSharedMemoryStatusResponse.RegionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class CudaSharedMemoryStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryStatusResponse) */ {
 public:
  inline CudaSharedMemoryStatusResponse() : CudaSharedMemoryStatusResponse(nullptr) {}
  ~CudaSharedMemoryStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryStatusResponse(const CudaSharedMemoryStatusResponse& from);
  CudaSharedMemoryStatusResponse(CudaSharedMemoryStatusResponse&& from) noexcept
    : CudaSharedMemoryStatusResponse() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryStatusResponse& operator=(const CudaSharedMemoryStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryStatusResponse& operator=(CudaSharedMemoryStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryStatusResponse* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryStatusResponse*>(
               &_CudaSharedMemoryStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CudaSharedMemoryStatusResponse& a, CudaSharedMemoryStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryStatusResponse& from) {
    CudaSharedMemoryStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryStatusResponse";
  }
  protected:
  explicit CudaSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CudaSharedMemoryStatusResponse_RegionStatus RegionStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
  };
  // map<string, .inference.CudaSharedMemoryStatusResponse.RegionStatus> regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
      _internal_regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
      _internal_mutable_regions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
      regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
      mutable_regions();

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse,
        std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> regions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryRegisterRequest) */ {
 public:
  inline CudaSharedMemoryRegisterRequest() : CudaSharedMemoryRegisterRequest(nullptr) {}
  ~CudaSharedMemoryRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryRegisterRequest(const CudaSharedMemoryRegisterRequest& from);
  CudaSharedMemoryRegisterRequest(CudaSharedMemoryRegisterRequest&& from) noexcept
    : CudaSharedMemoryRegisterRequest() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryRegisterRequest& operator=(const CudaSharedMemoryRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryRegisterRequest& operator=(CudaSharedMemoryRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryRegisterRequest*>(
               &_CudaSharedMemoryRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CudaSharedMemoryRegisterRequest& a, CudaSharedMemoryRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryRegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryRegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryRegisterRequest& from) {
    CudaSharedMemoryRegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryRegisterRequest";
  }
  protected:
  explicit CudaSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRawHandleFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kByteSizeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes raw_handle = 2;
  void clear_raw_handle();
  const std::string& raw_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_handle();
  PROTOBUF_NODISCARD std::string* release_raw_handle();
  void set_allocated_raw_handle(std::string* raw_handle);
  private:
  const std::string& _internal_raw_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_handle(const std::string& value);
  std::string* _internal_mutable_raw_handle();
  public:

  // int64 device_id = 3;
  void clear_device_id();
  int64_t device_id() const;
  void set_device_id(int64_t value);
  private:
  int64_t _internal_device_id() const;
  void _internal_set_device_id(int64_t value);
  public:

  // uint64 byte_size = 4;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_handle_;
    int64_t device_id_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryRegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryRegisterResponse) */ {
 public:
  inline CudaSharedMemoryRegisterResponse() : CudaSharedMemoryRegisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryRegisterResponse(const CudaSharedMemoryRegisterResponse& from);
  CudaSharedMemoryRegisterResponse(CudaSharedMemoryRegisterResponse&& from) noexcept
    : CudaSharedMemoryRegisterResponse() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryRegisterResponse& operator=(const CudaSharedMemoryRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryRegisterResponse& operator=(CudaSharedMemoryRegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryRegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryRegisterResponse* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryRegisterResponse*>(
               &_CudaSharedMemoryRegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CudaSharedMemoryRegisterResponse& a, CudaSharedMemoryRegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryRegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryRegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryRegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryRegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CudaSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CudaSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryRegisterResponse";
  }
  protected:
  explicit CudaSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryRegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryUnregisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryUnregisterRequest) */ {
 public:
  inline CudaSharedMemoryUnregisterRequest() : CudaSharedMemoryUnregisterRequest(nullptr) {}
  ~CudaSharedMemoryUnregisterRequest() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryUnregisterRequest(const CudaSharedMemoryUnregisterRequest& from);
  CudaSharedMemoryUnregisterRequest(CudaSharedMemoryUnregisterRequest&& from) noexcept
    : CudaSharedMemoryUnregisterRequest() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryUnregisterRequest& operator=(const CudaSharedMemoryUnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryUnregisterRequest& operator=(CudaSharedMemoryUnregisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryUnregisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryUnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryUnregisterRequest*>(
               &_CudaSharedMemoryUnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CudaSharedMemoryUnregisterRequest& a, CudaSharedMemoryUnregisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryUnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryUnregisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryUnregisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryUnregisterRequest& from) {
    CudaSharedMemoryUnregisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryUnregisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryUnregisterRequest";
  }
  protected:
  explicit CudaSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryUnregisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryUnregisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryUnregisterResponse) */ {
 public:
  inline CudaSharedMemoryUnregisterResponse() : CudaSharedMemoryUnregisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryUnregisterResponse(const CudaSharedMemoryUnregisterResponse& from);
  CudaSharedMemoryUnregisterResponse(CudaSharedMemoryUnregisterResponse&& from) noexcept
    : CudaSharedMemoryUnregisterResponse() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryUnregisterResponse& operator=(const CudaSharedMemoryUnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryUnregisterResponse& operator=(CudaSharedMemoryUnregisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryUnregisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryUnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryUnregisterResponse*>(
               &_CudaSharedMemoryUnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CudaSharedMemoryUnregisterResponse& a, CudaSharedMemoryUnregisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryUnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryUnregisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CudaSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CudaSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryUnregisterResponse";
  }
  protected:
  explicit CudaSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryUnregisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TraceSettingRequest_SettingValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.TraceSettingRequest.SettingValue) */ {
 public:
  inline TraceSettingRequest_SettingValue() : TraceSettingRequest_SettingValue(nullptr) {}
  ~TraceSettingRequest_SettingValue() override;
  explicit PROTOBUF_CONSTEXPR TraceSettingRequest_SettingValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceSettingRequest_SettingValue(const TraceSettingRequest_SettingValue& from);
  TraceSettingRequest_SettingValue(TraceSettingRequest_SettingValue&& from) noexcept
    : TraceSettingRequest_SettingValue() {
    *this = ::std::move(from);
  }

  inline TraceSettingRequest_SettingValue& operator=(const TraceSettingRequest_SettingValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceSettingRequest_SettingValue& operator=(TraceSettingRequest_SettingValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceSettingRequest_SettingValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceSettingRequest_SettingValue* internal_default_instance() {
    return reinterpret_cast<const TraceSettingRequest_SettingValue*>(
               &_TraceSettingRequest_SettingValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(TraceSettingRequest_SettingValue& a, TraceSettingRequest_SettingValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceSettingRequest_SettingValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceSettingRequest_SettingValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceSettingRequest_SettingValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceSettingRequest_SettingValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceSettingRequest_SettingValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceSettingRequest_SettingValue& from) {
    TraceSettingRequest_SettingValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceSettingRequest_SettingValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.TraceSettingRequest.SettingValue";
  }
  protected:
  explicit TraceSettingRequest_SettingValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // @@protoc_insertion_point(class_scope:inference.TraceSettingRequest.SettingValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TraceSettingRequest_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TraceSettingRequest_SettingsEntry_DoNotUse, 
    std::string, ::inference::TraceSettingRequest_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TraceSettingRequest_SettingsEntry_DoNotUse, 
    std::string, ::inference::TraceSettingRequest_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TraceSettingRequest_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TraceSettingRequest_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TraceSettingRequest_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TraceSettingRequest_SettingsEntry_DoNotUse& other);
  static const TraceSettingRequest_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TraceSettingRequest_SettingsEntry_DoNotUse*>(&_TraceSettingRequest_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.TraceSettingRequest.SettingsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class TraceSettingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.TraceSettingRequest) */ {
 public:
  inline TraceSettingRequest() : TraceSettingRequest(nullptr) {}
  ~TraceSettingRequest() override;
  explicit PROTOBUF_CONSTEXPR TraceSettingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceSettingRequest(const TraceSettingRequest& from);
  TraceSettingRequest(TraceSettingRequest&& from) noexcept
    : TraceSettingRequest() {
    *this = ::std::move(from);
  }

  inline TraceSettingRequest& operator=(const TraceSettingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceSettingRequest& operator=(TraceSettingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceSettingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceSettingRequest* internal_default_instance() {
    return reinterpret_cast<const TraceSettingRequest*>(
               &_TraceSettingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(TraceSettingRequest& a, TraceSettingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceSettingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceSettingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceSettingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceSettingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceSettingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceSettingRequest& from) {
    TraceSettingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceSettingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.TraceSettingRequest";
  }
  protected:
  explicit TraceSettingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TraceSettingRequest_SettingValue SettingValue;

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
    kModelNameFieldNumber = 2,
  };
  // map<string, .inference.TraceSettingRequest.SettingValue> settings = 1;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >*
      mutable_settings();

  // string model_name = 2;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.TraceSettingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TraceSettingRequest_SettingsEntry_DoNotUse,
        std::string, ::inference::TraceSettingRequest_SettingValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TraceSettingResponse_SettingValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.TraceSettingResponse.SettingValue) */ {
 public:
  inline TraceSettingResponse_SettingValue() : TraceSettingResponse_SettingValue(nullptr) {}
  ~TraceSettingResponse_SettingValue() override;
  explicit PROTOBUF_CONSTEXPR TraceSettingResponse_SettingValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceSettingResponse_SettingValue(const TraceSettingResponse_SettingValue& from);
  TraceSettingResponse_SettingValue(TraceSettingResponse_SettingValue&& from) noexcept
    : TraceSettingResponse_SettingValue() {
    *this = ::std::move(from);
  }

  inline TraceSettingResponse_SettingValue& operator=(const TraceSettingResponse_SettingValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceSettingResponse_SettingValue& operator=(TraceSettingResponse_SettingValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceSettingResponse_SettingValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceSettingResponse_SettingValue* internal_default_instance() {
    return reinterpret_cast<const TraceSettingResponse_SettingValue*>(
               &_TraceSettingResponse_SettingValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(TraceSettingResponse_SettingValue& a, TraceSettingResponse_SettingValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceSettingResponse_SettingValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceSettingResponse_SettingValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceSettingResponse_SettingValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceSettingResponse_SettingValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceSettingResponse_SettingValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceSettingResponse_SettingValue& from) {
    TraceSettingResponse_SettingValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceSettingResponse_SettingValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.TraceSettingResponse.SettingValue";
  }
  protected:
  explicit TraceSettingResponse_SettingValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // @@protoc_insertion_point(class_scope:inference.TraceSettingResponse.SettingValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TraceSettingResponse_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TraceSettingResponse_SettingsEntry_DoNotUse, 
    std::string, ::inference::TraceSettingResponse_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TraceSettingResponse_SettingsEntry_DoNotUse, 
    std::string, ::inference::TraceSettingResponse_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TraceSettingResponse_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TraceSettingResponse_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TraceSettingResponse_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TraceSettingResponse_SettingsEntry_DoNotUse& other);
  static const TraceSettingResponse_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TraceSettingResponse_SettingsEntry_DoNotUse*>(&_TraceSettingResponse_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.TraceSettingResponse.SettingsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class TraceSettingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.TraceSettingResponse) */ {
 public:
  inline TraceSettingResponse() : TraceSettingResponse(nullptr) {}
  ~TraceSettingResponse() override;
  explicit PROTOBUF_CONSTEXPR TraceSettingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceSettingResponse(const TraceSettingResponse& from);
  TraceSettingResponse(TraceSettingResponse&& from) noexcept
    : TraceSettingResponse() {
    *this = ::std::move(from);
  }

  inline TraceSettingResponse& operator=(const TraceSettingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceSettingResponse& operator=(TraceSettingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceSettingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceSettingResponse* internal_default_instance() {
    return reinterpret_cast<const TraceSettingResponse*>(
               &_TraceSettingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(TraceSettingResponse& a, TraceSettingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceSettingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceSettingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceSettingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceSettingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceSettingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceSettingResponse& from) {
    TraceSettingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceSettingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.TraceSettingResponse";
  }
  protected:
  explicit TraceSettingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TraceSettingResponse_SettingValue SettingValue;

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // map<string, .inference.TraceSettingResponse.SettingValue> settings = 1;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >*
      mutable_settings();

  // @@protoc_insertion_point(class_scope:inference.TraceSettingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TraceSettingResponse_SettingsEntry_DoNotUse,
        std::string, ::inference::TraceSettingResponse_SettingValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LogSettingsRequest_SettingValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.LogSettingsRequest.SettingValue) */ {
 public:
  inline LogSettingsRequest_SettingValue() : LogSettingsRequest_SettingValue(nullptr) {}
  ~LogSettingsRequest_SettingValue() override;
  explicit PROTOBUF_CONSTEXPR LogSettingsRequest_SettingValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSettingsRequest_SettingValue(const LogSettingsRequest_SettingValue& from);
  LogSettingsRequest_SettingValue(LogSettingsRequest_SettingValue&& from) noexcept
    : LogSettingsRequest_SettingValue() {
    *this = ::std::move(from);
  }

  inline LogSettingsRequest_SettingValue& operator=(const LogSettingsRequest_SettingValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSettingsRequest_SettingValue& operator=(LogSettingsRequest_SettingValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSettingsRequest_SettingValue& default_instance() {
    return *internal_default_instance();
  }
  enum ParameterChoiceCase {
    kBoolParam = 1,
    kUint32Param = 2,
    kStringParam = 3,
    PARAMETER_CHOICE_NOT_SET = 0,
  };

  static inline const LogSettingsRequest_SettingValue* internal_default_instance() {
    return reinterpret_cast<const LogSettingsRequest_SettingValue*>(
               &_LogSettingsRequest_SettingValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(LogSettingsRequest_SettingValue& a, LogSettingsRequest_SettingValue& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSettingsRequest_SettingValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSettingsRequest_SettingValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSettingsRequest_SettingValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSettingsRequest_SettingValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSettingsRequest_SettingValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogSettingsRequest_SettingValue& from) {
    LogSettingsRequest_SettingValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSettingsRequest_SettingValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.LogSettingsRequest.SettingValue";
  }
  protected:
  explicit LogSettingsRequest_SettingValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolParamFieldNumber = 1,
    kUint32ParamFieldNumber = 2,
    kStringParamFieldNumber = 3,
  };
  // bool bool_param = 1;
  bool has_bool_param() const;
  private:
  bool _internal_has_bool_param() const;
  public:
  void clear_bool_param();
  bool bool_param() const;
  void set_bool_param(bool value);
  private:
  bool _internal_bool_param() const;
  void _internal_set_bool_param(bool value);
  public:

  // uint32 uint32_param = 2;
  bool has_uint32_param() const;
  private:
  bool _internal_has_uint32_param() const;
  public:
  void clear_uint32_param();
  uint32_t uint32_param() const;
  void set_uint32_param(uint32_t value);
  private:
  uint32_t _internal_uint32_param() const;
  void _internal_set_uint32_param(uint32_t value);
  public:

  // string string_param = 3;
  bool has_string_param() const;
  private:
  bool _internal_has_string_param() const;
  public:
  void clear_string_param();
  const std::string& string_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_param();
  PROTOBUF_NODISCARD std::string* release_string_param();
  void set_allocated_string_param(std::string* string_param);
  private:
  const std::string& _internal_string_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_param(const std::string& value);
  std::string* _internal_mutable_string_param();
  public:

  void clear_parameter_choice();
  ParameterChoiceCase parameter_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.LogSettingsRequest.SettingValue)
 private:
  class _Internal;
  void set_has_bool_param();
  void set_has_uint32_param();
  void set_has_string_param();

  inline bool has_parameter_choice() const;
  inline void clear_has_parameter_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ParameterChoiceUnion {
      constexpr ParameterChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool bool_param_;
      uint32_t uint32_param_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_param_;
    } parameter_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LogSettingsRequest_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogSettingsRequest_SettingsEntry_DoNotUse, 
    std::string, ::inference::LogSettingsRequest_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogSettingsRequest_SettingsEntry_DoNotUse, 
    std::string, ::inference::LogSettingsRequest_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LogSettingsRequest_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogSettingsRequest_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogSettingsRequest_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogSettingsRequest_SettingsEntry_DoNotUse& other);
  static const LogSettingsRequest_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogSettingsRequest_SettingsEntry_DoNotUse*>(&_LogSettingsRequest_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.LogSettingsRequest.SettingsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class LogSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.LogSettingsRequest) */ {
 public:
  inline LogSettingsRequest() : LogSettingsRequest(nullptr) {}
  ~LogSettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR LogSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSettingsRequest(const LogSettingsRequest& from);
  LogSettingsRequest(LogSettingsRequest&& from) noexcept
    : LogSettingsRequest() {
    *this = ::std::move(from);
  }

  inline LogSettingsRequest& operator=(const LogSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSettingsRequest& operator=(LogSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const LogSettingsRequest*>(
               &_LogSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(LogSettingsRequest& a, LogSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogSettingsRequest& from) {
    LogSettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.LogSettingsRequest";
  }
  protected:
  explicit LogSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogSettingsRequest_SettingValue SettingValue;

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // map<string, .inference.LogSettingsRequest.SettingValue> settings = 1;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >*
      mutable_settings();

  // @@protoc_insertion_point(class_scope:inference.LogSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogSettingsRequest_SettingsEntry_DoNotUse,
        std::string, ::inference::LogSettingsRequest_SettingValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LogSettingsResponse_SettingValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.LogSettingsResponse.SettingValue) */ {
 public:
  inline LogSettingsResponse_SettingValue() : LogSettingsResponse_SettingValue(nullptr) {}
  ~LogSettingsResponse_SettingValue() override;
  explicit PROTOBUF_CONSTEXPR LogSettingsResponse_SettingValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSettingsResponse_SettingValue(const LogSettingsResponse_SettingValue& from);
  LogSettingsResponse_SettingValue(LogSettingsResponse_SettingValue&& from) noexcept
    : LogSettingsResponse_SettingValue() {
    *this = ::std::move(from);
  }

  inline LogSettingsResponse_SettingValue& operator=(const LogSettingsResponse_SettingValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSettingsResponse_SettingValue& operator=(LogSettingsResponse_SettingValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSettingsResponse_SettingValue& default_instance() {
    return *internal_default_instance();
  }
  enum ParameterChoiceCase {
    kBoolParam = 1,
    kUint32Param = 2,
    kStringParam = 3,
    PARAMETER_CHOICE_NOT_SET = 0,
  };

  static inline const LogSettingsResponse_SettingValue* internal_default_instance() {
    return reinterpret_cast<const LogSettingsResponse_SettingValue*>(
               &_LogSettingsResponse_SettingValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(LogSettingsResponse_SettingValue& a, LogSettingsResponse_SettingValue& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSettingsResponse_SettingValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSettingsResponse_SettingValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSettingsResponse_SettingValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSettingsResponse_SettingValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSettingsResponse_SettingValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogSettingsResponse_SettingValue& from) {
    LogSettingsResponse_SettingValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSettingsResponse_SettingValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.LogSettingsResponse.SettingValue";
  }
  protected:
  explicit LogSettingsResponse_SettingValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolParamFieldNumber = 1,
    kUint32ParamFieldNumber = 2,
    kStringParamFieldNumber = 3,
  };
  // bool bool_param = 1;
  bool has_bool_param() const;
  private:
  bool _internal_has_bool_param() const;
  public:
  void clear_bool_param();
  bool bool_param() const;
  void set_bool_param(bool value);
  private:
  bool _internal_bool_param() const;
  void _internal_set_bool_param(bool value);
  public:

  // uint32 uint32_param = 2;
  bool has_uint32_param() const;
  private:
  bool _internal_has_uint32_param() const;
  public:
  void clear_uint32_param();
  uint32_t uint32_param() const;
  void set_uint32_param(uint32_t value);
  private:
  uint32_t _internal_uint32_param() const;
  void _internal_set_uint32_param(uint32_t value);
  public:

  // string string_param = 3;
  bool has_string_param() const;
  private:
  bool _internal_has_string_param() const;
  public:
  void clear_string_param();
  const std::string& string_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_param();
  PROTOBUF_NODISCARD std::string* release_string_param();
  void set_allocated_string_param(std::string* string_param);
  private:
  const std::string& _internal_string_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_param(const std::string& value);
  std::string* _internal_mutable_string_param();
  public:

  void clear_parameter_choice();
  ParameterChoiceCase parameter_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.LogSettingsResponse.SettingValue)
 private:
  class _Internal;
  void set_has_bool_param();
  void set_has_uint32_param();
  void set_has_string_param();

  inline bool has_parameter_choice() const;
  inline void clear_has_parameter_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ParameterChoiceUnion {
      constexpr ParameterChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool bool_param_;
      uint32_t uint32_param_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_param_;
    } parameter_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LogSettingsResponse_SettingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogSettingsResponse_SettingsEntry_DoNotUse, 
    std::string, ::inference::LogSettingsResponse_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogSettingsResponse_SettingsEntry_DoNotUse, 
    std::string, ::inference::LogSettingsResponse_SettingValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LogSettingsResponse_SettingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogSettingsResponse_SettingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogSettingsResponse_SettingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogSettingsResponse_SettingsEntry_DoNotUse& other);
  static const LogSettingsResponse_SettingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogSettingsResponse_SettingsEntry_DoNotUse*>(&_LogSettingsResponse_SettingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.LogSettingsResponse.SettingsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class LogSettingsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.LogSettingsResponse) */ {
 public:
  inline LogSettingsResponse() : LogSettingsResponse(nullptr) {}
  ~LogSettingsResponse() override;
  explicit PROTOBUF_CONSTEXPR LogSettingsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSettingsResponse(const LogSettingsResponse& from);
  LogSettingsResponse(LogSettingsResponse&& from) noexcept
    : LogSettingsResponse() {
    *this = ::std::move(from);
  }

  inline LogSettingsResponse& operator=(const LogSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSettingsResponse& operator=(LogSettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogSettingsResponse* internal_default_instance() {
    return reinterpret_cast<const LogSettingsResponse*>(
               &_LogSettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(LogSettingsResponse& a, LogSettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSettingsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSettingsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSettingsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSettingsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogSettingsResponse& from) {
    LogSettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSettingsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.LogSettingsResponse";
  }
  protected:
  explicit LogSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogSettingsResponse_SettingValue SettingValue;

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // map<string, .inference.LogSettingsResponse.SettingValue> settings = 1;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >&
      _internal_settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >*
      _internal_mutable_settings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >&
      settings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >*
      mutable_settings();

  // @@protoc_insertion_point(class_scope:inference.LogSettingsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogSettingsResponse_SettingsEntry_DoNotUse,
        std::string, ::inference::LogSettingsResponse_SettingValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerLiveRequest

// -------------------------------------------------------------------

// ServerLiveResponse

// bool live = 1;
inline void ServerLiveResponse::clear_live() {
  _impl_.live_ = false;
}
inline bool ServerLiveResponse::_internal_live() const {
  return _impl_.live_;
}
inline bool ServerLiveResponse::live() const {
  // @@protoc_insertion_point(field_get:inference.ServerLiveResponse.live)
  return _internal_live();
}
inline void ServerLiveResponse::_internal_set_live(bool value) {
  
  _impl_.live_ = value;
}
inline void ServerLiveResponse::set_live(bool value) {
  _internal_set_live(value);
  // @@protoc_insertion_point(field_set:inference.ServerLiveResponse.live)
}

// -------------------------------------------------------------------

// ServerReadyRequest

// -------------------------------------------------------------------

// ServerReadyResponse

// bool ready = 1;
inline void ServerReadyResponse::clear_ready() {
  _impl_.ready_ = false;
}
inline bool ServerReadyResponse::_internal_ready() const {
  return _impl_.ready_;
}
inline bool ServerReadyResponse::ready() const {
  // @@protoc_insertion_point(field_get:inference.ServerReadyResponse.ready)
  return _internal_ready();
}
inline void ServerReadyResponse::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void ServerReadyResponse::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:inference.ServerReadyResponse.ready)
}

// -------------------------------------------------------------------

// ModelReadyRequest

// string name = 1;
inline void ModelReadyRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelReadyRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelReadyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReadyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelReadyRequest.name)
}
inline std::string* ModelReadyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelReadyRequest.name)
  return _s;
}
inline const std::string& ModelReadyRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelReadyRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelReadyRequest.name)
  return _impl_.name_.Release();
}
inline void ModelReadyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelReadyRequest.name)
}

// string version = 2;
inline void ModelReadyRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelReadyRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelReadyRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReadyRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelReadyRequest.version)
}
inline std::string* ModelReadyRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelReadyRequest.version)
  return _s;
}
inline const std::string& ModelReadyRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelReadyRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelReadyRequest.version)
  return _impl_.version_.Release();
}
inline void ModelReadyRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelReadyRequest.version)
}

// -------------------------------------------------------------------

// ModelReadyResponse

// bool ready = 1;
inline void ModelReadyResponse::clear_ready() {
  _impl_.ready_ = false;
}
inline bool ModelReadyResponse::_internal_ready() const {
  return _impl_.ready_;
}
inline bool ModelReadyResponse::ready() const {
  // @@protoc_insertion_point(field_get:inference.ModelReadyResponse.ready)
  return _internal_ready();
}
inline void ModelReadyResponse::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void ModelReadyResponse::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:inference.ModelReadyResponse.ready)
}

// -------------------------------------------------------------------

// ServerMetadataRequest

// -------------------------------------------------------------------

// ServerMetadataResponse

// string name = 1;
inline void ServerMetadataResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServerMetadataResponse::name() const {
  // @@protoc_insertion_point(field_get:inference.ServerMetadataResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerMetadataResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.name)
}
inline std::string* ServerMetadataResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ServerMetadataResponse.name)
  return _s;
}
inline const std::string& ServerMetadataResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ServerMetadataResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::release_name() {
  // @@protoc_insertion_point(field_release:inference.ServerMetadataResponse.name)
  return _impl_.name_.Release();
}
inline void ServerMetadataResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ServerMetadataResponse.name)
}

// string version = 2;
inline void ServerMetadataResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ServerMetadataResponse::version() const {
  // @@protoc_insertion_point(field_get:inference.ServerMetadataResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerMetadataResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.version)
}
inline std::string* ServerMetadataResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ServerMetadataResponse.version)
  return _s;
}
inline const std::string& ServerMetadataResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ServerMetadataResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::release_version() {
  // @@protoc_insertion_point(field_release:inference.ServerMetadataResponse.version)
  return _impl_.version_.Release();
}
inline void ServerMetadataResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ServerMetadataResponse.version)
}

// repeated string extensions = 3;
inline int ServerMetadataResponse::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int ServerMetadataResponse::extensions_size() const {
  return _internal_extensions_size();
}
inline void ServerMetadataResponse::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline std::string* ServerMetadataResponse::add_extensions() {
  std::string* _s = _internal_add_extensions();
  // @@protoc_insertion_point(field_add_mutable:inference.ServerMetadataResponse.extensions)
  return _s;
}
inline const std::string& ServerMetadataResponse::_internal_extensions(int index) const {
  return _impl_.extensions_.Get(index);
}
inline const std::string& ServerMetadataResponse::extensions(int index) const {
  // @@protoc_insertion_point(field_get:inference.ServerMetadataResponse.extensions)
  return _internal_extensions(index);
}
inline std::string* ServerMetadataResponse::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ServerMetadataResponse.extensions)
  return _impl_.extensions_.Mutable(index);
}
inline void ServerMetadataResponse::set_extensions(int index, const std::string& value) {
  _impl_.extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::set_extensions(int index, std::string&& value) {
  _impl_.extensions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::set_extensions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::set_extensions(int index, const char* value, size_t size) {
  _impl_.extensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ServerMetadataResponse.extensions)
}
inline std::string* ServerMetadataResponse::_internal_add_extensions() {
  return _impl_.extensions_.Add();
}
inline void ServerMetadataResponse::add_extensions(const std::string& value) {
  _impl_.extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::add_extensions(std::string&& value) {
  _impl_.extensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::add_extensions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::add_extensions(const char* value, size_t size) {
  _impl_.extensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ServerMetadataResponse.extensions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMetadataResponse::extensions() const {
  // @@protoc_insertion_point(field_list:inference.ServerMetadataResponse.extensions)
  return _impl_.extensions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerMetadataResponse::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:inference.ServerMetadataResponse.extensions)
  return &_impl_.extensions_;
}

// -------------------------------------------------------------------

// ModelMetadataRequest

// string name = 1;
inline void ModelMetadataRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelMetadataRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataRequest.name)
}
inline std::string* ModelMetadataRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataRequest.name)
  return _s;
}
inline const std::string& ModelMetadataRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelMetadataRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataRequest.name)
  return _impl_.name_.Release();
}
inline void ModelMetadataRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataRequest.name)
}

// string version = 2;
inline void ModelMetadataRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelMetadataRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataRequest.version)
}
inline std::string* ModelMetadataRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataRequest.version)
  return _s;
}
inline const std::string& ModelMetadataRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelMetadataRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataRequest.version)
  return _impl_.version_.Release();
}
inline void ModelMetadataRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataRequest.version)
}

// -------------------------------------------------------------------

// ModelMetadataResponse_TensorMetadata

// string name = 1;
inline void ModelMetadataResponse_TensorMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse_TensorMetadata::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.TensorMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse_TensorMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.TensorMetadata.name)
}
inline std::string* ModelMetadataResponse_TensorMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.TensorMetadata.name)
  return _s;
}
inline const std::string& ModelMetadataResponse_TensorMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelMetadataResponse_TensorMetadata::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse.TensorMetadata.name)
  return _impl_.name_.Release();
}
inline void ModelMetadataResponse_TensorMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse.TensorMetadata.name)
}

// string datatype = 2;
inline void ModelMetadataResponse_TensorMetadata::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse_TensorMetadata::datatype() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.TensorMetadata.datatype)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse_TensorMetadata::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.TensorMetadata.datatype)
}
inline std::string* ModelMetadataResponse_TensorMetadata::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.TensorMetadata.datatype)
  return _s;
}
inline const std::string& ModelMetadataResponse_TensorMetadata::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void ModelMetadataResponse_TensorMetadata::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::release_datatype() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse.TensorMetadata.datatype)
  return _impl_.datatype_.Release();
}
inline void ModelMetadataResponse_TensorMetadata::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse.TensorMetadata.datatype)
}

// repeated int64 shape = 3;
inline int ModelMetadataResponse_TensorMetadata::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int ModelMetadataResponse_TensorMetadata::shape_size() const {
  return _internal_shape_size();
}
inline void ModelMetadataResponse_TensorMetadata::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t ModelMetadataResponse_TensorMetadata::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t ModelMetadataResponse_TensorMetadata::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.TensorMetadata.shape)
  return _internal_shape(index);
}
inline void ModelMetadataResponse_TensorMetadata::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.TensorMetadata.shape)
}
inline void ModelMetadataResponse_TensorMetadata::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void ModelMetadataResponse_TensorMetadata::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.TensorMetadata.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelMetadataResponse_TensorMetadata::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelMetadataResponse_TensorMetadata::shape() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.TensorMetadata.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelMetadataResponse_TensorMetadata::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelMetadataResponse_TensorMetadata::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.TensorMetadata.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// ModelMetadataResponse

// string name = 1;
inline void ModelMetadataResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.name)
}
inline std::string* ModelMetadataResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.name)
  return _s;
}
inline const std::string& ModelMetadataResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelMetadataResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse.name)
  return _impl_.name_.Release();
}
inline void ModelMetadataResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse.name)
}

// repeated string versions = 2;
inline int ModelMetadataResponse::_internal_versions_size() const {
  return _impl_.versions_.size();
}
inline int ModelMetadataResponse::versions_size() const {
  return _internal_versions_size();
}
inline void ModelMetadataResponse::clear_versions() {
  _impl_.versions_.Clear();
}
inline std::string* ModelMetadataResponse::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelMetadataResponse.versions)
  return _s;
}
inline const std::string& ModelMetadataResponse::_internal_versions(int index) const {
  return _impl_.versions_.Get(index);
}
inline const std::string& ModelMetadataResponse::versions(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.versions)
  return _internal_versions(index);
}
inline std::string* ModelMetadataResponse::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.versions)
  return _impl_.versions_.Mutable(index);
}
inline void ModelMetadataResponse::set_versions(int index, const std::string& value) {
  _impl_.versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::set_versions(int index, std::string&& value) {
  _impl_.versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::set_versions(int index, const char* value, size_t size) {
  _impl_.versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelMetadataResponse.versions)
}
inline std::string* ModelMetadataResponse::_internal_add_versions() {
  return _impl_.versions_.Add();
}
inline void ModelMetadataResponse::add_versions(const std::string& value) {
  _impl_.versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::add_versions(std::string&& value) {
  _impl_.versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::add_versions(const char* value, size_t size) {
  _impl_.versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelMetadataResponse.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelMetadataResponse::versions() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.versions)
  return _impl_.versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelMetadataResponse::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.versions)
  return &_impl_.versions_;
}

// string platform = 3;
inline void ModelMetadataResponse::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse::platform() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse::set_platform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.platform)
}
inline std::string* ModelMetadataResponse::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.platform)
  return _s;
}
inline const std::string& ModelMetadataResponse::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void ModelMetadataResponse::_internal_set_platform(const std::string& value) {
  
  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::_internal_mutable_platform() {
  
  return _impl_.platform_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::release_platform() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse.platform)
  return _impl_.platform_.Release();
}
inline void ModelMetadataResponse::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  _impl_.platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse.platform)
}

// repeated .inference.ModelMetadataResponse.TensorMetadata inputs = 4;
inline int ModelMetadataResponse::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int ModelMetadataResponse::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelMetadataResponse::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
ModelMetadataResponse::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.inputs)
  return &_impl_.inputs_;
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::inputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.inputs)
  return _internal_inputs(index);
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::add_inputs() {
  ::inference::ModelMetadataResponse_TensorMetadata* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
ModelMetadataResponse::inputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.inputs)
  return _impl_.inputs_;
}

// repeated .inference.ModelMetadataResponse.TensorMetadata outputs = 5;
inline int ModelMetadataResponse::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelMetadataResponse::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelMetadataResponse::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
ModelMetadataResponse::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.outputs)
  return _internal_outputs(index);
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::add_outputs() {
  ::inference::ModelMetadataResponse_TensorMetadata* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
ModelMetadataResponse::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.outputs)
  return _impl_.outputs_;
}

// -------------------------------------------------------------------

// InferParameter

// bool bool_param = 1;
inline bool InferParameter::_internal_has_bool_param() const {
  return parameter_choice_case() == kBoolParam;
}
inline bool InferParameter::has_bool_param() const {
  return _internal_has_bool_param();
}
inline void InferParameter::set_has_bool_param() {
  _impl_._oneof_case_[0] = kBoolParam;
}
inline void InferParameter::clear_bool_param() {
  if (_internal_has_bool_param()) {
    _impl_.parameter_choice_.bool_param_ = false;
    clear_has_parameter_choice();
  }
}
inline bool InferParameter::_internal_bool_param() const {
  if (_internal_has_bool_param()) {
    return _impl_.parameter_choice_.bool_param_;
  }
  return false;
}
inline void InferParameter::_internal_set_bool_param(bool value) {
  if (!_internal_has_bool_param()) {
    clear_parameter_choice();
    set_has_bool_param();
  }
  _impl_.parameter_choice_.bool_param_ = value;
}
inline bool InferParameter::bool_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.bool_param)
  return _internal_bool_param();
}
inline void InferParameter::set_bool_param(bool value) {
  _internal_set_bool_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.bool_param)
}

// int64 int64_param = 2;
inline bool InferParameter::_internal_has_int64_param() const {
  return parameter_choice_case() == kInt64Param;
}
inline bool InferParameter::has_int64_param() const {
  return _internal_has_int64_param();
}
inline void InferParameter::set_has_int64_param() {
  _impl_._oneof_case_[0] = kInt64Param;
}
inline void InferParameter::clear_int64_param() {
  if (_internal_has_int64_param()) {
    _impl_.parameter_choice_.int64_param_ = int64_t{0};
    clear_has_parameter_choice();
  }
}
inline int64_t InferParameter::_internal_int64_param() const {
  if (_internal_has_int64_param()) {
    return _impl_.parameter_choice_.int64_param_;
  }
  return int64_t{0};
}
inline void InferParameter::_internal_set_int64_param(int64_t value) {
  if (!_internal_has_int64_param()) {
    clear_parameter_choice();
    set_has_int64_param();
  }
  _impl_.parameter_choice_.int64_param_ = value;
}
inline int64_t InferParameter::int64_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.int64_param)
  return _internal_int64_param();
}
inline void InferParameter::set_int64_param(int64_t value) {
  _internal_set_int64_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.int64_param)
}

// string string_param = 3;
inline bool InferParameter::_internal_has_string_param() const {
  return parameter_choice_case() == kStringParam;
}
inline bool InferParameter::has_string_param() const {
  return _internal_has_string_param();
}
inline void InferParameter::set_has_string_param() {
  _impl_._oneof_case_[0] = kStringParam;
}
inline void InferParameter::clear_string_param() {
  if (_internal_has_string_param()) {
    _impl_.parameter_choice_.string_param_.Destroy();
    clear_has_parameter_choice();
  }
}
inline const std::string& InferParameter::string_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.string_param)
  return _internal_string_param();
}
template <typename ArgT0, typename... ArgT>
inline void InferParameter::set_string_param(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferParameter.string_param)
}
inline std::string* InferParameter::mutable_string_param() {
  std::string* _s = _internal_mutable_string_param();
  // @@protoc_insertion_point(field_mutable:inference.InferParameter.string_param)
  return _s;
}
inline const std::string& InferParameter::_internal_string_param() const {
  if (_internal_has_string_param()) {
    return _impl_.parameter_choice_.string_param_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InferParameter::_internal_set_string_param(const std::string& value) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set(value, GetArenaForAllocation());
}
inline std::string* InferParameter::_internal_mutable_string_param() {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  return _impl_.parameter_choice_.string_param_.Mutable(      GetArenaForAllocation());
}
inline std::string* InferParameter::release_string_param() {
  // @@protoc_insertion_point(field_release:inference.InferParameter.string_param)
  if (_internal_has_string_param()) {
    clear_has_parameter_choice();
    return _impl_.parameter_choice_.string_param_.Release();
  } else {
    return nullptr;
  }
}
inline void InferParameter::set_allocated_string_param(std::string* string_param) {
  if (has_parameter_choice()) {
    clear_parameter_choice();
  }
  if (string_param != nullptr) {
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitAllocated(string_param, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.InferParameter.string_param)
}

// double double_param = 4;
inline bool InferParameter::_internal_has_double_param() const {
  return parameter_choice_case() == kDoubleParam;
}
inline bool InferParameter::has_double_param() const {
  return _internal_has_double_param();
}
inline void InferParameter::set_has_double_param() {
  _impl_._oneof_case_[0] = kDoubleParam;
}
inline void InferParameter::clear_double_param() {
  if (_internal_has_double_param()) {
    _impl_.parameter_choice_.double_param_ = 0;
    clear_has_parameter_choice();
  }
}
inline double InferParameter::_internal_double_param() const {
  if (_internal_has_double_param()) {
    return _impl_.parameter_choice_.double_param_;
  }
  return 0;
}
inline void InferParameter::_internal_set_double_param(double value) {
  if (!_internal_has_double_param()) {
    clear_parameter_choice();
    set_has_double_param();
  }
  _impl_.parameter_choice_.double_param_ = value;
}
inline double InferParameter::double_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.double_param)
  return _internal_double_param();
}
inline void InferParameter::set_double_param(double value) {
  _internal_set_double_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.double_param)
}

// uint64 uint64_param = 5;
inline bool InferParameter::_internal_has_uint64_param() const {
  return parameter_choice_case() == kUint64Param;
}
inline bool InferParameter::has_uint64_param() const {
  return _internal_has_uint64_param();
}
inline void InferParameter::set_has_uint64_param() {
  _impl_._oneof_case_[0] = kUint64Param;
}
inline void InferParameter::clear_uint64_param() {
  if (_internal_has_uint64_param()) {
    _impl_.parameter_choice_.uint64_param_ = uint64_t{0u};
    clear_has_parameter_choice();
  }
}
inline uint64_t InferParameter::_internal_uint64_param() const {
  if (_internal_has_uint64_param()) {
    return _impl_.parameter_choice_.uint64_param_;
  }
  return uint64_t{0u};
}
inline void InferParameter::_internal_set_uint64_param(uint64_t value) {
  if (!_internal_has_uint64_param()) {
    clear_parameter_choice();
    set_has_uint64_param();
  }
  _impl_.parameter_choice_.uint64_param_ = value;
}
inline uint64_t InferParameter::uint64_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.uint64_param)
  return _internal_uint64_param();
}
inline void InferParameter::set_uint64_param(uint64_t value) {
  _internal_set_uint64_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.uint64_param)
}

inline bool InferParameter::has_parameter_choice() const {
  return parameter_choice_case() != PARAMETER_CHOICE_NOT_SET;
}
inline void InferParameter::clear_has_parameter_choice() {
  _impl_._oneof_case_[0] = PARAMETER_CHOICE_NOT_SET;
}
inline InferParameter::ParameterChoiceCase InferParameter::parameter_choice_case() const {
  return InferParameter::ParameterChoiceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InferTensorContents

// repeated bool bool_contents = 1;
inline int InferTensorContents::_internal_bool_contents_size() const {
  return _impl_.bool_contents_.size();
}
inline int InferTensorContents::bool_contents_size() const {
  return _internal_bool_contents_size();
}
inline void InferTensorContents::clear_bool_contents() {
  _impl_.bool_contents_.Clear();
}
inline bool InferTensorContents::_internal_bool_contents(int index) const {
  return _impl_.bool_contents_.Get(index);
}
inline bool InferTensorContents::bool_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.bool_contents)
  return _internal_bool_contents(index);
}
inline void InferTensorContents::set_bool_contents(int index, bool value) {
  _impl_.bool_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.bool_contents)
}
inline void InferTensorContents::_internal_add_bool_contents(bool value) {
  _impl_.bool_contents_.Add(value);
}
inline void InferTensorContents::add_bool_contents(bool value) {
  _internal_add_bool_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.bool_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
InferTensorContents::_internal_bool_contents() const {
  return _impl_.bool_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
InferTensorContents::bool_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.bool_contents)
  return _internal_bool_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
InferTensorContents::_internal_mutable_bool_contents() {
  return &_impl_.bool_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
InferTensorContents::mutable_bool_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.bool_contents)
  return _internal_mutable_bool_contents();
}

// repeated int32 int_contents = 2;
inline int InferTensorContents::_internal_int_contents_size() const {
  return _impl_.int_contents_.size();
}
inline int InferTensorContents::int_contents_size() const {
  return _internal_int_contents_size();
}
inline void InferTensorContents::clear_int_contents() {
  _impl_.int_contents_.Clear();
}
inline int32_t InferTensorContents::_internal_int_contents(int index) const {
  return _impl_.int_contents_.Get(index);
}
inline int32_t InferTensorContents::int_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.int_contents)
  return _internal_int_contents(index);
}
inline void InferTensorContents::set_int_contents(int index, int32_t value) {
  _impl_.int_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.int_contents)
}
inline void InferTensorContents::_internal_add_int_contents(int32_t value) {
  _impl_.int_contents_.Add(value);
}
inline void InferTensorContents::add_int_contents(int32_t value) {
  _internal_add_int_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.int_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
InferTensorContents::_internal_int_contents() const {
  return _impl_.int_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
InferTensorContents::int_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.int_contents)
  return _internal_int_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
InferTensorContents::_internal_mutable_int_contents() {
  return &_impl_.int_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
InferTensorContents::mutable_int_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.int_contents)
  return _internal_mutable_int_contents();
}

// repeated int64 int64_contents = 3;
inline int InferTensorContents::_internal_int64_contents_size() const {
  return _impl_.int64_contents_.size();
}
inline int InferTensorContents::int64_contents_size() const {
  return _internal_int64_contents_size();
}
inline void InferTensorContents::clear_int64_contents() {
  _impl_.int64_contents_.Clear();
}
inline int64_t InferTensorContents::_internal_int64_contents(int index) const {
  return _impl_.int64_contents_.Get(index);
}
inline int64_t InferTensorContents::int64_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.int64_contents)
  return _internal_int64_contents(index);
}
inline void InferTensorContents::set_int64_contents(int index, int64_t value) {
  _impl_.int64_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.int64_contents)
}
inline void InferTensorContents::_internal_add_int64_contents(int64_t value) {
  _impl_.int64_contents_.Add(value);
}
inline void InferTensorContents::add_int64_contents(int64_t value) {
  _internal_add_int64_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.int64_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
InferTensorContents::_internal_int64_contents() const {
  return _impl_.int64_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
InferTensorContents::int64_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.int64_contents)
  return _internal_int64_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
InferTensorContents::_internal_mutable_int64_contents() {
  return &_impl_.int64_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
InferTensorContents::mutable_int64_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.int64_contents)
  return _internal_mutable_int64_contents();
}

// repeated uint32 uint_contents = 4;
inline int InferTensorContents::_internal_uint_contents_size() const {
  return _impl_.uint_contents_.size();
}
inline int InferTensorContents::uint_contents_size() const {
  return _internal_uint_contents_size();
}
inline void InferTensorContents::clear_uint_contents() {
  _impl_.uint_contents_.Clear();
}
inline uint32_t InferTensorContents::_internal_uint_contents(int index) const {
  return _impl_.uint_contents_.Get(index);
}
inline uint32_t InferTensorContents::uint_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.uint_contents)
  return _internal_uint_contents(index);
}
inline void InferTensorContents::set_uint_contents(int index, uint32_t value) {
  _impl_.uint_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.uint_contents)
}
inline void InferTensorContents::_internal_add_uint_contents(uint32_t value) {
  _impl_.uint_contents_.Add(value);
}
inline void InferTensorContents::add_uint_contents(uint32_t value) {
  _internal_add_uint_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.uint_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
InferTensorContents::_internal_uint_contents() const {
  return _impl_.uint_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
InferTensorContents::uint_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.uint_contents)
  return _internal_uint_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
InferTensorContents::_internal_mutable_uint_contents() {
  return &_impl_.uint_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
InferTensorContents::mutable_uint_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.uint_contents)
  return _internal_mutable_uint_contents();
}

// repeated uint64 uint64_contents = 5;
inline int InferTensorContents::_internal_uint64_contents_size() const {
  return _impl_.uint64_contents_.size();
}
inline int InferTensorContents::uint64_contents_size() const {
  return _internal_uint64_contents_size();
}
inline void InferTensorContents::clear_uint64_contents() {
  _impl_.uint64_contents_.Clear();
}
inline uint64_t InferTensorContents::_internal_uint64_contents(int index) const {
  return _impl_.uint64_contents_.Get(index);
}
inline uint64_t InferTensorContents::uint64_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.uint64_contents)
  return _internal_uint64_contents(index);
}
inline void InferTensorContents::set_uint64_contents(int index, uint64_t value) {
  _impl_.uint64_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.uint64_contents)
}
inline void InferTensorContents::_internal_add_uint64_contents(uint64_t value) {
  _impl_.uint64_contents_.Add(value);
}
inline void InferTensorContents::add_uint64_contents(uint64_t value) {
  _internal_add_uint64_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.uint64_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
InferTensorContents::_internal_uint64_contents() const {
  return _impl_.uint64_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
InferTensorContents::uint64_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.uint64_contents)
  return _internal_uint64_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
InferTensorContents::_internal_mutable_uint64_contents() {
  return &_impl_.uint64_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
InferTensorContents::mutable_uint64_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.uint64_contents)
  return _internal_mutable_uint64_contents();
}

// repeated float fp32_contents = 6;
inline int InferTensorContents::_internal_fp32_contents_size() const {
  return _impl_.fp32_contents_.size();
}
inline int InferTensorContents::fp32_contents_size() const {
  return _internal_fp32_contents_size();
}
inline void InferTensorContents::clear_fp32_contents() {
  _impl_.fp32_contents_.Clear();
}
inline float InferTensorContents::_internal_fp32_contents(int index) const {
  return _impl_.fp32_contents_.Get(index);
}
inline float InferTensorContents::fp32_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.fp32_contents)
  return _internal_fp32_contents(index);
}
inline void InferTensorContents::set_fp32_contents(int index, float value) {
  _impl_.fp32_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.fp32_contents)
}
inline void InferTensorContents::_internal_add_fp32_contents(float value) {
  _impl_.fp32_contents_.Add(value);
}
inline void InferTensorContents::add_fp32_contents(float value) {
  _internal_add_fp32_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.fp32_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
InferTensorContents::_internal_fp32_contents() const {
  return _impl_.fp32_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
InferTensorContents::fp32_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.fp32_contents)
  return _internal_fp32_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
InferTensorContents::_internal_mutable_fp32_contents() {
  return &_impl_.fp32_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
InferTensorContents::mutable_fp32_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.fp32_contents)
  return _internal_mutable_fp32_contents();
}

// repeated double fp64_contents = 7;
inline int InferTensorContents::_internal_fp64_contents_size() const {
  return _impl_.fp64_contents_.size();
}
inline int InferTensorContents::fp64_contents_size() const {
  return _internal_fp64_contents_size();
}
inline void InferTensorContents::clear_fp64_contents() {
  _impl_.fp64_contents_.Clear();
}
inline double InferTensorContents::_internal_fp64_contents(int index) const {
  return _impl_.fp64_contents_.Get(index);
}
inline double InferTensorContents::fp64_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.fp64_contents)
  return _internal_fp64_contents(index);
}
inline void InferTensorContents::set_fp64_contents(int index, double value) {
  _impl_.fp64_contents_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.fp64_contents)
}
inline void InferTensorContents::_internal_add_fp64_contents(double value) {
  _impl_.fp64_contents_.Add(value);
}
inline void InferTensorContents::add_fp64_contents(double value) {
  _internal_add_fp64_contents(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.fp64_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
InferTensorContents::_internal_fp64_contents() const {
  return _impl_.fp64_contents_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
InferTensorContents::fp64_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.fp64_contents)
  return _internal_fp64_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
InferTensorContents::_internal_mutable_fp64_contents() {
  return &_impl_.fp64_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
InferTensorContents::mutable_fp64_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.fp64_contents)
  return _internal_mutable_fp64_contents();
}

// repeated bytes bytes_contents = 8;
inline int InferTensorContents::_internal_bytes_contents_size() const {
  return _impl_.bytes_contents_.size();
}
inline int InferTensorContents::bytes_contents_size() const {
  return _internal_bytes_contents_size();
}
inline void InferTensorContents::clear_bytes_contents() {
  _impl_.bytes_contents_.Clear();
}
inline std::string* InferTensorContents::add_bytes_contents() {
  std::string* _s = _internal_add_bytes_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.InferTensorContents.bytes_contents)
  return _s;
}
inline const std::string& InferTensorContents::_internal_bytes_contents(int index) const {
  return _impl_.bytes_contents_.Get(index);
}
inline const std::string& InferTensorContents::bytes_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferTensorContents.bytes_contents)
  return _internal_bytes_contents(index);
}
inline std::string* InferTensorContents::mutable_bytes_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.InferTensorContents.bytes_contents)
  return _impl_.bytes_contents_.Mutable(index);
}
inline void InferTensorContents::set_bytes_contents(int index, const std::string& value) {
  _impl_.bytes_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.bytes_contents)
}
inline void InferTensorContents::set_bytes_contents(int index, std::string&& value) {
  _impl_.bytes_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.InferTensorContents.bytes_contents)
}
inline void InferTensorContents::set_bytes_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bytes_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.InferTensorContents.bytes_contents)
}
inline void InferTensorContents::set_bytes_contents(int index, const void* value, size_t size) {
  _impl_.bytes_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.InferTensorContents.bytes_contents)
}
inline std::string* InferTensorContents::_internal_add_bytes_contents() {
  return _impl_.bytes_contents_.Add();
}
inline void InferTensorContents::add_bytes_contents(const std::string& value) {
  _impl_.bytes_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.bytes_contents)
}
inline void InferTensorContents::add_bytes_contents(std::string&& value) {
  _impl_.bytes_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.InferTensorContents.bytes_contents)
}
inline void InferTensorContents::add_bytes_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bytes_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.InferTensorContents.bytes_contents)
}
inline void InferTensorContents::add_bytes_contents(const void* value, size_t size) {
  _impl_.bytes_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.InferTensorContents.bytes_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InferTensorContents::bytes_contents() const {
  // @@protoc_insertion_point(field_list:inference.InferTensorContents.bytes_contents)
  return _impl_.bytes_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InferTensorContents::mutable_bytes_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferTensorContents.bytes_contents)
  return &_impl_.bytes_contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferRequest_InferInputTensor

// string name = 1;
inline void ModelInferRequest_InferInputTensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelInferRequest_InferInputTensor::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.InferInputTensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest_InferInputTensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.InferInputTensor.name)
}
inline std::string* ModelInferRequest_InferInputTensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.InferInputTensor.name)
  return _s;
}
inline const std::string& ModelInferRequest_InferInputTensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelInferRequest_InferInputTensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest_InferInputTensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest_InferInputTensor::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.InferInputTensor.name)
  return _impl_.name_.Release();
}
inline void ModelInferRequest_InferInputTensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.InferInputTensor.name)
}

// string datatype = 2;
inline void ModelInferRequest_InferInputTensor::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& ModelInferRequest_InferInputTensor::datatype() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.InferInputTensor.datatype)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest_InferInputTensor::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.InferInputTensor.datatype)
}
inline std::string* ModelInferRequest_InferInputTensor::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.InferInputTensor.datatype)
  return _s;
}
inline const std::string& ModelInferRequest_InferInputTensor::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void ModelInferRequest_InferInputTensor::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest_InferInputTensor::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest_InferInputTensor::release_datatype() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.InferInputTensor.datatype)
  return _impl_.datatype_.Release();
}
inline void ModelInferRequest_InferInputTensor::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.InferInputTensor.datatype)
}

// repeated int64 shape = 3;
inline int ModelInferRequest_InferInputTensor::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int ModelInferRequest_InferInputTensor::shape_size() const {
  return _internal_shape_size();
}
inline void ModelInferRequest_InferInputTensor::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t ModelInferRequest_InferInputTensor::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t ModelInferRequest_InferInputTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.InferInputTensor.shape)
  return _internal_shape(index);
}
inline void ModelInferRequest_InferInputTensor::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.InferInputTensor.shape)
}
inline void ModelInferRequest_InferInputTensor::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void ModelInferRequest_InferInputTensor::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.InferInputTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelInferRequest_InferInputTensor::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelInferRequest_InferInputTensor::shape() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.InferInputTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelInferRequest_InferInputTensor::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelInferRequest_InferInputTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.InferInputTensor.shape)
  return _internal_mutable_shape();
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelInferRequest_InferInputTensor::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferRequest_InferInputTensor::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferRequest_InferInputTensor::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest_InferInputTensor::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest_InferInputTensor::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferRequest.InferInputTensor.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest_InferInputTensor::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest_InferInputTensor::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferRequest.InferInputTensor.parameters)
  return _internal_mutable_parameters();
}

// .inference.InferTensorContents contents = 5;
inline bool ModelInferRequest_InferInputTensor::_internal_has_contents() const {
  return this != internal_default_instance() && _impl_.contents_ != nullptr;
}
inline bool ModelInferRequest_InferInputTensor::has_contents() const {
  return _internal_has_contents();
}
inline void ModelInferRequest_InferInputTensor::clear_contents() {
  if (GetArenaForAllocation() == nullptr && _impl_.contents_ != nullptr) {
    delete _impl_.contents_;
  }
  _impl_.contents_ = nullptr;
}
inline const ::inference::InferTensorContents& ModelInferRequest_InferInputTensor::_internal_contents() const {
  const ::inference::InferTensorContents* p = _impl_.contents_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::InferTensorContents&>(
      ::inference::_InferTensorContents_default_instance_);
}
inline const ::inference::InferTensorContents& ModelInferRequest_InferInputTensor::contents() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.InferInputTensor.contents)
  return _internal_contents();
}
inline void ModelInferRequest_InferInputTensor::unsafe_arena_set_allocated_contents(
    ::inference::InferTensorContents* contents) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contents_);
  }
  _impl_.contents_ = contents;
  if (contents) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelInferRequest.InferInputTensor.contents)
}
inline ::inference::InferTensorContents* ModelInferRequest_InferInputTensor::release_contents() {
  
  ::inference::InferTensorContents* temp = _impl_.contents_;
  _impl_.contents_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::InferTensorContents* ModelInferRequest_InferInputTensor::unsafe_arena_release_contents() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.InferInputTensor.contents)
  
  ::inference::InferTensorContents* temp = _impl_.contents_;
  _impl_.contents_ = nullptr;
  return temp;
}
inline ::inference::InferTensorContents* ModelInferRequest_InferInputTensor::_internal_mutable_contents() {
  
  if (_impl_.contents_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::InferTensorContents>(GetArenaForAllocation());
    _impl_.contents_ = p;
  }
  return _impl_.contents_;
}
inline ::inference::InferTensorContents* ModelInferRequest_InferInputTensor::mutable_contents() {
  ::inference::InferTensorContents* _msg = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.InferInputTensor.contents)
  return _msg;
}
inline void ModelInferRequest_InferInputTensor::set_allocated_contents(::inference::InferTensorContents* contents) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contents_;
  }
  if (contents) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contents);
    if (message_arena != submessage_arena) {
      contents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contents, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contents_ = contents;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.InferInputTensor.contents)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferRequest_InferRequestedOutputTensor

// string name = 1;
inline void ModelInferRequest_InferRequestedOutputTensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelInferRequest_InferRequestedOutputTensor::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.InferRequestedOutputTensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest_InferRequestedOutputTensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.InferRequestedOutputTensor.name)
}
inline std::string* ModelInferRequest_InferRequestedOutputTensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.InferRequestedOutputTensor.name)
  return _s;
}
inline const std::string& ModelInferRequest_InferRequestedOutputTensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelInferRequest_InferRequestedOutputTensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest_InferRequestedOutputTensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest_InferRequestedOutputTensor::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.InferRequestedOutputTensor.name)
  return _impl_.name_.Release();
}
inline void ModelInferRequest_InferRequestedOutputTensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.InferRequestedOutputTensor.name)
}

// map<string, .inference.InferParameter> parameters = 2;
inline int ModelInferRequest_InferRequestedOutputTensor::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferRequest_InferRequestedOutputTensor::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferRequest_InferRequestedOutputTensor::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest_InferRequestedOutputTensor::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest_InferRequestedOutputTensor::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferRequest.InferRequestedOutputTensor.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest_InferRequestedOutputTensor::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest_InferRequestedOutputTensor::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferRequest.InferRequestedOutputTensor.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferRequest

// string model_name = 1;
inline void ModelInferRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelInferRequest::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.model_name)
}
inline std::string* ModelInferRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.model_name)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelInferRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelInferRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.model_name)
}

// string model_version = 2;
inline void ModelInferRequest::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& ModelInferRequest::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.model_version)
}
inline std::string* ModelInferRequest::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.model_version)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void ModelInferRequest::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest::release_model_version() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.model_version)
  return _impl_.model_version_.Release();
}
inline void ModelInferRequest::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.model_version)
}

// string id = 3;
inline void ModelInferRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelInferRequest::id() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.id)
}
inline std::string* ModelInferRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.id)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelInferRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest::release_id() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.id)
  return _impl_.id_.Release();
}
inline void ModelInferRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.id)
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelInferRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferRequest.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.ModelInferRequest.InferInputTensor inputs = 5;
inline int ModelInferRequest::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int ModelInferRequest::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelInferRequest::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::inference::ModelInferRequest_InferInputTensor* ModelInferRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferInputTensor >*
ModelInferRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.inputs)
  return &_impl_.inputs_;
}
inline const ::inference::ModelInferRequest_InferInputTensor& ModelInferRequest::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::inference::ModelInferRequest_InferInputTensor& ModelInferRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.inputs)
  return _internal_inputs(index);
}
inline ::inference::ModelInferRequest_InferInputTensor* ModelInferRequest::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::inference::ModelInferRequest_InferInputTensor* ModelInferRequest::add_inputs() {
  ::inference::ModelInferRequest_InferInputTensor* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferInputTensor >&
ModelInferRequest::inputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.inputs)
  return _impl_.inputs_;
}

// repeated .inference.ModelInferRequest.InferRequestedOutputTensor outputs = 6;
inline int ModelInferRequest::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelInferRequest::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelInferRequest::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::ModelInferRequest_InferRequestedOutputTensor* ModelInferRequest::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferRequestedOutputTensor >*
ModelInferRequest::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::ModelInferRequest_InferRequestedOutputTensor& ModelInferRequest::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::ModelInferRequest_InferRequestedOutputTensor& ModelInferRequest::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.outputs)
  return _internal_outputs(index);
}
inline ::inference::ModelInferRequest_InferRequestedOutputTensor* ModelInferRequest::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::ModelInferRequest_InferRequestedOutputTensor* ModelInferRequest::add_outputs() {
  ::inference::ModelInferRequest_InferRequestedOutputTensor* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferRequest_InferRequestedOutputTensor >&
ModelInferRequest::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.outputs)
  return _impl_.outputs_;
}

// repeated bytes raw_input_contents = 7;
inline int ModelInferRequest::_internal_raw_input_contents_size() const {
  return _impl_.raw_input_contents_.size();
}
inline int ModelInferRequest::raw_input_contents_size() const {
  return _internal_raw_input_contents_size();
}
inline void ModelInferRequest::clear_raw_input_contents() {
  _impl_.raw_input_contents_.Clear();
}
inline std::string* ModelInferRequest::add_raw_input_contents() {
  std::string* _s = _internal_add_raw_input_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelInferRequest.raw_input_contents)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_raw_input_contents(int index) const {
  return _impl_.raw_input_contents_.Get(index);
}
inline const std::string& ModelInferRequest::raw_input_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.raw_input_contents)
  return _internal_raw_input_contents(index);
}
inline std::string* ModelInferRequest::mutable_raw_input_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.raw_input_contents)
  return _impl_.raw_input_contents_.Mutable(index);
}
inline void ModelInferRequest::set_raw_input_contents(int index, const std::string& value) {
  _impl_.raw_input_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::set_raw_input_contents(int index, std::string&& value) {
  _impl_.raw_input_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::set_raw_input_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_input_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::set_raw_input_contents(int index, const void* value, size_t size) {
  _impl_.raw_input_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInferRequest.raw_input_contents)
}
inline std::string* ModelInferRequest::_internal_add_raw_input_contents() {
  return _impl_.raw_input_contents_.Add();
}
inline void ModelInferRequest::add_raw_input_contents(const std::string& value) {
  _impl_.raw_input_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::add_raw_input_contents(std::string&& value) {
  _impl_.raw_input_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::add_raw_input_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_input_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::add_raw_input_contents(const void* value, size_t size) {
  _impl_.raw_input_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelInferRequest.raw_input_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInferRequest::raw_input_contents() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.raw_input_contents)
  return _impl_.raw_input_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInferRequest::mutable_raw_input_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.raw_input_contents)
  return &_impl_.raw_input_contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferResponse_InferOutputTensor

// string name = 1;
inline void ModelInferResponse_InferOutputTensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelInferResponse_InferOutputTensor::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.InferOutputTensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse_InferOutputTensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.InferOutputTensor.name)
}
inline std::string* ModelInferResponse_InferOutputTensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.InferOutputTensor.name)
  return _s;
}
inline const std::string& ModelInferResponse_InferOutputTensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelInferResponse_InferOutputTensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse_InferOutputTensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse_InferOutputTensor::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.InferOutputTensor.name)
  return _impl_.name_.Release();
}
inline void ModelInferResponse_InferOutputTensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.InferOutputTensor.name)
}

// string datatype = 2;
inline void ModelInferResponse_InferOutputTensor::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& ModelInferResponse_InferOutputTensor::datatype() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.InferOutputTensor.datatype)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse_InferOutputTensor::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.InferOutputTensor.datatype)
}
inline std::string* ModelInferResponse_InferOutputTensor::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.InferOutputTensor.datatype)
  return _s;
}
inline const std::string& ModelInferResponse_InferOutputTensor::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void ModelInferResponse_InferOutputTensor::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse_InferOutputTensor::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse_InferOutputTensor::release_datatype() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.InferOutputTensor.datatype)
  return _impl_.datatype_.Release();
}
inline void ModelInferResponse_InferOutputTensor::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.InferOutputTensor.datatype)
}

// repeated int64 shape = 3;
inline int ModelInferResponse_InferOutputTensor::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int ModelInferResponse_InferOutputTensor::shape_size() const {
  return _internal_shape_size();
}
inline void ModelInferResponse_InferOutputTensor::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t ModelInferResponse_InferOutputTensor::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t ModelInferResponse_InferOutputTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.InferOutputTensor.shape)
  return _internal_shape(index);
}
inline void ModelInferResponse_InferOutputTensor::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.InferOutputTensor.shape)
}
inline void ModelInferResponse_InferOutputTensor::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void ModelInferResponse_InferOutputTensor::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.InferOutputTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelInferResponse_InferOutputTensor::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelInferResponse_InferOutputTensor::shape() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferResponse.InferOutputTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelInferResponse_InferOutputTensor::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelInferResponse_InferOutputTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferResponse.InferOutputTensor.shape)
  return _internal_mutable_shape();
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelInferResponse_InferOutputTensor::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferResponse_InferOutputTensor::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferResponse_InferOutputTensor::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferResponse_InferOutputTensor::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferResponse_InferOutputTensor::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferResponse.InferOutputTensor.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferResponse_InferOutputTensor::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferResponse_InferOutputTensor::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferResponse.InferOutputTensor.parameters)
  return _internal_mutable_parameters();
}

// .inference.InferTensorContents contents = 5;
inline bool ModelInferResponse_InferOutputTensor::_internal_has_contents() const {
  return this != internal_default_instance() && _impl_.contents_ != nullptr;
}
inline bool ModelInferResponse_InferOutputTensor::has_contents() const {
  return _internal_has_contents();
}
inline void ModelInferResponse_InferOutputTensor::clear_contents() {
  if (GetArenaForAllocation() == nullptr && _impl_.contents_ != nullptr) {
    delete _impl_.contents_;
  }
  _impl_.contents_ = nullptr;
}
inline const ::inference::InferTensorContents& ModelInferResponse_InferOutputTensor::_internal_contents() const {
  const ::inference::InferTensorContents* p = _impl_.contents_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::InferTensorContents&>(
      ::inference::_InferTensorContents_default_instance_);
}
inline const ::inference::InferTensorContents& ModelInferResponse_InferOutputTensor::contents() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.InferOutputTensor.contents)
  return _internal_contents();
}
inline void ModelInferResponse_InferOutputTensor::unsafe_arena_set_allocated_contents(
    ::inference::InferTensorContents* contents) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contents_);
  }
  _impl_.contents_ = contents;
  if (contents) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelInferResponse.InferOutputTensor.contents)
}
inline ::inference::InferTensorContents* ModelInferResponse_InferOutputTensor::release_contents() {
  
  ::inference::InferTensorContents* temp = _impl_.contents_;
  _impl_.contents_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::InferTensorContents* ModelInferResponse_InferOutputTensor::unsafe_arena_release_contents() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.InferOutputTensor.contents)
  
  ::inference::InferTensorContents* temp = _impl_.contents_;
  _impl_.contents_ = nullptr;
  return temp;
}
inline ::inference::InferTensorContents* ModelInferResponse_InferOutputTensor::_internal_mutable_contents() {
  
  if (_impl_.contents_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::InferTensorContents>(GetArenaForAllocation());
    _impl_.contents_ = p;
  }
  return _impl_.contents_;
}
inline ::inference::InferTensorContents* ModelInferResponse_InferOutputTensor::mutable_contents() {
  ::inference::InferTensorContents* _msg = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.InferOutputTensor.contents)
  return _msg;
}
inline void ModelInferResponse_InferOutputTensor::set_allocated_contents(::inference::InferTensorContents* contents) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contents_;
  }
  if (contents) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contents);
    if (message_arena != submessage_arena) {
      contents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contents, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contents_ = contents;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.InferOutputTensor.contents)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferResponse

// string model_name = 1;
inline void ModelInferResponse::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelInferResponse::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.model_name)
}
inline std::string* ModelInferResponse::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.model_name)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelInferResponse::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelInferResponse::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.model_name)
}

// string model_version = 2;
inline void ModelInferResponse::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& ModelInferResponse::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.model_version)
}
inline std::string* ModelInferResponse::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.model_version)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void ModelInferResponse::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse::release_model_version() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.model_version)
  return _impl_.model_version_.Release();
}
inline void ModelInferResponse::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.model_version)
}

// string id = 3;
inline void ModelInferResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelInferResponse::id() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.id)
}
inline std::string* ModelInferResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.id)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelInferResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse::release_id() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.id)
  return _impl_.id_.Release();
}
inline void ModelInferResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.id)
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelInferResponse::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferResponse::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferResponse::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferResponse::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferResponse::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferResponse.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferResponse::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferResponse::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferResponse.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.ModelInferResponse.InferOutputTensor outputs = 5;
inline int ModelInferResponse::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelInferResponse::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelInferResponse::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::ModelInferResponse_InferOutputTensor* ModelInferResponse::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferResponse_InferOutputTensor >*
ModelInferResponse::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferResponse.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::ModelInferResponse_InferOutputTensor& ModelInferResponse::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::ModelInferResponse_InferOutputTensor& ModelInferResponse::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.outputs)
  return _internal_outputs(index);
}
inline ::inference::ModelInferResponse_InferOutputTensor* ModelInferResponse::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::ModelInferResponse_InferOutputTensor* ModelInferResponse::add_outputs() {
  ::inference::ModelInferResponse_InferOutputTensor* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInferResponse_InferOutputTensor >&
ModelInferResponse::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferResponse.outputs)
  return _impl_.outputs_;
}

// repeated bytes raw_output_contents = 6;
inline int ModelInferResponse::_internal_raw_output_contents_size() const {
  return _impl_.raw_output_contents_.size();
}
inline int ModelInferResponse::raw_output_contents_size() const {
  return _internal_raw_output_contents_size();
}
inline void ModelInferResponse::clear_raw_output_contents() {
  _impl_.raw_output_contents_.Clear();
}
inline std::string* ModelInferResponse::add_raw_output_contents() {
  std::string* _s = _internal_add_raw_output_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelInferResponse.raw_output_contents)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_raw_output_contents(int index) const {
  return _impl_.raw_output_contents_.Get(index);
}
inline const std::string& ModelInferResponse::raw_output_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.raw_output_contents)
  return _internal_raw_output_contents(index);
}
inline std::string* ModelInferResponse::mutable_raw_output_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.raw_output_contents)
  return _impl_.raw_output_contents_.Mutable(index);
}
inline void ModelInferResponse::set_raw_output_contents(int index, const std::string& value) {
  _impl_.raw_output_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::set_raw_output_contents(int index, std::string&& value) {
  _impl_.raw_output_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::set_raw_output_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_output_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::set_raw_output_contents(int index, const void* value, size_t size) {
  _impl_.raw_output_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInferResponse.raw_output_contents)
}
inline std::string* ModelInferResponse::_internal_add_raw_output_contents() {
  return _impl_.raw_output_contents_.Add();
}
inline void ModelInferResponse::add_raw_output_contents(const std::string& value) {
  _impl_.raw_output_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::add_raw_output_contents(std::string&& value) {
  _impl_.raw_output_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::add_raw_output_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_output_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::add_raw_output_contents(const void* value, size_t size) {
  _impl_.raw_output_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelInferResponse.raw_output_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInferResponse::raw_output_contents() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferResponse.raw_output_contents)
  return _impl_.raw_output_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInferResponse::mutable_raw_output_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferResponse.raw_output_contents)
  return &_impl_.raw_output_contents_;
}

// -------------------------------------------------------------------

// ModelStreamInferResponse

// string error_message = 1;
inline void ModelStreamInferResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ModelStreamInferResponse::error_message() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferResponse.error_message)
}
inline std::string* ModelStreamInferResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.error_message)
  return _s;
}
inline const std::string& ModelStreamInferResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ModelStreamInferResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ModelStreamInferResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferResponse.error_message)
}

// .inference.ModelInferResponse infer_response = 2;
inline bool ModelStreamInferResponse::_internal_has_infer_response() const {
  return this != internal_default_instance() && _impl_.infer_response_ != nullptr;
}
inline bool ModelStreamInferResponse::has_infer_response() const {
  return _internal_has_infer_response();
}
inline void ModelStreamInferResponse::clear_infer_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.infer_response_ != nullptr) {
    delete _impl_.infer_response_;
  }
  _impl_.infer_response_ = nullptr;
}
inline const ::inference::ModelInferResponse& ModelStreamInferResponse::_internal_infer_response() const {
  const ::inference::ModelInferResponse* p = _impl_.infer_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelInferResponse&>(
      ::inference::_ModelInferResponse_default_instance_);
}
inline const ::inference::ModelInferResponse& ModelStreamInferResponse::infer_response() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.infer_response)
  return _internal_infer_response();
}
inline void ModelStreamInferResponse::unsafe_arena_set_allocated_infer_response(
    ::inference::ModelInferResponse* infer_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.infer_response_);
  }
  _impl_.infer_response_ = infer_response;
  if (infer_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelStreamInferResponse.infer_response)
}
inline ::inference::ModelInferResponse* ModelStreamInferResponse::release_infer_response() {
  
  ::inference::ModelInferResponse* temp = _impl_.infer_response_;
  _impl_.infer_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelInferResponse* ModelStreamInferResponse::unsafe_arena_release_infer_response() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferResponse.infer_response)
  
  ::inference::ModelInferResponse* temp = _impl_.infer_response_;
  _impl_.infer_response_ = nullptr;
  return temp;
}
inline ::inference::ModelInferResponse* ModelStreamInferResponse::_internal_mutable_infer_response() {
  
  if (_impl_.infer_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelInferResponse>(GetArenaForAllocation());
    _impl_.infer_response_ = p;
  }
  return _impl_.infer_response_;
}
inline ::inference::ModelInferResponse* ModelStreamInferResponse::mutable_infer_response() {
  ::inference::ModelInferResponse* _msg = _internal_mutable_infer_response();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.infer_response)
  return _msg;
}
inline void ModelStreamInferResponse::set_allocated_infer_response(::inference::ModelInferResponse* infer_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.infer_response_;
  }
  if (infer_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(infer_response);
    if (message_arena != submessage_arena) {
      infer_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, infer_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.infer_response_ = infer_response;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferResponse.infer_response)
}

// -------------------------------------------------------------------

// ModelConfigRequest

// string name = 1;
inline void ModelConfigRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelConfigRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfigRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfigRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfigRequest.name)
}
inline std::string* ModelConfigRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfigRequest.name)
  return _s;
}
inline const std::string& ModelConfigRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelConfigRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelConfigRequest.name)
  return _impl_.name_.Release();
}
inline void ModelConfigRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfigRequest.name)
}

// string version = 2;
inline void ModelConfigRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelConfigRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfigRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfigRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfigRequest.version)
}
inline std::string* ModelConfigRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfigRequest.version)
  return _s;
}
inline const std::string& ModelConfigRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelConfigRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelConfigRequest.version)
  return _impl_.version_.Release();
}
inline void ModelConfigRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfigRequest.version)
}

// -------------------------------------------------------------------

// ModelConfigResponse

// .inference.ModelConfig config = 1;
inline bool ModelConfigResponse::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool ModelConfigResponse::has_config() const {
  return _internal_has_config();
}
inline const ::inference::ModelConfig& ModelConfigResponse::_internal_config() const {
  const ::inference::ModelConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelConfig&>(
      ::inference::_ModelConfig_default_instance_);
}
inline const ::inference::ModelConfig& ModelConfigResponse::config() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfigResponse.config)
  return _internal_config();
}
inline void ModelConfigResponse::unsafe_arena_set_allocated_config(
    ::inference::ModelConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfigResponse.config)
}
inline ::inference::ModelConfig* ModelConfigResponse::release_config() {
  
  ::inference::ModelConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelConfig* ModelConfigResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:inference.ModelConfigResponse.config)
  
  ::inference::ModelConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::inference::ModelConfig* ModelConfigResponse::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::inference::ModelConfig* ModelConfigResponse::mutable_config() {
  ::inference::ModelConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfigResponse.config)
  return _msg;
}
inline void ModelConfigResponse::set_allocated_config(::inference::ModelConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfigResponse.config)
}

// -------------------------------------------------------------------

// ModelStatisticsRequest

// string name = 1;
inline void ModelStatisticsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelStatisticsRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatisticsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatisticsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatisticsRequest.name)
}
inline std::string* ModelStatisticsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatisticsRequest.name)
  return _s;
}
inline const std::string& ModelStatisticsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelStatisticsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelStatisticsRequest.name)
  return _impl_.name_.Release();
}
inline void ModelStatisticsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatisticsRequest.name)
}

// string version = 2;
inline void ModelStatisticsRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelStatisticsRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatisticsRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatisticsRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatisticsRequest.version)
}
inline std::string* ModelStatisticsRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatisticsRequest.version)
  return _s;
}
inline const std::string& ModelStatisticsRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelStatisticsRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelStatisticsRequest.version)
  return _impl_.version_.Release();
}
inline void ModelStatisticsRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatisticsRequest.version)
}

// -------------------------------------------------------------------

// StatisticDuration

// uint64 count = 1;
inline void StatisticDuration::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t StatisticDuration::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t StatisticDuration::count() const {
  // @@protoc_insertion_point(field_get:inference.StatisticDuration.count)
  return _internal_count();
}
inline void StatisticDuration::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void StatisticDuration::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:inference.StatisticDuration.count)
}

// uint64 ns = 2;
inline void StatisticDuration::clear_ns() {
  _impl_.ns_ = uint64_t{0u};
}
inline uint64_t StatisticDuration::_internal_ns() const {
  return _impl_.ns_;
}
inline uint64_t StatisticDuration::ns() const {
  // @@protoc_insertion_point(field_get:inference.StatisticDuration.ns)
  return _internal_ns();
}
inline void StatisticDuration::_internal_set_ns(uint64_t value) {
  
  _impl_.ns_ = value;
}
inline void StatisticDuration::set_ns(uint64_t value) {
  _internal_set_ns(value);
  // @@protoc_insertion_point(field_set:inference.StatisticDuration.ns)
}

// -------------------------------------------------------------------

// InferStatistics

// .inference.StatisticDuration success = 1;
inline bool InferStatistics::_internal_has_success() const {
  return this != internal_default_instance() && _impl_.success_ != nullptr;
}
inline bool InferStatistics::has_success() const {
  return _internal_has_success();
}
inline void InferStatistics::clear_success() {
  if (GetArenaForAllocation() == nullptr && _impl_.success_ != nullptr) {
    delete _impl_.success_;
  }
  _impl_.success_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_success() const {
  const ::inference::StatisticDuration* p = _impl_.success_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::success() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.success)
  return _internal_success();
}
inline void InferStatistics::unsafe_arena_set_allocated_success(
    ::inference::StatisticDuration* success) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.success_);
  }
  _impl_.success_ = success;
  if (success) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.success)
}
inline ::inference::StatisticDuration* InferStatistics::release_success() {
  
  ::inference::StatisticDuration* temp = _impl_.success_;
  _impl_.success_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_success() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.success)
  
  ::inference::StatisticDuration* temp = _impl_.success_;
  _impl_.success_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_success() {
  
  if (_impl_.success_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.success_ = p;
  }
  return _impl_.success_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_success() {
  ::inference::StatisticDuration* _msg = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.success)
  return _msg;
}
inline void InferStatistics::set_allocated_success(::inference::StatisticDuration* success) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.success_;
  }
  if (success) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(success);
    if (message_arena != submessage_arena) {
      success = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, success, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.success_ = success;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.success)
}

// .inference.StatisticDuration fail = 2;
inline bool InferStatistics::_internal_has_fail() const {
  return this != internal_default_instance() && _impl_.fail_ != nullptr;
}
inline bool InferStatistics::has_fail() const {
  return _internal_has_fail();
}
inline void InferStatistics::clear_fail() {
  if (GetArenaForAllocation() == nullptr && _impl_.fail_ != nullptr) {
    delete _impl_.fail_;
  }
  _impl_.fail_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_fail() const {
  const ::inference::StatisticDuration* p = _impl_.fail_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::fail() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.fail)
  return _internal_fail();
}
inline void InferStatistics::unsafe_arena_set_allocated_fail(
    ::inference::StatisticDuration* fail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fail_);
  }
  _impl_.fail_ = fail;
  if (fail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.fail)
}
inline ::inference::StatisticDuration* InferStatistics::release_fail() {
  
  ::inference::StatisticDuration* temp = _impl_.fail_;
  _impl_.fail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_fail() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.fail)
  
  ::inference::StatisticDuration* temp = _impl_.fail_;
  _impl_.fail_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_fail() {
  
  if (_impl_.fail_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.fail_ = p;
  }
  return _impl_.fail_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_fail() {
  ::inference::StatisticDuration* _msg = _internal_mutable_fail();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.fail)
  return _msg;
}
inline void InferStatistics::set_allocated_fail(::inference::StatisticDuration* fail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fail_;
  }
  if (fail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fail);
    if (message_arena != submessage_arena) {
      fail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fail, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fail_ = fail;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.fail)
}

// .inference.StatisticDuration queue = 3;
inline bool InferStatistics::_internal_has_queue() const {
  return this != internal_default_instance() && _impl_.queue_ != nullptr;
}
inline bool InferStatistics::has_queue() const {
  return _internal_has_queue();
}
inline void InferStatistics::clear_queue() {
  if (GetArenaForAllocation() == nullptr && _impl_.queue_ != nullptr) {
    delete _impl_.queue_;
  }
  _impl_.queue_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_queue() const {
  const ::inference::StatisticDuration* p = _impl_.queue_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::queue() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.queue)
  return _internal_queue();
}
inline void InferStatistics::unsafe_arena_set_allocated_queue(
    ::inference::StatisticDuration* queue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.queue_);
  }
  _impl_.queue_ = queue;
  if (queue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.queue)
}
inline ::inference::StatisticDuration* InferStatistics::release_queue() {
  
  ::inference::StatisticDuration* temp = _impl_.queue_;
  _impl_.queue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_queue() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.queue)
  
  ::inference::StatisticDuration* temp = _impl_.queue_;
  _impl_.queue_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_queue() {
  
  if (_impl_.queue_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.queue_ = p;
  }
  return _impl_.queue_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_queue() {
  ::inference::StatisticDuration* _msg = _internal_mutable_queue();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.queue)
  return _msg;
}
inline void InferStatistics::set_allocated_queue(::inference::StatisticDuration* queue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.queue_;
  }
  if (queue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(queue);
    if (message_arena != submessage_arena) {
      queue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, queue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.queue_ = queue;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.queue)
}

// .inference.StatisticDuration compute_input = 4;
inline bool InferStatistics::_internal_has_compute_input() const {
  return this != internal_default_instance() && _impl_.compute_input_ != nullptr;
}
inline bool InferStatistics::has_compute_input() const {
  return _internal_has_compute_input();
}
inline void InferStatistics::clear_compute_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.compute_input_ != nullptr) {
    delete _impl_.compute_input_;
  }
  _impl_.compute_input_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_compute_input() const {
  const ::inference::StatisticDuration* p = _impl_.compute_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::compute_input() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.compute_input)
  return _internal_compute_input();
}
inline void InferStatistics::unsafe_arena_set_allocated_compute_input(
    ::inference::StatisticDuration* compute_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_input_);
  }
  _impl_.compute_input_ = compute_input;
  if (compute_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.compute_input)
}
inline ::inference::StatisticDuration* InferStatistics::release_compute_input() {
  
  ::inference::StatisticDuration* temp = _impl_.compute_input_;
  _impl_.compute_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_compute_input() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.compute_input)
  
  ::inference::StatisticDuration* temp = _impl_.compute_input_;
  _impl_.compute_input_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_compute_input() {
  
  if (_impl_.compute_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.compute_input_ = p;
  }
  return _impl_.compute_input_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_compute_input() {
  ::inference::StatisticDuration* _msg = _internal_mutable_compute_input();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.compute_input)
  return _msg;
}
inline void InferStatistics::set_allocated_compute_input(::inference::StatisticDuration* compute_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_input_;
  }
  if (compute_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_input);
    if (message_arena != submessage_arena) {
      compute_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compute_input_ = compute_input;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.compute_input)
}

// .inference.StatisticDuration compute_infer = 5;
inline bool InferStatistics::_internal_has_compute_infer() const {
  return this != internal_default_instance() && _impl_.compute_infer_ != nullptr;
}
inline bool InferStatistics::has_compute_infer() const {
  return _internal_has_compute_infer();
}
inline void InferStatistics::clear_compute_infer() {
  if (GetArenaForAllocation() == nullptr && _impl_.compute_infer_ != nullptr) {
    delete _impl_.compute_infer_;
  }
  _impl_.compute_infer_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_compute_infer() const {
  const ::inference::StatisticDuration* p = _impl_.compute_infer_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::compute_infer() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.compute_infer)
  return _internal_compute_infer();
}
inline void InferStatistics::unsafe_arena_set_allocated_compute_infer(
    ::inference::StatisticDuration* compute_infer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_infer_);
  }
  _impl_.compute_infer_ = compute_infer;
  if (compute_infer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.compute_infer)
}
inline ::inference::StatisticDuration* InferStatistics::release_compute_infer() {
  
  ::inference::StatisticDuration* temp = _impl_.compute_infer_;
  _impl_.compute_infer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_compute_infer() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.compute_infer)
  
  ::inference::StatisticDuration* temp = _impl_.compute_infer_;
  _impl_.compute_infer_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_compute_infer() {
  
  if (_impl_.compute_infer_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.compute_infer_ = p;
  }
  return _impl_.compute_infer_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_compute_infer() {
  ::inference::StatisticDuration* _msg = _internal_mutable_compute_infer();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.compute_infer)
  return _msg;
}
inline void InferStatistics::set_allocated_compute_infer(::inference::StatisticDuration* compute_infer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_infer_;
  }
  if (compute_infer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_infer);
    if (message_arena != submessage_arena) {
      compute_infer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_infer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compute_infer_ = compute_infer;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.compute_infer)
}

// .inference.StatisticDuration compute_output = 6;
inline bool InferStatistics::_internal_has_compute_output() const {
  return this != internal_default_instance() && _impl_.compute_output_ != nullptr;
}
inline bool InferStatistics::has_compute_output() const {
  return _internal_has_compute_output();
}
inline void InferStatistics::clear_compute_output() {
  if (GetArenaForAllocation() == nullptr && _impl_.compute_output_ != nullptr) {
    delete _impl_.compute_output_;
  }
  _impl_.compute_output_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_compute_output() const {
  const ::inference::StatisticDuration* p = _impl_.compute_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::compute_output() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.compute_output)
  return _internal_compute_output();
}
inline void InferStatistics::unsafe_arena_set_allocated_compute_output(
    ::inference::StatisticDuration* compute_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_output_);
  }
  _impl_.compute_output_ = compute_output;
  if (compute_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.compute_output)
}
inline ::inference::StatisticDuration* InferStatistics::release_compute_output() {
  
  ::inference::StatisticDuration* temp = _impl_.compute_output_;
  _impl_.compute_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_compute_output() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.compute_output)
  
  ::inference::StatisticDuration* temp = _impl_.compute_output_;
  _impl_.compute_output_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_compute_output() {
  
  if (_impl_.compute_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.compute_output_ = p;
  }
  return _impl_.compute_output_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_compute_output() {
  ::inference::StatisticDuration* _msg = _internal_mutable_compute_output();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.compute_output)
  return _msg;
}
inline void InferStatistics::set_allocated_compute_output(::inference::StatisticDuration* compute_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_output_;
  }
  if (compute_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_output);
    if (message_arena != submessage_arena) {
      compute_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compute_output_ = compute_output;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.compute_output)
}

// .inference.StatisticDuration cache_hit = 7;
inline bool InferStatistics::_internal_has_cache_hit() const {
  return this != internal_default_instance() && _impl_.cache_hit_ != nullptr;
}
inline bool InferStatistics::has_cache_hit() const {
  return _internal_has_cache_hit();
}
inline void InferStatistics::clear_cache_hit() {
  if (GetArenaForAllocation() == nullptr && _impl_.cache_hit_ != nullptr) {
    delete _impl_.cache_hit_;
  }
  _impl_.cache_hit_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_cache_hit() const {
  const ::inference::StatisticDuration* p = _impl_.cache_hit_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::cache_hit() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.cache_hit)
  return _internal_cache_hit();
}
inline void InferStatistics::unsafe_arena_set_allocated_cache_hit(
    ::inference::StatisticDuration* cache_hit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cache_hit_);
  }
  _impl_.cache_hit_ = cache_hit;
  if (cache_hit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.cache_hit)
}
inline ::inference::StatisticDuration* InferStatistics::release_cache_hit() {
  
  ::inference::StatisticDuration* temp = _impl_.cache_hit_;
  _impl_.cache_hit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_cache_hit() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.cache_hit)
  
  ::inference::StatisticDuration* temp = _impl_.cache_hit_;
  _impl_.cache_hit_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_cache_hit() {
  
  if (_impl_.cache_hit_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.cache_hit_ = p;
  }
  return _impl_.cache_hit_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_cache_hit() {
  ::inference::StatisticDuration* _msg = _internal_mutable_cache_hit();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.cache_hit)
  return _msg;
}
inline void InferStatistics::set_allocated_cache_hit(::inference::StatisticDuration* cache_hit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cache_hit_;
  }
  if (cache_hit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache_hit);
    if (message_arena != submessage_arena) {
      cache_hit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache_hit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cache_hit_ = cache_hit;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.cache_hit)
}

// .inference.StatisticDuration cache_miss = 8;
inline bool InferStatistics::_internal_has_cache_miss() const {
  return this != internal_default_instance() && _impl_.cache_miss_ != nullptr;
}
inline bool InferStatistics::has_cache_miss() const {
  return _internal_has_cache_miss();
}
inline void InferStatistics::clear_cache_miss() {
  if (GetArenaForAllocation() == nullptr && _impl_.cache_miss_ != nullptr) {
    delete _impl_.cache_miss_;
  }
  _impl_.cache_miss_ = nullptr;
}
inline const ::inference::StatisticDuration& InferStatistics::_internal_cache_miss() const {
  const ::inference::StatisticDuration* p = _impl_.cache_miss_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferStatistics::cache_miss() const {
  // @@protoc_insertion_point(field_get:inference.InferStatistics.cache_miss)
  return _internal_cache_miss();
}
inline void InferStatistics::unsafe_arena_set_allocated_cache_miss(
    ::inference::StatisticDuration* cache_miss) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cache_miss_);
  }
  _impl_.cache_miss_ = cache_miss;
  if (cache_miss) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferStatistics.cache_miss)
}
inline ::inference::StatisticDuration* InferStatistics::release_cache_miss() {
  
  ::inference::StatisticDuration* temp = _impl_.cache_miss_;
  _impl_.cache_miss_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::unsafe_arena_release_cache_miss() {
  // @@protoc_insertion_point(field_release:inference.InferStatistics.cache_miss)
  
  ::inference::StatisticDuration* temp = _impl_.cache_miss_;
  _impl_.cache_miss_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferStatistics::_internal_mutable_cache_miss() {
  
  if (_impl_.cache_miss_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.cache_miss_ = p;
  }
  return _impl_.cache_miss_;
}
inline ::inference::StatisticDuration* InferStatistics::mutable_cache_miss() {
  ::inference::StatisticDuration* _msg = _internal_mutable_cache_miss();
  // @@protoc_insertion_point(field_mutable:inference.InferStatistics.cache_miss)
  return _msg;
}
inline void InferStatistics::set_allocated_cache_miss(::inference::StatisticDuration* cache_miss) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cache_miss_;
  }
  if (cache_miss) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache_miss);
    if (message_arena != submessage_arena) {
      cache_miss = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache_miss, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cache_miss_ = cache_miss;
  // @@protoc_insertion_point(field_set_allocated:inference.InferStatistics.cache_miss)
}

// -------------------------------------------------------------------

// InferBatchStatistics

// uint64 batch_size = 1;
inline void InferBatchStatistics::clear_batch_size() {
  _impl_.batch_size_ = uint64_t{0u};
}
inline uint64_t InferBatchStatistics::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline uint64_t InferBatchStatistics::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.InferBatchStatistics.batch_size)
  return _internal_batch_size();
}
inline void InferBatchStatistics::_internal_set_batch_size(uint64_t value) {
  
  _impl_.batch_size_ = value;
}
inline void InferBatchStatistics::set_batch_size(uint64_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.InferBatchStatistics.batch_size)
}

// .inference.StatisticDuration compute_input = 2;
inline bool InferBatchStatistics::_internal_has_compute_input() const {
  return this != internal_default_instance() && _impl_.compute_input_ != nullptr;
}
inline bool InferBatchStatistics::has_compute_input() const {
  return _internal_has_compute_input();
}
inline void InferBatchStatistics::clear_compute_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.compute_input_ != nullptr) {
    delete _impl_.compute_input_;
  }
  _impl_.compute_input_ = nullptr;
}
inline const ::inference::StatisticDuration& InferBatchStatistics::_internal_compute_input() const {
  const ::inference::StatisticDuration* p = _impl_.compute_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferBatchStatistics::compute_input() const {
  // @@protoc_insertion_point(field_get:inference.InferBatchStatistics.compute_input)
  return _internal_compute_input();
}
inline void InferBatchStatistics::unsafe_arena_set_allocated_compute_input(
    ::inference::StatisticDuration* compute_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_input_);
  }
  _impl_.compute_input_ = compute_input;
  if (compute_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferBatchStatistics.compute_input)
}
inline ::inference::StatisticDuration* InferBatchStatistics::release_compute_input() {
  
  ::inference::StatisticDuration* temp = _impl_.compute_input_;
  _impl_.compute_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferBatchStatistics::unsafe_arena_release_compute_input() {
  // @@protoc_insertion_point(field_release:inference.InferBatchStatistics.compute_input)
  
  ::inference::StatisticDuration* temp = _impl_.compute_input_;
  _impl_.compute_input_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferBatchStatistics::_internal_mutable_compute_input() {
  
  if (_impl_.compute_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.compute_input_ = p;
  }
  return _impl_.compute_input_;
}
inline ::inference::StatisticDuration* InferBatchStatistics::mutable_compute_input() {
  ::inference::StatisticDuration* _msg = _internal_mutable_compute_input();
  // @@protoc_insertion_point(field_mutable:inference.InferBatchStatistics.compute_input)
  return _msg;
}
inline void InferBatchStatistics::set_allocated_compute_input(::inference::StatisticDuration* compute_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_input_;
  }
  if (compute_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_input);
    if (message_arena != submessage_arena) {
      compute_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compute_input_ = compute_input;
  // @@protoc_insertion_point(field_set_allocated:inference.InferBatchStatistics.compute_input)
}

// .inference.StatisticDuration compute_infer = 3;
inline bool InferBatchStatistics::_internal_has_compute_infer() const {
  return this != internal_default_instance() && _impl_.compute_infer_ != nullptr;
}
inline bool InferBatchStatistics::has_compute_infer() const {
  return _internal_has_compute_infer();
}
inline void InferBatchStatistics::clear_compute_infer() {
  if (GetArenaForAllocation() == nullptr && _impl_.compute_infer_ != nullptr) {
    delete _impl_.compute_infer_;
  }
  _impl_.compute_infer_ = nullptr;
}
inline const ::inference::StatisticDuration& InferBatchStatistics::_internal_compute_infer() const {
  const ::inference::StatisticDuration* p = _impl_.compute_infer_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferBatchStatistics::compute_infer() const {
  // @@protoc_insertion_point(field_get:inference.InferBatchStatistics.compute_infer)
  return _internal_compute_infer();
}
inline void InferBatchStatistics::unsafe_arena_set_allocated_compute_infer(
    ::inference::StatisticDuration* compute_infer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_infer_);
  }
  _impl_.compute_infer_ = compute_infer;
  if (compute_infer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferBatchStatistics.compute_infer)
}
inline ::inference::StatisticDuration* InferBatchStatistics::release_compute_infer() {
  
  ::inference::StatisticDuration* temp = _impl_.compute_infer_;
  _impl_.compute_infer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferBatchStatistics::unsafe_arena_release_compute_infer() {
  // @@protoc_insertion_point(field_release:inference.InferBatchStatistics.compute_infer)
  
  ::inference::StatisticDuration* temp = _impl_.compute_infer_;
  _impl_.compute_infer_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferBatchStatistics::_internal_mutable_compute_infer() {
  
  if (_impl_.compute_infer_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.compute_infer_ = p;
  }
  return _impl_.compute_infer_;
}
inline ::inference::StatisticDuration* InferBatchStatistics::mutable_compute_infer() {
  ::inference::StatisticDuration* _msg = _internal_mutable_compute_infer();
  // @@protoc_insertion_point(field_mutable:inference.InferBatchStatistics.compute_infer)
  return _msg;
}
inline void InferBatchStatistics::set_allocated_compute_infer(::inference::StatisticDuration* compute_infer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_infer_;
  }
  if (compute_infer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_infer);
    if (message_arena != submessage_arena) {
      compute_infer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_infer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compute_infer_ = compute_infer;
  // @@protoc_insertion_point(field_set_allocated:inference.InferBatchStatistics.compute_infer)
}

// .inference.StatisticDuration compute_output = 4;
inline bool InferBatchStatistics::_internal_has_compute_output() const {
  return this != internal_default_instance() && _impl_.compute_output_ != nullptr;
}
inline bool InferBatchStatistics::has_compute_output() const {
  return _internal_has_compute_output();
}
inline void InferBatchStatistics::clear_compute_output() {
  if (GetArenaForAllocation() == nullptr && _impl_.compute_output_ != nullptr) {
    delete _impl_.compute_output_;
  }
  _impl_.compute_output_ = nullptr;
}
inline const ::inference::StatisticDuration& InferBatchStatistics::_internal_compute_output() const {
  const ::inference::StatisticDuration* p = _impl_.compute_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::StatisticDuration&>(
      ::inference::_StatisticDuration_default_instance_);
}
inline const ::inference::StatisticDuration& InferBatchStatistics::compute_output() const {
  // @@protoc_insertion_point(field_get:inference.InferBatchStatistics.compute_output)
  return _internal_compute_output();
}
inline void InferBatchStatistics::unsafe_arena_set_allocated_compute_output(
    ::inference::StatisticDuration* compute_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_output_);
  }
  _impl_.compute_output_ = compute_output;
  if (compute_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.InferBatchStatistics.compute_output)
}
inline ::inference::StatisticDuration* InferBatchStatistics::release_compute_output() {
  
  ::inference::StatisticDuration* temp = _impl_.compute_output_;
  _impl_.compute_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::StatisticDuration* InferBatchStatistics::unsafe_arena_release_compute_output() {
  // @@protoc_insertion_point(field_release:inference.InferBatchStatistics.compute_output)
  
  ::inference::StatisticDuration* temp = _impl_.compute_output_;
  _impl_.compute_output_ = nullptr;
  return temp;
}
inline ::inference::StatisticDuration* InferBatchStatistics::_internal_mutable_compute_output() {
  
  if (_impl_.compute_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::StatisticDuration>(GetArenaForAllocation());
    _impl_.compute_output_ = p;
  }
  return _impl_.compute_output_;
}
inline ::inference::StatisticDuration* InferBatchStatistics::mutable_compute_output() {
  ::inference::StatisticDuration* _msg = _internal_mutable_compute_output();
  // @@protoc_insertion_point(field_mutable:inference.InferBatchStatistics.compute_output)
  return _msg;
}
inline void InferBatchStatistics::set_allocated_compute_output(::inference::StatisticDuration* compute_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_output_;
  }
  if (compute_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_output);
    if (message_arena != submessage_arena) {
      compute_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compute_output_ = compute_output;
  // @@protoc_insertion_point(field_set_allocated:inference.InferBatchStatistics.compute_output)
}

// -------------------------------------------------------------------

// MemoryUsage

// string type = 1;
inline void MemoryUsage::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& MemoryUsage::type() const {
  // @@protoc_insertion_point(field_get:inference.MemoryUsage.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MemoryUsage::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.MemoryUsage.type)
}
inline std::string* MemoryUsage::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:inference.MemoryUsage.type)
  return _s;
}
inline const std::string& MemoryUsage::_internal_type() const {
  return _impl_.type_.Get();
}
inline void MemoryUsage::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* MemoryUsage::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* MemoryUsage::release_type() {
  // @@protoc_insertion_point(field_release:inference.MemoryUsage.type)
  return _impl_.type_.Release();
}
inline void MemoryUsage::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.MemoryUsage.type)
}

// int64 id = 2;
inline void MemoryUsage::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t MemoryUsage::_internal_id() const {
  return _impl_.id_;
}
inline int64_t MemoryUsage::id() const {
  // @@protoc_insertion_point(field_get:inference.MemoryUsage.id)
  return _internal_id();
}
inline void MemoryUsage::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void MemoryUsage::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:inference.MemoryUsage.id)
}

// uint64 byte_size = 3;
inline void MemoryUsage::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t MemoryUsage::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t MemoryUsage::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.MemoryUsage.byte_size)
  return _internal_byte_size();
}
inline void MemoryUsage::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void MemoryUsage::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.MemoryUsage.byte_size)
}

// -------------------------------------------------------------------

// ModelStatistics

// string name = 1;
inline void ModelStatistics::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelStatistics::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatistics::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.name)
}
inline std::string* ModelStatistics::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.name)
  return _s;
}
inline const std::string& ModelStatistics::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelStatistics::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatistics::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatistics::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelStatistics.name)
  return _impl_.name_.Release();
}
inline void ModelStatistics::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatistics.name)
}

// string version = 2;
inline void ModelStatistics::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelStatistics::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatistics::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.version)
}
inline std::string* ModelStatistics::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.version)
  return _s;
}
inline const std::string& ModelStatistics::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelStatistics::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatistics::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatistics::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelStatistics.version)
  return _impl_.version_.Release();
}
inline void ModelStatistics::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatistics.version)
}

// uint64 last_inference = 3;
inline void ModelStatistics::clear_last_inference() {
  _impl_.last_inference_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_last_inference() const {
  return _impl_.last_inference_;
}
inline uint64_t ModelStatistics::last_inference() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.last_inference)
  return _internal_last_inference();
}
inline void ModelStatistics::_internal_set_last_inference(uint64_t value) {
  
  _impl_.last_inference_ = value;
}
inline void ModelStatistics::set_last_inference(uint64_t value) {
  _internal_set_last_inference(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.last_inference)
}

// uint64 inference_count = 4;
inline void ModelStatistics::clear_inference_count() {
  _impl_.inference_count_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_inference_count() const {
  return _impl_.inference_count_;
}
inline uint64_t ModelStatistics::inference_count() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.inference_count)
  return _internal_inference_count();
}
inline void ModelStatistics::_internal_set_inference_count(uint64_t value) {
  
  _impl_.inference_count_ = value;
}
inline void ModelStatistics::set_inference_count(uint64_t value) {
  _internal_set_inference_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.inference_count)
}

// uint64 execution_count = 5;
inline void ModelStatistics::clear_execution_count() {
  _impl_.execution_count_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_execution_count() const {
  return _impl_.execution_count_;
}
inline uint64_t ModelStatistics::execution_count() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.execution_count)
  return _internal_execution_count();
}
inline void ModelStatistics::_internal_set_execution_count(uint64_t value) {
  
  _impl_.execution_count_ = value;
}
inline void ModelStatistics::set_execution_count(uint64_t value) {
  _internal_set_execution_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.execution_count)
}

// .inference.InferStatistics inference_stats = 6;
inline bool ModelStatistics::_internal_has_inference_stats() const {
  return this != internal_default_instance() && _impl_.inference_stats_ != nullptr;
}
inline bool ModelStatistics::has_inference_stats() const {
  return _internal_has_inference_stats();
}
inline void ModelStatistics::clear_inference_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.inference_stats_ != nullptr) {
    delete _impl_.inference_stats_;
  }
  _impl_.inference_stats_ = nullptr;
}
inline const ::inference::InferStatistics& ModelStatistics::_internal_inference_stats() const {
  const ::inference::InferStatistics* p = _impl_.inference_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::InferStatistics&>(
      ::inference::_InferStatistics_default_instance_);
}
inline const ::inference::InferStatistics& ModelStatistics::inference_stats() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.inference_stats)
  return _internal_inference_stats();
}
inline void ModelStatistics::unsafe_arena_set_allocated_inference_stats(
    ::inference::InferStatistics* inference_stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inference_stats_);
  }
  _impl_.inference_stats_ = inference_stats;
  if (inference_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelStatistics.inference_stats)
}
inline ::inference::InferStatistics* ModelStatistics::release_inference_stats() {
  
  ::inference::InferStatistics* temp = _impl_.inference_stats_;
  _impl_.inference_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::InferStatistics* ModelStatistics::unsafe_arena_release_inference_stats() {
  // @@protoc_insertion_point(field_release:inference.ModelStatistics.inference_stats)
  
  ::inference::InferStatistics* temp = _impl_.inference_stats_;
  _impl_.inference_stats_ = nullptr;
  return temp;
}
inline ::inference::InferStatistics* ModelStatistics::_internal_mutable_inference_stats() {
  
  if (_impl_.inference_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::InferStatistics>(GetArenaForAllocation());
    _impl_.inference_stats_ = p;
  }
  return _impl_.inference_stats_;
}
inline ::inference::InferStatistics* ModelStatistics::mutable_inference_stats() {
  ::inference::InferStatistics* _msg = _internal_mutable_inference_stats();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.inference_stats)
  return _msg;
}
inline void ModelStatistics::set_allocated_inference_stats(::inference::InferStatistics* inference_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inference_stats_;
  }
  if (inference_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inference_stats);
    if (message_arena != submessage_arena) {
      inference_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inference_stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inference_stats_ = inference_stats;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatistics.inference_stats)
}

// repeated .inference.InferBatchStatistics batch_stats = 7;
inline int ModelStatistics::_internal_batch_stats_size() const {
  return _impl_.batch_stats_.size();
}
inline int ModelStatistics::batch_stats_size() const {
  return _internal_batch_stats_size();
}
inline void ModelStatistics::clear_batch_stats() {
  _impl_.batch_stats_.Clear();
}
inline ::inference::InferBatchStatistics* ModelStatistics::mutable_batch_stats(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.batch_stats)
  return _impl_.batch_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferBatchStatistics >*
ModelStatistics::mutable_batch_stats() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStatistics.batch_stats)
  return &_impl_.batch_stats_;
}
inline const ::inference::InferBatchStatistics& ModelStatistics::_internal_batch_stats(int index) const {
  return _impl_.batch_stats_.Get(index);
}
inline const ::inference::InferBatchStatistics& ModelStatistics::batch_stats(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.batch_stats)
  return _internal_batch_stats(index);
}
inline ::inference::InferBatchStatistics* ModelStatistics::_internal_add_batch_stats() {
  return _impl_.batch_stats_.Add();
}
inline ::inference::InferBatchStatistics* ModelStatistics::add_batch_stats() {
  ::inference::InferBatchStatistics* _add = _internal_add_batch_stats();
  // @@protoc_insertion_point(field_add:inference.ModelStatistics.batch_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferBatchStatistics >&
ModelStatistics::batch_stats() const {
  // @@protoc_insertion_point(field_list:inference.ModelStatistics.batch_stats)
  return _impl_.batch_stats_;
}

// repeated .inference.MemoryUsage memory_usage = 8;
inline int ModelStatistics::_internal_memory_usage_size() const {
  return _impl_.memory_usage_.size();
}
inline int ModelStatistics::memory_usage_size() const {
  return _internal_memory_usage_size();
}
inline void ModelStatistics::clear_memory_usage() {
  _impl_.memory_usage_.Clear();
}
inline ::inference::MemoryUsage* ModelStatistics::mutable_memory_usage(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.memory_usage)
  return _impl_.memory_usage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::MemoryUsage >*
ModelStatistics::mutable_memory_usage() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStatistics.memory_usage)
  return &_impl_.memory_usage_;
}
inline const ::inference::MemoryUsage& ModelStatistics::_internal_memory_usage(int index) const {
  return _impl_.memory_usage_.Get(index);
}
inline const ::inference::MemoryUsage& ModelStatistics::memory_usage(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.memory_usage)
  return _internal_memory_usage(index);
}
inline ::inference::MemoryUsage* ModelStatistics::_internal_add_memory_usage() {
  return _impl_.memory_usage_.Add();
}
inline ::inference::MemoryUsage* ModelStatistics::add_memory_usage() {
  ::inference::MemoryUsage* _add = _internal_add_memory_usage();
  // @@protoc_insertion_point(field_add:inference.ModelStatistics.memory_usage)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::MemoryUsage >&
ModelStatistics::memory_usage() const {
  // @@protoc_insertion_point(field_list:inference.ModelStatistics.memory_usage)
  return _impl_.memory_usage_;
}

// -------------------------------------------------------------------

// ModelStatisticsResponse

// repeated .inference.ModelStatistics model_stats = 1;
inline int ModelStatisticsResponse::_internal_model_stats_size() const {
  return _impl_.model_stats_.size();
}
inline int ModelStatisticsResponse::model_stats_size() const {
  return _internal_model_stats_size();
}
inline void ModelStatisticsResponse::clear_model_stats() {
  _impl_.model_stats_.Clear();
}
inline ::inference::ModelStatistics* ModelStatisticsResponse::mutable_model_stats(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStatisticsResponse.model_stats)
  return _impl_.model_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >*
ModelStatisticsResponse::mutable_model_stats() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStatisticsResponse.model_stats)
  return &_impl_.model_stats_;
}
inline const ::inference::ModelStatistics& ModelStatisticsResponse::_internal_model_stats(int index) const {
  return _impl_.model_stats_.Get(index);
}
inline const ::inference::ModelStatistics& ModelStatisticsResponse::model_stats(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStatisticsResponse.model_stats)
  return _internal_model_stats(index);
}
inline ::inference::ModelStatistics* ModelStatisticsResponse::_internal_add_model_stats() {
  return _impl_.model_stats_.Add();
}
inline ::inference::ModelStatistics* ModelStatisticsResponse::add_model_stats() {
  ::inference::ModelStatistics* _add = _internal_add_model_stats();
  // @@protoc_insertion_point(field_add:inference.ModelStatisticsResponse.model_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >&
ModelStatisticsResponse::model_stats() const {
  // @@protoc_insertion_point(field_list:inference.ModelStatisticsResponse.model_stats)
  return _impl_.model_stats_;
}

// -------------------------------------------------------------------

// ModelRepositoryParameter

// bool bool_param = 1;
inline bool ModelRepositoryParameter::_internal_has_bool_param() const {
  return parameter_choice_case() == kBoolParam;
}
inline bool ModelRepositoryParameter::has_bool_param() const {
  return _internal_has_bool_param();
}
inline void ModelRepositoryParameter::set_has_bool_param() {
  _impl_._oneof_case_[0] = kBoolParam;
}
inline void ModelRepositoryParameter::clear_bool_param() {
  if (_internal_has_bool_param()) {
    _impl_.parameter_choice_.bool_param_ = false;
    clear_has_parameter_choice();
  }
}
inline bool ModelRepositoryParameter::_internal_bool_param() const {
  if (_internal_has_bool_param()) {
    return _impl_.parameter_choice_.bool_param_;
  }
  return false;
}
inline void ModelRepositoryParameter::_internal_set_bool_param(bool value) {
  if (!_internal_has_bool_param()) {
    clear_parameter_choice();
    set_has_bool_param();
  }
  _impl_.parameter_choice_.bool_param_ = value;
}
inline bool ModelRepositoryParameter::bool_param() const {
  // @@protoc_insertion_point(field_get:inference.ModelRepositoryParameter.bool_param)
  return _internal_bool_param();
}
inline void ModelRepositoryParameter::set_bool_param(bool value) {
  _internal_set_bool_param(value);
  // @@protoc_insertion_point(field_set:inference.ModelRepositoryParameter.bool_param)
}

// int64 int64_param = 2;
inline bool ModelRepositoryParameter::_internal_has_int64_param() const {
  return parameter_choice_case() == kInt64Param;
}
inline bool ModelRepositoryParameter::has_int64_param() const {
  return _internal_has_int64_param();
}
inline void ModelRepositoryParameter::set_has_int64_param() {
  _impl_._oneof_case_[0] = kInt64Param;
}
inline void ModelRepositoryParameter::clear_int64_param() {
  if (_internal_has_int64_param()) {
    _impl_.parameter_choice_.int64_param_ = int64_t{0};
    clear_has_parameter_choice();
  }
}
inline int64_t ModelRepositoryParameter::_internal_int64_param() const {
  if (_internal_has_int64_param()) {
    return _impl_.parameter_choice_.int64_param_;
  }
  return int64_t{0};
}
inline void ModelRepositoryParameter::_internal_set_int64_param(int64_t value) {
  if (!_internal_has_int64_param()) {
    clear_parameter_choice();
    set_has_int64_param();
  }
  _impl_.parameter_choice_.int64_param_ = value;
}
inline int64_t ModelRepositoryParameter::int64_param() const {
  // @@protoc_insertion_point(field_get:inference.ModelRepositoryParameter.int64_param)
  return _internal_int64_param();
}
inline void ModelRepositoryParameter::set_int64_param(int64_t value) {
  _internal_set_int64_param(value);
  // @@protoc_insertion_point(field_set:inference.ModelRepositoryParameter.int64_param)
}

// string string_param = 3;
inline bool ModelRepositoryParameter::_internal_has_string_param() const {
  return parameter_choice_case() == kStringParam;
}
inline bool ModelRepositoryParameter::has_string_param() const {
  return _internal_has_string_param();
}
inline void ModelRepositoryParameter::set_has_string_param() {
  _impl_._oneof_case_[0] = kStringParam;
}
inline void ModelRepositoryParameter::clear_string_param() {
  if (_internal_has_string_param()) {
    _impl_.parameter_choice_.string_param_.Destroy();
    clear_has_parameter_choice();
  }
}
inline const std::string& ModelRepositoryParameter::string_param() const {
  // @@protoc_insertion_point(field_get:inference.ModelRepositoryParameter.string_param)
  return _internal_string_param();
}
template <typename ArgT0, typename... ArgT>
inline void ModelRepositoryParameter::set_string_param(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelRepositoryParameter.string_param)
}
inline std::string* ModelRepositoryParameter::mutable_string_param() {
  std::string* _s = _internal_mutable_string_param();
  // @@protoc_insertion_point(field_mutable:inference.ModelRepositoryParameter.string_param)
  return _s;
}
inline const std::string& ModelRepositoryParameter::_internal_string_param() const {
  if (_internal_has_string_param()) {
    return _impl_.parameter_choice_.string_param_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ModelRepositoryParameter::_internal_set_string_param(const std::string& value) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelRepositoryParameter::_internal_mutable_string_param() {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  return _impl_.parameter_choice_.string_param_.Mutable(      GetArenaForAllocation());
}
inline std::string* ModelRepositoryParameter::release_string_param() {
  // @@protoc_insertion_point(field_release:inference.ModelRepositoryParameter.string_param)
  if (_internal_has_string_param()) {
    clear_has_parameter_choice();
    return _impl_.parameter_choice_.string_param_.Release();
  } else {
    return nullptr;
  }
}
inline void ModelRepositoryParameter::set_allocated_string_param(std::string* string_param) {
  if (has_parameter_choice()) {
    clear_parameter_choice();
  }
  if (string_param != nullptr) {
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitAllocated(string_param, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelRepositoryParameter.string_param)
}

// bytes bytes_param = 4;
inline bool ModelRepositoryParameter::_internal_has_bytes_param() const {
  return parameter_choice_case() == kBytesParam;
}
inline bool ModelRepositoryParameter::has_bytes_param() const {
  return _internal_has_bytes_param();
}
inline void ModelRepositoryParameter::set_has_bytes_param() {
  _impl_._oneof_case_[0] = kBytesParam;
}
inline void ModelRepositoryParameter::clear_bytes_param() {
  if (_internal_has_bytes_param()) {
    _impl_.parameter_choice_.bytes_param_.Destroy();
    clear_has_parameter_choice();
  }
}
inline const std::string& ModelRepositoryParameter::bytes_param() const {
  // @@protoc_insertion_point(field_get:inference.ModelRepositoryParameter.bytes_param)
  return _internal_bytes_param();
}
template <typename ArgT0, typename... ArgT>
inline void ModelRepositoryParameter::set_bytes_param(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bytes_param()) {
    clear_parameter_choice();
    set_has_bytes_param();
    _impl_.parameter_choice_.bytes_param_.InitDefault();
  }
  _impl_.parameter_choice_.bytes_param_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelRepositoryParameter.bytes_param)
}
inline std::string* ModelRepositoryParameter::mutable_bytes_param() {
  std::string* _s = _internal_mutable_bytes_param();
  // @@protoc_insertion_point(field_mutable:inference.ModelRepositoryParameter.bytes_param)
  return _s;
}
inline const std::string& ModelRepositoryParameter::_internal_bytes_param() const {
  if (_internal_has_bytes_param()) {
    return _impl_.parameter_choice_.bytes_param_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ModelRepositoryParameter::_internal_set_bytes_param(const std::string& value) {
  if (!_internal_has_bytes_param()) {
    clear_parameter_choice();
    set_has_bytes_param();
    _impl_.parameter_choice_.bytes_param_.InitDefault();
  }
  _impl_.parameter_choice_.bytes_param_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelRepositoryParameter::_internal_mutable_bytes_param() {
  if (!_internal_has_bytes_param()) {
    clear_parameter_choice();
    set_has_bytes_param();
    _impl_.parameter_choice_.bytes_param_.InitDefault();
  }
  return _impl_.parameter_choice_.bytes_param_.Mutable(      GetArenaForAllocation());
}
inline std::string* ModelRepositoryParameter::release_bytes_param() {
  // @@protoc_insertion_point(field_release:inference.ModelRepositoryParameter.bytes_param)
  if (_internal_has_bytes_param()) {
    clear_has_parameter_choice();
    return _impl_.parameter_choice_.bytes_param_.Release();
  } else {
    return nullptr;
  }
}
inline void ModelRepositoryParameter::set_allocated_bytes_param(std::string* bytes_param) {
  if (has_parameter_choice()) {
    clear_parameter_choice();
  }
  if (bytes_param != nullptr) {
    set_has_bytes_param();
    _impl_.parameter_choice_.bytes_param_.InitAllocated(bytes_param, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelRepositoryParameter.bytes_param)
}

inline bool ModelRepositoryParameter::has_parameter_choice() const {
  return parameter_choice_case() != PARAMETER_CHOICE_NOT_SET;
}
inline void ModelRepositoryParameter::clear_has_parameter_choice() {
  _impl_._oneof_case_[0] = PARAMETER_CHOICE_NOT_SET;
}
inline ModelRepositoryParameter::ParameterChoiceCase ModelRepositoryParameter::parameter_choice_case() const {
  return ModelRepositoryParameter::ParameterChoiceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RepositoryIndexRequest

// string repository_name = 1;
inline void RepositoryIndexRequest::clear_repository_name() {
  _impl_.repository_name_.ClearToEmpty();
}
inline const std::string& RepositoryIndexRequest::repository_name() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexRequest.repository_name)
  return _internal_repository_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryIndexRequest::set_repository_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.repository_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryIndexRequest.repository_name)
}
inline std::string* RepositoryIndexRequest::mutable_repository_name() {
  std::string* _s = _internal_mutable_repository_name();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryIndexRequest.repository_name)
  return _s;
}
inline const std::string& RepositoryIndexRequest::_internal_repository_name() const {
  return _impl_.repository_name_.Get();
}
inline void RepositoryIndexRequest::_internal_set_repository_name(const std::string& value) {
  
  _impl_.repository_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryIndexRequest::_internal_mutable_repository_name() {
  
  return _impl_.repository_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryIndexRequest::release_repository_name() {
  // @@protoc_insertion_point(field_release:inference.RepositoryIndexRequest.repository_name)
  return _impl_.repository_name_.Release();
}
inline void RepositoryIndexRequest::set_allocated_repository_name(std::string* repository_name) {
  if (repository_name != nullptr) {
    
  } else {
    
  }
  _impl_.repository_name_.SetAllocated(repository_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.repository_name_.IsDefault()) {
    _impl_.repository_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryIndexRequest.repository_name)
}

// bool ready = 2;
inline void RepositoryIndexRequest::clear_ready() {
  _impl_.ready_ = false;
}
inline bool RepositoryIndexRequest::_internal_ready() const {
  return _impl_.ready_;
}
inline bool RepositoryIndexRequest::ready() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexRequest.ready)
  return _internal_ready();
}
inline void RepositoryIndexRequest::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void RepositoryIndexRequest::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:inference.RepositoryIndexRequest.ready)
}

// -------------------------------------------------------------------

// RepositoryIndexResponse_ModelIndex

// string name = 1;
inline void RepositoryIndexResponse_ModelIndex::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RepositoryIndexResponse_ModelIndex::name() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexResponse.ModelIndex.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryIndexResponse_ModelIndex::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryIndexResponse.ModelIndex.name)
}
inline std::string* RepositoryIndexResponse_ModelIndex::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryIndexResponse.ModelIndex.name)
  return _s;
}
inline const std::string& RepositoryIndexResponse_ModelIndex::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RepositoryIndexResponse_ModelIndex::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::release_name() {
  // @@protoc_insertion_point(field_release:inference.RepositoryIndexResponse.ModelIndex.name)
  return _impl_.name_.Release();
}
inline void RepositoryIndexResponse_ModelIndex::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryIndexResponse.ModelIndex.name)
}

// string version = 2;
inline void RepositoryIndexResponse_ModelIndex::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& RepositoryIndexResponse_ModelIndex::version() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexResponse.ModelIndex.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryIndexResponse_ModelIndex::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryIndexResponse.ModelIndex.version)
}
inline std::string* RepositoryIndexResponse_ModelIndex::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryIndexResponse.ModelIndex.version)
  return _s;
}
inline const std::string& RepositoryIndexResponse_ModelIndex::_internal_version() const {
  return _impl_.version_.Get();
}
inline void RepositoryIndexResponse_ModelIndex::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::release_version() {
  // @@protoc_insertion_point(field_release:inference.RepositoryIndexResponse.ModelIndex.version)
  return _impl_.version_.Release();
}
inline void RepositoryIndexResponse_ModelIndex::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryIndexResponse.ModelIndex.version)
}

// string state = 3;
inline void RepositoryIndexResponse_ModelIndex::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& RepositoryIndexResponse_ModelIndex::state() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexResponse.ModelIndex.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryIndexResponse_ModelIndex::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryIndexResponse.ModelIndex.state)
}
inline std::string* RepositoryIndexResponse_ModelIndex::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryIndexResponse.ModelIndex.state)
  return _s;
}
inline const std::string& RepositoryIndexResponse_ModelIndex::_internal_state() const {
  return _impl_.state_.Get();
}
inline void RepositoryIndexResponse_ModelIndex::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::release_state() {
  // @@protoc_insertion_point(field_release:inference.RepositoryIndexResponse.ModelIndex.state)
  return _impl_.state_.Release();
}
inline void RepositoryIndexResponse_ModelIndex::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryIndexResponse.ModelIndex.state)
}

// string reason = 4;
inline void RepositoryIndexResponse_ModelIndex::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& RepositoryIndexResponse_ModelIndex::reason() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexResponse.ModelIndex.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryIndexResponse_ModelIndex::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryIndexResponse.ModelIndex.reason)
}
inline std::string* RepositoryIndexResponse_ModelIndex::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryIndexResponse.ModelIndex.reason)
  return _s;
}
inline const std::string& RepositoryIndexResponse_ModelIndex::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void RepositoryIndexResponse_ModelIndex::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryIndexResponse_ModelIndex::release_reason() {
  // @@protoc_insertion_point(field_release:inference.RepositoryIndexResponse.ModelIndex.reason)
  return _impl_.reason_.Release();
}
inline void RepositoryIndexResponse_ModelIndex::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryIndexResponse.ModelIndex.reason)
}

// -------------------------------------------------------------------

// RepositoryIndexResponse

// repeated .inference.RepositoryIndexResponse.ModelIndex models = 1;
inline int RepositoryIndexResponse::_internal_models_size() const {
  return _impl_.models_.size();
}
inline int RepositoryIndexResponse::models_size() const {
  return _internal_models_size();
}
inline void RepositoryIndexResponse::clear_models() {
  _impl_.models_.Clear();
}
inline ::inference::RepositoryIndexResponse_ModelIndex* RepositoryIndexResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:inference.RepositoryIndexResponse.models)
  return _impl_.models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::RepositoryIndexResponse_ModelIndex >*
RepositoryIndexResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:inference.RepositoryIndexResponse.models)
  return &_impl_.models_;
}
inline const ::inference::RepositoryIndexResponse_ModelIndex& RepositoryIndexResponse::_internal_models(int index) const {
  return _impl_.models_.Get(index);
}
inline const ::inference::RepositoryIndexResponse_ModelIndex& RepositoryIndexResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:inference.RepositoryIndexResponse.models)
  return _internal_models(index);
}
inline ::inference::RepositoryIndexResponse_ModelIndex* RepositoryIndexResponse::_internal_add_models() {
  return _impl_.models_.Add();
}
inline ::inference::RepositoryIndexResponse_ModelIndex* RepositoryIndexResponse::add_models() {
  ::inference::RepositoryIndexResponse_ModelIndex* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:inference.RepositoryIndexResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::RepositoryIndexResponse_ModelIndex >&
RepositoryIndexResponse::models() const {
  // @@protoc_insertion_point(field_list:inference.RepositoryIndexResponse.models)
  return _impl_.models_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RepositoryModelLoadRequest

// string repository_name = 1;
inline void RepositoryModelLoadRequest::clear_repository_name() {
  _impl_.repository_name_.ClearToEmpty();
}
inline const std::string& RepositoryModelLoadRequest::repository_name() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryModelLoadRequest.repository_name)
  return _internal_repository_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryModelLoadRequest::set_repository_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.repository_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryModelLoadRequest.repository_name)
}
inline std::string* RepositoryModelLoadRequest::mutable_repository_name() {
  std::string* _s = _internal_mutable_repository_name();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryModelLoadRequest.repository_name)
  return _s;
}
inline const std::string& RepositoryModelLoadRequest::_internal_repository_name() const {
  return _impl_.repository_name_.Get();
}
inline void RepositoryModelLoadRequest::_internal_set_repository_name(const std::string& value) {
  
  _impl_.repository_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryModelLoadRequest::_internal_mutable_repository_name() {
  
  return _impl_.repository_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryModelLoadRequest::release_repository_name() {
  // @@protoc_insertion_point(field_release:inference.RepositoryModelLoadRequest.repository_name)
  return _impl_.repository_name_.Release();
}
inline void RepositoryModelLoadRequest::set_allocated_repository_name(std::string* repository_name) {
  if (repository_name != nullptr) {
    
  } else {
    
  }
  _impl_.repository_name_.SetAllocated(repository_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.repository_name_.IsDefault()) {
    _impl_.repository_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryModelLoadRequest.repository_name)
}

// string model_name = 2;
inline void RepositoryModelLoadRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RepositoryModelLoadRequest::model_name() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryModelLoadRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryModelLoadRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryModelLoadRequest.model_name)
}
inline std::string* RepositoryModelLoadRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryModelLoadRequest.model_name)
  return _s;
}
inline const std::string& RepositoryModelLoadRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void RepositoryModelLoadRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryModelLoadRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryModelLoadRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.RepositoryModelLoadRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void RepositoryModelLoadRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryModelLoadRequest.model_name)
}

// map<string, .inference.ModelRepositoryParameter> parameters = 3;
inline int RepositoryModelLoadRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int RepositoryModelLoadRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void RepositoryModelLoadRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
RepositoryModelLoadRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
RepositoryModelLoadRequest::parameters() const {
  // @@protoc_insertion_point(field_map:inference.RepositoryModelLoadRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
RepositoryModelLoadRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
RepositoryModelLoadRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.RepositoryModelLoadRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// RepositoryModelLoadResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RepositoryModelUnloadRequest

// string repository_name = 1;
inline void RepositoryModelUnloadRequest::clear_repository_name() {
  _impl_.repository_name_.ClearToEmpty();
}
inline const std::string& RepositoryModelUnloadRequest::repository_name() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryModelUnloadRequest.repository_name)
  return _internal_repository_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryModelUnloadRequest::set_repository_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.repository_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryModelUnloadRequest.repository_name)
}
inline std::string* RepositoryModelUnloadRequest::mutable_repository_name() {
  std::string* _s = _internal_mutable_repository_name();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryModelUnloadRequest.repository_name)
  return _s;
}
inline const std::string& RepositoryModelUnloadRequest::_internal_repository_name() const {
  return _impl_.repository_name_.Get();
}
inline void RepositoryModelUnloadRequest::_internal_set_repository_name(const std::string& value) {
  
  _impl_.repository_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryModelUnloadRequest::_internal_mutable_repository_name() {
  
  return _impl_.repository_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryModelUnloadRequest::release_repository_name() {
  // @@protoc_insertion_point(field_release:inference.RepositoryModelUnloadRequest.repository_name)
  return _impl_.repository_name_.Release();
}
inline void RepositoryModelUnloadRequest::set_allocated_repository_name(std::string* repository_name) {
  if (repository_name != nullptr) {
    
  } else {
    
  }
  _impl_.repository_name_.SetAllocated(repository_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.repository_name_.IsDefault()) {
    _impl_.repository_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryModelUnloadRequest.repository_name)
}

// string model_name = 2;
inline void RepositoryModelUnloadRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RepositoryModelUnloadRequest::model_name() const {
  // @@protoc_insertion_point(field_get:inference.RepositoryModelUnloadRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositoryModelUnloadRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.RepositoryModelUnloadRequest.model_name)
}
inline std::string* RepositoryModelUnloadRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.RepositoryModelUnloadRequest.model_name)
  return _s;
}
inline const std::string& RepositoryModelUnloadRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void RepositoryModelUnloadRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RepositoryModelUnloadRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RepositoryModelUnloadRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.RepositoryModelUnloadRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void RepositoryModelUnloadRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.RepositoryModelUnloadRequest.model_name)
}

// map<string, .inference.ModelRepositoryParameter> parameters = 3;
inline int RepositoryModelUnloadRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int RepositoryModelUnloadRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void RepositoryModelUnloadRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
RepositoryModelUnloadRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >&
RepositoryModelUnloadRequest::parameters() const {
  // @@protoc_insertion_point(field_map:inference.RepositoryModelUnloadRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
RepositoryModelUnloadRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelRepositoryParameter >*
RepositoryModelUnloadRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.RepositoryModelUnloadRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// RepositoryModelUnloadResponse

// -------------------------------------------------------------------

// SystemSharedMemoryStatusRequest

// string name = 1;
inline void SystemSharedMemoryStatusRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryStatusRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryStatusRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusRequest.name)
}
inline std::string* SystemSharedMemoryStatusRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryStatusRequest.name)
  return _s;
}
inline const std::string& SystemSharedMemoryStatusRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryStatusRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryStatusRequest.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryStatusRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryStatusRequest.name)
}

// -------------------------------------------------------------------

// SystemSharedMemoryStatusResponse_RegionStatus

// string name = 1;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse.RegionStatus.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryStatusResponse_RegionStatus::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse.RegionStatus.name)
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryStatusResponse.RegionStatus.name)
  return _s;
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryStatusResponse.RegionStatus.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryStatusResponse.RegionStatus.name)
}

// string key = 2;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::key() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse.RegionStatus.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryStatusResponse_RegionStatus::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse.RegionStatus.key)
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryStatusResponse.RegionStatus.key)
  return _s;
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::release_key() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryStatusResponse.RegionStatus.key)
  return _impl_.key_.Release();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryStatusResponse.RegionStatus.key)
}

// uint64 offset = 3;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::offset() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse.RegionStatus.offset)
  return _internal_offset();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse.RegionStatus.offset)
}

// uint64 byte_size = 4;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse.RegionStatus.byte_size)
  return _internal_byte_size();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse.RegionStatus.byte_size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SystemSharedMemoryStatusResponse

// map<string, .inference.SystemSharedMemoryStatusResponse.RegionStatus> regions = 1;
inline int SystemSharedMemoryStatusResponse::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int SystemSharedMemoryStatusResponse::regions_size() const {
  return _internal_regions_size();
}
inline void SystemSharedMemoryStatusResponse::clear_regions() {
  _impl_.regions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
SystemSharedMemoryStatusResponse::_internal_regions() const {
  return _impl_.regions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
SystemSharedMemoryStatusResponse::regions() const {
  // @@protoc_insertion_point(field_map:inference.SystemSharedMemoryStatusResponse.regions)
  return _internal_regions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
SystemSharedMemoryStatusResponse::_internal_mutable_regions() {
  return _impl_.regions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
SystemSharedMemoryStatusResponse::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_map:inference.SystemSharedMemoryStatusResponse.regions)
  return _internal_mutable_regions();
}

// -------------------------------------------------------------------

// SystemSharedMemoryRegisterRequest

// string name = 1;
inline void SystemSharedMemoryRegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryRegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryRegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.name)
}
inline std::string* SystemSharedMemoryRegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryRegisterRequest.name)
  return _s;
}
inline const std::string& SystemSharedMemoryRegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryRegisterRequest.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryRegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryRegisterRequest.name)
}

// string key = 2;
inline void SystemSharedMemoryRegisterRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryRegisterRequest::key() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryRegisterRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.key)
}
inline std::string* SystemSharedMemoryRegisterRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryRegisterRequest.key)
  return _s;
}
inline const std::string& SystemSharedMemoryRegisterRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::release_key() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryRegisterRequest.key)
  return _impl_.key_.Release();
}
inline void SystemSharedMemoryRegisterRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryRegisterRequest.key)
}

// uint64 offset = 3;
inline void SystemSharedMemoryRegisterRequest::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryRegisterRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t SystemSharedMemoryRegisterRequest::offset() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.offset)
  return _internal_offset();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void SystemSharedMemoryRegisterRequest::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.offset)
}

// uint64 byte_size = 4;
inline void SystemSharedMemoryRegisterRequest::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryRegisterRequest::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t SystemSharedMemoryRegisterRequest::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.byte_size)
  return _internal_byte_size();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void SystemSharedMemoryRegisterRequest::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.byte_size)
}

// -------------------------------------------------------------------

// SystemSharedMemoryRegisterResponse

// -------------------------------------------------------------------

// SystemSharedMemoryUnregisterRequest

// string name = 1;
inline void SystemSharedMemoryUnregisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryUnregisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryUnregisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryUnregisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryUnregisterRequest.name)
}
inline std::string* SystemSharedMemoryUnregisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryUnregisterRequest.name)
  return _s;
}
inline const std::string& SystemSharedMemoryUnregisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryUnregisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryUnregisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryUnregisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryUnregisterRequest.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryUnregisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryUnregisterRequest.name)
}

// -------------------------------------------------------------------

// SystemSharedMemoryUnregisterResponse

// -------------------------------------------------------------------

// CudaSharedMemoryStatusRequest

// string name = 1;
inline void CudaSharedMemoryStatusRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryStatusRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryStatusRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusRequest.name)
}
inline std::string* CudaSharedMemoryStatusRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryStatusRequest.name)
  return _s;
}
inline const std::string& CudaSharedMemoryStatusRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryStatusRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryStatusRequest.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryStatusRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryStatusRequest.name)
}

// -------------------------------------------------------------------

// CudaSharedMemoryStatusResponse_RegionStatus

// string name = 1;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryStatusResponse_RegionStatus::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse.RegionStatus.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryStatusResponse_RegionStatus::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse.RegionStatus.name)
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryStatusResponse.RegionStatus.name)
  return _s;
}
inline const std::string& CudaSharedMemoryStatusResponse_RegionStatus::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryStatusResponse.RegionStatus.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryStatusResponse.RegionStatus.name)
}

// uint64 device_id = 2;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_device_id() {
  _impl_.device_id_ = uint64_t{0u};
}
inline uint64_t CudaSharedMemoryStatusResponse_RegionStatus::_internal_device_id() const {
  return _impl_.device_id_;
}
inline uint64_t CudaSharedMemoryStatusResponse_RegionStatus::device_id() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse.RegionStatus.device_id)
  return _internal_device_id();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_device_id(uint64_t value) {
  
  _impl_.device_id_ = value;
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_device_id(uint64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse.RegionStatus.device_id)
}

// uint64 byte_size = 3;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t CudaSharedMemoryStatusResponse_RegionStatus::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t CudaSharedMemoryStatusResponse_RegionStatus::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse.RegionStatus.byte_size)
  return _internal_byte_size();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse.RegionStatus.byte_size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CudaSharedMemoryStatusResponse

// map<string, .inference.CudaSharedMemoryStatusResponse.RegionStatus> regions = 1;
inline int CudaSharedMemoryStatusResponse::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int CudaSharedMemoryStatusResponse::regions_size() const {
  return _internal_regions_size();
}
inline void CudaSharedMemoryStatusResponse::clear_regions() {
  _impl_.regions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
CudaSharedMemoryStatusResponse::_internal_regions() const {
  return _impl_.regions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
CudaSharedMemoryStatusResponse::regions() const {
  // @@protoc_insertion_point(field_map:inference.CudaSharedMemoryStatusResponse.regions)
  return _internal_regions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
CudaSharedMemoryStatusResponse::_internal_mutable_regions() {
  return _impl_.regions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
CudaSharedMemoryStatusResponse::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_map:inference.CudaSharedMemoryStatusResponse.regions)
  return _internal_mutable_regions();
}

// -------------------------------------------------------------------

// CudaSharedMemoryRegisterRequest

// string name = 1;
inline void CudaSharedMemoryRegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryRegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryRegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.name)
}
inline std::string* CudaSharedMemoryRegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryRegisterRequest.name)
  return _s;
}
inline const std::string& CudaSharedMemoryRegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryRegisterRequest.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryRegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryRegisterRequest.name)
}

// bytes raw_handle = 2;
inline void CudaSharedMemoryRegisterRequest::clear_raw_handle() {
  _impl_.raw_handle_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryRegisterRequest::raw_handle() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.raw_handle)
  return _internal_raw_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryRegisterRequest::set_raw_handle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_handle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.raw_handle)
}
inline std::string* CudaSharedMemoryRegisterRequest::mutable_raw_handle() {
  std::string* _s = _internal_mutable_raw_handle();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryRegisterRequest.raw_handle)
  return _s;
}
inline const std::string& CudaSharedMemoryRegisterRequest::_internal_raw_handle() const {
  return _impl_.raw_handle_.Get();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_raw_handle(const std::string& value) {
  
  _impl_.raw_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::_internal_mutable_raw_handle() {
  
  return _impl_.raw_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::release_raw_handle() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryRegisterRequest.raw_handle)
  return _impl_.raw_handle_.Release();
}
inline void CudaSharedMemoryRegisterRequest::set_allocated_raw_handle(std::string* raw_handle) {
  if (raw_handle != nullptr) {
    
  } else {
    
  }
  _impl_.raw_handle_.SetAllocated(raw_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_handle_.IsDefault()) {
    _impl_.raw_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryRegisterRequest.raw_handle)
}

// int64 device_id = 3;
inline void CudaSharedMemoryRegisterRequest::clear_device_id() {
  _impl_.device_id_ = int64_t{0};
}
inline int64_t CudaSharedMemoryRegisterRequest::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int64_t CudaSharedMemoryRegisterRequest::device_id() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.device_id)
  return _internal_device_id();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_device_id(int64_t value) {
  
  _impl_.device_id_ = value;
}
inline void CudaSharedMemoryRegisterRequest::set_device_id(int64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.device_id)
}

// uint64 byte_size = 4;
inline void CudaSharedMemoryRegisterRequest::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t CudaSharedMemoryRegisterRequest::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t CudaSharedMemoryRegisterRequest::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.byte_size)
  return _internal_byte_size();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void CudaSharedMemoryRegisterRequest::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.byte_size)
}

// -------------------------------------------------------------------

// CudaSharedMemoryRegisterResponse

// -------------------------------------------------------------------

// CudaSharedMemoryUnregisterRequest

// string name = 1;
inline void CudaSharedMemoryUnregisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryUnregisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryUnregisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryUnregisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryUnregisterRequest.name)
}
inline std::string* CudaSharedMemoryUnregisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryUnregisterRequest.name)
  return _s;
}
inline const std::string& CudaSharedMemoryUnregisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryUnregisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryUnregisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryUnregisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryUnregisterRequest.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryUnregisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryUnregisterRequest.name)
}

// -------------------------------------------------------------------

// CudaSharedMemoryUnregisterResponse

// -------------------------------------------------------------------

// TraceSettingRequest_SettingValue

// repeated string value = 1;
inline int TraceSettingRequest_SettingValue::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int TraceSettingRequest_SettingValue::value_size() const {
  return _internal_value_size();
}
inline void TraceSettingRequest_SettingValue::clear_value() {
  _impl_.value_.Clear();
}
inline std::string* TraceSettingRequest_SettingValue::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:inference.TraceSettingRequest.SettingValue.value)
  return _s;
}
inline const std::string& TraceSettingRequest_SettingValue::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const std::string& TraceSettingRequest_SettingValue::value(int index) const {
  // @@protoc_insertion_point(field_get:inference.TraceSettingRequest.SettingValue.value)
  return _internal_value(index);
}
inline std::string* TraceSettingRequest_SettingValue::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:inference.TraceSettingRequest.SettingValue.value)
  return _impl_.value_.Mutable(index);
}
inline void TraceSettingRequest_SettingValue::set_value(int index, const std::string& value) {
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.TraceSettingRequest.SettingValue.value)
}
inline void TraceSettingRequest_SettingValue::set_value(int index, std::string&& value) {
  _impl_.value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.TraceSettingRequest.SettingValue.value)
}
inline void TraceSettingRequest_SettingValue::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.TraceSettingRequest.SettingValue.value)
}
inline void TraceSettingRequest_SettingValue::set_value(int index, const char* value, size_t size) {
  _impl_.value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.TraceSettingRequest.SettingValue.value)
}
inline std::string* TraceSettingRequest_SettingValue::_internal_add_value() {
  return _impl_.value_.Add();
}
inline void TraceSettingRequest_SettingValue::add_value(const std::string& value) {
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.TraceSettingRequest.SettingValue.value)
}
inline void TraceSettingRequest_SettingValue::add_value(std::string&& value) {
  _impl_.value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.TraceSettingRequest.SettingValue.value)
}
inline void TraceSettingRequest_SettingValue::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.TraceSettingRequest.SettingValue.value)
}
inline void TraceSettingRequest_SettingValue::add_value(const char* value, size_t size) {
  _impl_.value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.TraceSettingRequest.SettingValue.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TraceSettingRequest_SettingValue::value() const {
  // @@protoc_insertion_point(field_list:inference.TraceSettingRequest.SettingValue.value)
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TraceSettingRequest_SettingValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:inference.TraceSettingRequest.SettingValue.value)
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TraceSettingRequest

// map<string, .inference.TraceSettingRequest.SettingValue> settings = 1;
inline int TraceSettingRequest::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int TraceSettingRequest::settings_size() const {
  return _internal_settings_size();
}
inline void TraceSettingRequest::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >&
TraceSettingRequest::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >&
TraceSettingRequest::settings() const {
  // @@protoc_insertion_point(field_map:inference.TraceSettingRequest.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >*
TraceSettingRequest::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingRequest_SettingValue >*
TraceSettingRequest::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:inference.TraceSettingRequest.settings)
  return _internal_mutable_settings();
}

// string model_name = 2;
inline void TraceSettingRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& TraceSettingRequest::model_name() const {
  // @@protoc_insertion_point(field_get:inference.TraceSettingRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceSettingRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.TraceSettingRequest.model_name)
}
inline std::string* TraceSettingRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.TraceSettingRequest.model_name)
  return _s;
}
inline const std::string& TraceSettingRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void TraceSettingRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceSettingRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceSettingRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.TraceSettingRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void TraceSettingRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.TraceSettingRequest.model_name)
}

// -------------------------------------------------------------------

// TraceSettingResponse_SettingValue

// repeated string value = 1;
inline int TraceSettingResponse_SettingValue::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int TraceSettingResponse_SettingValue::value_size() const {
  return _internal_value_size();
}
inline void TraceSettingResponse_SettingValue::clear_value() {
  _impl_.value_.Clear();
}
inline std::string* TraceSettingResponse_SettingValue::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:inference.TraceSettingResponse.SettingValue.value)
  return _s;
}
inline const std::string& TraceSettingResponse_SettingValue::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const std::string& TraceSettingResponse_SettingValue::value(int index) const {
  // @@protoc_insertion_point(field_get:inference.TraceSettingResponse.SettingValue.value)
  return _internal_value(index);
}
inline std::string* TraceSettingResponse_SettingValue::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:inference.TraceSettingResponse.SettingValue.value)
  return _impl_.value_.Mutable(index);
}
inline void TraceSettingResponse_SettingValue::set_value(int index, const std::string& value) {
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.TraceSettingResponse.SettingValue.value)
}
inline void TraceSettingResponse_SettingValue::set_value(int index, std::string&& value) {
  _impl_.value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.TraceSettingResponse.SettingValue.value)
}
inline void TraceSettingResponse_SettingValue::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.TraceSettingResponse.SettingValue.value)
}
inline void TraceSettingResponse_SettingValue::set_value(int index, const char* value, size_t size) {
  _impl_.value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.TraceSettingResponse.SettingValue.value)
}
inline std::string* TraceSettingResponse_SettingValue::_internal_add_value() {
  return _impl_.value_.Add();
}
inline void TraceSettingResponse_SettingValue::add_value(const std::string& value) {
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.TraceSettingResponse.SettingValue.value)
}
inline void TraceSettingResponse_SettingValue::add_value(std::string&& value) {
  _impl_.value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.TraceSettingResponse.SettingValue.value)
}
inline void TraceSettingResponse_SettingValue::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.TraceSettingResponse.SettingValue.value)
}
inline void TraceSettingResponse_SettingValue::add_value(const char* value, size_t size) {
  _impl_.value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.TraceSettingResponse.SettingValue.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TraceSettingResponse_SettingValue::value() const {
  // @@protoc_insertion_point(field_list:inference.TraceSettingResponse.SettingValue.value)
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TraceSettingResponse_SettingValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:inference.TraceSettingResponse.SettingValue.value)
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TraceSettingResponse

// map<string, .inference.TraceSettingResponse.SettingValue> settings = 1;
inline int TraceSettingResponse::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int TraceSettingResponse::settings_size() const {
  return _internal_settings_size();
}
inline void TraceSettingResponse::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >&
TraceSettingResponse::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >&
TraceSettingResponse::settings() const {
  // @@protoc_insertion_point(field_map:inference.TraceSettingResponse.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >*
TraceSettingResponse::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::TraceSettingResponse_SettingValue >*
TraceSettingResponse::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:inference.TraceSettingResponse.settings)
  return _internal_mutable_settings();
}

// -------------------------------------------------------------------

// LogSettingsRequest_SettingValue

// bool bool_param = 1;
inline bool LogSettingsRequest_SettingValue::_internal_has_bool_param() const {
  return parameter_choice_case() == kBoolParam;
}
inline bool LogSettingsRequest_SettingValue::has_bool_param() const {
  return _internal_has_bool_param();
}
inline void LogSettingsRequest_SettingValue::set_has_bool_param() {
  _impl_._oneof_case_[0] = kBoolParam;
}
inline void LogSettingsRequest_SettingValue::clear_bool_param() {
  if (_internal_has_bool_param()) {
    _impl_.parameter_choice_.bool_param_ = false;
    clear_has_parameter_choice();
  }
}
inline bool LogSettingsRequest_SettingValue::_internal_bool_param() const {
  if (_internal_has_bool_param()) {
    return _impl_.parameter_choice_.bool_param_;
  }
  return false;
}
inline void LogSettingsRequest_SettingValue::_internal_set_bool_param(bool value) {
  if (!_internal_has_bool_param()) {
    clear_parameter_choice();
    set_has_bool_param();
  }
  _impl_.parameter_choice_.bool_param_ = value;
}
inline bool LogSettingsRequest_SettingValue::bool_param() const {
  // @@protoc_insertion_point(field_get:inference.LogSettingsRequest.SettingValue.bool_param)
  return _internal_bool_param();
}
inline void LogSettingsRequest_SettingValue::set_bool_param(bool value) {
  _internal_set_bool_param(value);
  // @@protoc_insertion_point(field_set:inference.LogSettingsRequest.SettingValue.bool_param)
}

// uint32 uint32_param = 2;
inline bool LogSettingsRequest_SettingValue::_internal_has_uint32_param() const {
  return parameter_choice_case() == kUint32Param;
}
inline bool LogSettingsRequest_SettingValue::has_uint32_param() const {
  return _internal_has_uint32_param();
}
inline void LogSettingsRequest_SettingValue::set_has_uint32_param() {
  _impl_._oneof_case_[0] = kUint32Param;
}
inline void LogSettingsRequest_SettingValue::clear_uint32_param() {
  if (_internal_has_uint32_param()) {
    _impl_.parameter_choice_.uint32_param_ = 0u;
    clear_has_parameter_choice();
  }
}
inline uint32_t LogSettingsRequest_SettingValue::_internal_uint32_param() const {
  if (_internal_has_uint32_param()) {
    return _impl_.parameter_choice_.uint32_param_;
  }
  return 0u;
}
inline void LogSettingsRequest_SettingValue::_internal_set_uint32_param(uint32_t value) {
  if (!_internal_has_uint32_param()) {
    clear_parameter_choice();
    set_has_uint32_param();
  }
  _impl_.parameter_choice_.uint32_param_ = value;
}
inline uint32_t LogSettingsRequest_SettingValue::uint32_param() const {
  // @@protoc_insertion_point(field_get:inference.LogSettingsRequest.SettingValue.uint32_param)
  return _internal_uint32_param();
}
inline void LogSettingsRequest_SettingValue::set_uint32_param(uint32_t value) {
  _internal_set_uint32_param(value);
  // @@protoc_insertion_point(field_set:inference.LogSettingsRequest.SettingValue.uint32_param)
}

// string string_param = 3;
inline bool LogSettingsRequest_SettingValue::_internal_has_string_param() const {
  return parameter_choice_case() == kStringParam;
}
inline bool LogSettingsRequest_SettingValue::has_string_param() const {
  return _internal_has_string_param();
}
inline void LogSettingsRequest_SettingValue::set_has_string_param() {
  _impl_._oneof_case_[0] = kStringParam;
}
inline void LogSettingsRequest_SettingValue::clear_string_param() {
  if (_internal_has_string_param()) {
    _impl_.parameter_choice_.string_param_.Destroy();
    clear_has_parameter_choice();
  }
}
inline const std::string& LogSettingsRequest_SettingValue::string_param() const {
  // @@protoc_insertion_point(field_get:inference.LogSettingsRequest.SettingValue.string_param)
  return _internal_string_param();
}
template <typename ArgT0, typename... ArgT>
inline void LogSettingsRequest_SettingValue::set_string_param(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.LogSettingsRequest.SettingValue.string_param)
}
inline std::string* LogSettingsRequest_SettingValue::mutable_string_param() {
  std::string* _s = _internal_mutable_string_param();
  // @@protoc_insertion_point(field_mutable:inference.LogSettingsRequest.SettingValue.string_param)
  return _s;
}
inline const std::string& LogSettingsRequest_SettingValue::_internal_string_param() const {
  if (_internal_has_string_param()) {
    return _impl_.parameter_choice_.string_param_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LogSettingsRequest_SettingValue::_internal_set_string_param(const std::string& value) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSettingsRequest_SettingValue::_internal_mutable_string_param() {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  return _impl_.parameter_choice_.string_param_.Mutable(      GetArenaForAllocation());
}
inline std::string* LogSettingsRequest_SettingValue::release_string_param() {
  // @@protoc_insertion_point(field_release:inference.LogSettingsRequest.SettingValue.string_param)
  if (_internal_has_string_param()) {
    clear_has_parameter_choice();
    return _impl_.parameter_choice_.string_param_.Release();
  } else {
    return nullptr;
  }
}
inline void LogSettingsRequest_SettingValue::set_allocated_string_param(std::string* string_param) {
  if (has_parameter_choice()) {
    clear_parameter_choice();
  }
  if (string_param != nullptr) {
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitAllocated(string_param, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.LogSettingsRequest.SettingValue.string_param)
}

inline bool LogSettingsRequest_SettingValue::has_parameter_choice() const {
  return parameter_choice_case() != PARAMETER_CHOICE_NOT_SET;
}
inline void LogSettingsRequest_SettingValue::clear_has_parameter_choice() {
  _impl_._oneof_case_[0] = PARAMETER_CHOICE_NOT_SET;
}
inline LogSettingsRequest_SettingValue::ParameterChoiceCase LogSettingsRequest_SettingValue::parameter_choice_case() const {
  return LogSettingsRequest_SettingValue::ParameterChoiceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LogSettingsRequest

// map<string, .inference.LogSettingsRequest.SettingValue> settings = 1;
inline int LogSettingsRequest::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int LogSettingsRequest::settings_size() const {
  return _internal_settings_size();
}
inline void LogSettingsRequest::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >&
LogSettingsRequest::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >&
LogSettingsRequest::settings() const {
  // @@protoc_insertion_point(field_map:inference.LogSettingsRequest.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >*
LogSettingsRequest::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsRequest_SettingValue >*
LogSettingsRequest::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:inference.LogSettingsRequest.settings)
  return _internal_mutable_settings();
}

// -------------------------------------------------------------------

// LogSettingsResponse_SettingValue

// bool bool_param = 1;
inline bool LogSettingsResponse_SettingValue::_internal_has_bool_param() const {
  return parameter_choice_case() == kBoolParam;
}
inline bool LogSettingsResponse_SettingValue::has_bool_param() const {
  return _internal_has_bool_param();
}
inline void LogSettingsResponse_SettingValue::set_has_bool_param() {
  _impl_._oneof_case_[0] = kBoolParam;
}
inline void LogSettingsResponse_SettingValue::clear_bool_param() {
  if (_internal_has_bool_param()) {
    _impl_.parameter_choice_.bool_param_ = false;
    clear_has_parameter_choice();
  }
}
inline bool LogSettingsResponse_SettingValue::_internal_bool_param() const {
  if (_internal_has_bool_param()) {
    return _impl_.parameter_choice_.bool_param_;
  }
  return false;
}
inline void LogSettingsResponse_SettingValue::_internal_set_bool_param(bool value) {
  if (!_internal_has_bool_param()) {
    clear_parameter_choice();
    set_has_bool_param();
  }
  _impl_.parameter_choice_.bool_param_ = value;
}
inline bool LogSettingsResponse_SettingValue::bool_param() const {
  // @@protoc_insertion_point(field_get:inference.LogSettingsResponse.SettingValue.bool_param)
  return _internal_bool_param();
}
inline void LogSettingsResponse_SettingValue::set_bool_param(bool value) {
  _internal_set_bool_param(value);
  // @@protoc_insertion_point(field_set:inference.LogSettingsResponse.SettingValue.bool_param)
}

// uint32 uint32_param = 2;
inline bool LogSettingsResponse_SettingValue::_internal_has_uint32_param() const {
  return parameter_choice_case() == kUint32Param;
}
inline bool LogSettingsResponse_SettingValue::has_uint32_param() const {
  return _internal_has_uint32_param();
}
inline void LogSettingsResponse_SettingValue::set_has_uint32_param() {
  _impl_._oneof_case_[0] = kUint32Param;
}
inline void LogSettingsResponse_SettingValue::clear_uint32_param() {
  if (_internal_has_uint32_param()) {
    _impl_.parameter_choice_.uint32_param_ = 0u;
    clear_has_parameter_choice();
  }
}
inline uint32_t LogSettingsResponse_SettingValue::_internal_uint32_param() const {
  if (_internal_has_uint32_param()) {
    return _impl_.parameter_choice_.uint32_param_;
  }
  return 0u;
}
inline void LogSettingsResponse_SettingValue::_internal_set_uint32_param(uint32_t value) {
  if (!_internal_has_uint32_param()) {
    clear_parameter_choice();
    set_has_uint32_param();
  }
  _impl_.parameter_choice_.uint32_param_ = value;
}
inline uint32_t LogSettingsResponse_SettingValue::uint32_param() const {
  // @@protoc_insertion_point(field_get:inference.LogSettingsResponse.SettingValue.uint32_param)
  return _internal_uint32_param();
}
inline void LogSettingsResponse_SettingValue::set_uint32_param(uint32_t value) {
  _internal_set_uint32_param(value);
  // @@protoc_insertion_point(field_set:inference.LogSettingsResponse.SettingValue.uint32_param)
}

// string string_param = 3;
inline bool LogSettingsResponse_SettingValue::_internal_has_string_param() const {
  return parameter_choice_case() == kStringParam;
}
inline bool LogSettingsResponse_SettingValue::has_string_param() const {
  return _internal_has_string_param();
}
inline void LogSettingsResponse_SettingValue::set_has_string_param() {
  _impl_._oneof_case_[0] = kStringParam;
}
inline void LogSettingsResponse_SettingValue::clear_string_param() {
  if (_internal_has_string_param()) {
    _impl_.parameter_choice_.string_param_.Destroy();
    clear_has_parameter_choice();
  }
}
inline const std::string& LogSettingsResponse_SettingValue::string_param() const {
  // @@protoc_insertion_point(field_get:inference.LogSettingsResponse.SettingValue.string_param)
  return _internal_string_param();
}
template <typename ArgT0, typename... ArgT>
inline void LogSettingsResponse_SettingValue::set_string_param(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.LogSettingsResponse.SettingValue.string_param)
}
inline std::string* LogSettingsResponse_SettingValue::mutable_string_param() {
  std::string* _s = _internal_mutable_string_param();
  // @@protoc_insertion_point(field_mutable:inference.LogSettingsResponse.SettingValue.string_param)
  return _s;
}
inline const std::string& LogSettingsResponse_SettingValue::_internal_string_param() const {
  if (_internal_has_string_param()) {
    return _impl_.parameter_choice_.string_param_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LogSettingsResponse_SettingValue::_internal_set_string_param(const std::string& value) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSettingsResponse_SettingValue::_internal_mutable_string_param() {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  return _impl_.parameter_choice_.string_param_.Mutable(      GetArenaForAllocation());
}
inline std::string* LogSettingsResponse_SettingValue::release_string_param() {
  // @@protoc_insertion_point(field_release:inference.LogSettingsResponse.SettingValue.string_param)
  if (_internal_has_string_param()) {
    clear_has_parameter_choice();
    return _impl_.parameter_choice_.string_param_.Release();
  } else {
    return nullptr;
  }
}
inline void LogSettingsResponse_SettingValue::set_allocated_string_param(std::string* string_param) {
  if (has_parameter_choice()) {
    clear_parameter_choice();
  }
  if (string_param != nullptr) {
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitAllocated(string_param, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.LogSettingsResponse.SettingValue.string_param)
}

inline bool LogSettingsResponse_SettingValue::has_parameter_choice() const {
  return parameter_choice_case() != PARAMETER_CHOICE_NOT_SET;
}
inline void LogSettingsResponse_SettingValue::clear_has_parameter_choice() {
  _impl_._oneof_case_[0] = PARAMETER_CHOICE_NOT_SET;
}
inline LogSettingsResponse_SettingValue::ParameterChoiceCase LogSettingsResponse_SettingValue::parameter_choice_case() const {
  return LogSettingsResponse_SettingValue::ParameterChoiceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LogSettingsResponse

// map<string, .inference.LogSettingsResponse.SettingValue> settings = 1;
inline int LogSettingsResponse::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int LogSettingsResponse::settings_size() const {
  return _internal_settings_size();
}
inline void LogSettingsResponse::clear_settings() {
  _impl_.settings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >&
LogSettingsResponse::_internal_settings() const {
  return _impl_.settings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >&
LogSettingsResponse::settings() const {
  // @@protoc_insertion_point(field_map:inference.LogSettingsResponse.settings)
  return _internal_settings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >*
LogSettingsResponse::_internal_mutable_settings() {
  return _impl_.settings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::LogSettingsResponse_SettingValue >*
LogSettingsResponse::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_map:inference.LogSettingsResponse.settings)
  return _internal_mutable_settings();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace inference

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpc_5fservice_2eproto
