// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_config.proto

#include "model_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace inference {
PROTOBUF_CONSTEXPR ModelRateLimiter_Resource::ModelRateLimiter_Resource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.global_)*/false
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelRateLimiter_ResourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelRateLimiter_ResourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelRateLimiter_ResourceDefaultTypeInternal() {}
  union {
    ModelRateLimiter_Resource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelRateLimiter_ResourceDefaultTypeInternal _ModelRateLimiter_Resource_default_instance_;
PROTOBUF_CONSTEXPR ModelRateLimiter::ModelRateLimiter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.resources_)*/{}
  , /*decltype(_impl_.priority_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelRateLimiterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelRateLimiterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelRateLimiterDefaultTypeInternal() {}
  union {
    ModelRateLimiter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelRateLimiterDefaultTypeInternal _ModelRateLimiter_default_instance_;
PROTOBUF_CONSTEXPR ModelInstanceGroup_SecondaryDevice::ModelInstanceGroup_SecondaryDevice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_id_)*/int64_t{0}
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal() {}
  union {
    ModelInstanceGroup_SecondaryDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal _ModelInstanceGroup_SecondaryDevice_default_instance_;
PROTOBUF_CONSTEXPR ModelInstanceGroup::ModelInstanceGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gpus_)*/{}
  , /*decltype(_impl_._gpus_cached_byte_size_)*/{0}
  , /*decltype(_impl_.profile_)*/{}
  , /*decltype(_impl_.secondary_devices_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_policy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rate_limiter_)*/nullptr
  , /*decltype(_impl_.count_)*/0
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.passive_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelInstanceGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelInstanceGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelInstanceGroupDefaultTypeInternal() {}
  union {
    ModelInstanceGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelInstanceGroupDefaultTypeInternal _ModelInstanceGroup_default_instance_;
PROTOBUF_CONSTEXPR ModelTensorReshape::ModelTensorReshape(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shape_)*/{}
  , /*decltype(_impl_._shape_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelTensorReshapeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelTensorReshapeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelTensorReshapeDefaultTypeInternal() {}
  union {
    ModelTensorReshape _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelTensorReshapeDefaultTypeInternal _ModelTensorReshape_default_instance_;
PROTOBUF_CONSTEXPR ModelInput::ModelInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dims_)*/{}
  , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reshape_)*/nullptr
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.is_shape_tensor_)*/false
  , /*decltype(_impl_.allow_ragged_batch_)*/false
  , /*decltype(_impl_.optional_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelInputDefaultTypeInternal() {}
  union {
    ModelInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelInputDefaultTypeInternal _ModelInput_default_instance_;
PROTOBUF_CONSTEXPR ModelOutput::ModelOutput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dims_)*/{}
  , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.label_filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reshape_)*/nullptr
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.is_shape_tensor_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOutputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOutputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOutputDefaultTypeInternal() {}
  union {
    ModelOutput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOutputDefaultTypeInternal _ModelOutput_default_instance_;
PROTOBUF_CONSTEXPR BatchInput::BatchInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_name_)*/{}
  , /*decltype(_impl_.source_input_)*/{}
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchInputDefaultTypeInternal() {}
  union {
    BatchInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchInputDefaultTypeInternal _BatchInput_default_instance_;
PROTOBUF_CONSTEXPR BatchOutput::BatchOutput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_name_)*/{}
  , /*decltype(_impl_.source_input_)*/{}
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchOutputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchOutputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchOutputDefaultTypeInternal() {}
  union {
    BatchOutput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchOutputDefaultTypeInternal _BatchOutput_default_instance_;
PROTOBUF_CONSTEXPR ModelVersionPolicy_Latest::ModelVersionPolicy_Latest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.num_versions_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelVersionPolicy_LatestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelVersionPolicy_LatestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelVersionPolicy_LatestDefaultTypeInternal() {}
  union {
    ModelVersionPolicy_Latest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelVersionPolicy_LatestDefaultTypeInternal _ModelVersionPolicy_Latest_default_instance_;
PROTOBUF_CONSTEXPR ModelVersionPolicy_All::ModelVersionPolicy_All(
    ::_pbi::ConstantInitialized) {}
struct ModelVersionPolicy_AllDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelVersionPolicy_AllDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelVersionPolicy_AllDefaultTypeInternal() {}
  union {
    ModelVersionPolicy_All _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelVersionPolicy_AllDefaultTypeInternal _ModelVersionPolicy_All_default_instance_;
PROTOBUF_CONSTEXPR ModelVersionPolicy_Specific::ModelVersionPolicy_Specific(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.versions_)*/{}
  , /*decltype(_impl_._versions_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelVersionPolicy_SpecificDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelVersionPolicy_SpecificDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelVersionPolicy_SpecificDefaultTypeInternal() {}
  union {
    ModelVersionPolicy_Specific _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelVersionPolicy_SpecificDefaultTypeInternal _ModelVersionPolicy_Specific_default_instance_;
PROTOBUF_CONSTEXPR ModelVersionPolicy::ModelVersionPolicy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.policy_choice_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModelVersionPolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelVersionPolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelVersionPolicyDefaultTypeInternal() {}
  union {
    ModelVersionPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelVersionPolicyDefaultTypeInternal _ModelVersionPolicy_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Graph::ModelOptimizationPolicy_Graph(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_GraphDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_GraphDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_GraphDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Graph _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_GraphDefaultTypeInternal _ModelOptimizationPolicy_Graph_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ModelOptimizationPolicy_Cuda_GraphSpec_Shape(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dim_)*/{}
  , /*decltype(_impl_._dim_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_Shape _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.batch_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec::ModelOptimizationPolicy_Cuda_GraphSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.graph_lower_bound_)*/nullptr
  , /*decltype(_impl_.batch_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda::ModelOptimizationPolicy_Cuda(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.graph_spec_)*/{}
  , /*decltype(_impl_.graphs_)*/false
  , /*decltype(_impl_.busy_wait_events_)*/false
  , /*decltype(_impl_.output_copy_stream_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_CudaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_CudaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_CudaDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_CudaDefaultTypeInternal _ModelOptimizationPolicy_Cuda_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parameters_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators::ModelOptimizationPolicy_ExecutionAccelerators(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gpu_execution_accelerator_)*/{}
  , /*decltype(_impl_.cpu_execution_accelerator_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_ExecutionAccelerators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy_PinnedMemoryBuffer::ModelOptimizationPolicy_PinnedMemoryBuffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.enable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_PinnedMemoryBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal _ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_;
PROTOBUF_CONSTEXPR ModelOptimizationPolicy::ModelOptimizationPolicy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.graph_)*/nullptr
  , /*decltype(_impl_.cuda_)*/nullptr
  , /*decltype(_impl_.execution_accelerators_)*/nullptr
  , /*decltype(_impl_.input_pinned_memory_)*/nullptr
  , /*decltype(_impl_.output_pinned_memory_)*/nullptr
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_.gather_kernel_buffer_threshold_)*/0u
  , /*decltype(_impl_.eager_batching_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOptimizationPolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOptimizationPolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOptimizationPolicyDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOptimizationPolicyDefaultTypeInternal _ModelOptimizationPolicy_default_instance_;
PROTOBUF_CONSTEXPR ModelQueuePolicy::ModelQueuePolicy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.default_timeout_microseconds_)*/uint64_t{0u}
  , /*decltype(_impl_.timeout_action_)*/0
  , /*decltype(_impl_.allow_timeout_override_)*/false
  , /*decltype(_impl_.max_queue_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelQueuePolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelQueuePolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelQueuePolicyDefaultTypeInternal() {}
  union {
    ModelQueuePolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelQueuePolicyDefaultTypeInternal _ModelQueuePolicy_default_instance_;
PROTOBUF_CONSTEXPR ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal _ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelDynamicBatching::ModelDynamicBatching(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.preferred_batch_size_)*/{}
  , /*decltype(_impl_._preferred_batch_size_cached_byte_size_)*/{0}
  , /*decltype(_impl_.priority_queue_policy_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.default_queue_policy_)*/nullptr
  , /*decltype(_impl_.max_queue_delay_microseconds_)*/uint64_t{0u}
  , /*decltype(_impl_.priority_levels_)*/uint64_t{0u}
  , /*decltype(_impl_.default_priority_level_)*/uint64_t{0u}
  , /*decltype(_impl_.preserve_ordering_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelDynamicBatchingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelDynamicBatchingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelDynamicBatchingDefaultTypeInternal() {}
  union {
    ModelDynamicBatching _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelDynamicBatchingDefaultTypeInternal _ModelDynamicBatching_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching_Control::ModelSequenceBatching_Control(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.int32_false_true_)*/{}
  , /*decltype(_impl_._int32_false_true_cached_byte_size_)*/{0}
  , /*decltype(_impl_.fp32_false_true_)*/{}
  , /*decltype(_impl_.bool_false_true_)*/{}
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelSequenceBatching_ControlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatching_ControlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatching_ControlDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_Control _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatching_ControlDefaultTypeInternal _ModelSequenceBatching_Control_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching_ControlInput::ModelSequenceBatching_ControlInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.control_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelSequenceBatching_ControlInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatching_ControlInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatching_ControlInputDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_ControlInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatching_ControlInputDefaultTypeInternal _ModelSequenceBatching_ControlInput_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching_InitialState::ModelSequenceBatching_InitialState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dims_)*/{}
  , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.state_data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModelSequenceBatching_InitialStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatching_InitialStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatching_InitialStateDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_InitialState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatching_InitialStateDefaultTypeInternal _ModelSequenceBatching_InitialState_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching_State::ModelSequenceBatching_State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dims_)*/{}
  , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
  , /*decltype(_impl_.initial_state_)*/{}
  , /*decltype(_impl_.input_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.use_same_buffer_for_input_output_)*/false
  , /*decltype(_impl_.use_growable_memory_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelSequenceBatching_StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatching_StateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatching_StateDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_State _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatching_StateDefaultTypeInternal _ModelSequenceBatching_State_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching_StrategyDirect::ModelSequenceBatching_StrategyDirect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.max_queue_delay_microseconds_)*/uint64_t{0u}
  , /*decltype(_impl_.minimum_slot_utilization_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelSequenceBatching_StrategyDirectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatching_StrategyDirectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatching_StrategyDirectDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_StrategyDirect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatching_StrategyDirectDefaultTypeInternal _ModelSequenceBatching_StrategyDirect_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching_StrategyOldest::ModelSequenceBatching_StrategyOldest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.preferred_batch_size_)*/{}
  , /*decltype(_impl_._preferred_batch_size_cached_byte_size_)*/{0}
  , /*decltype(_impl_.max_candidate_sequences_)*/0
  , /*decltype(_impl_.preserve_ordering_)*/false
  , /*decltype(_impl_.max_queue_delay_microseconds_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelSequenceBatching_StrategyOldestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatching_StrategyOldestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatching_StrategyOldestDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_StrategyOldest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatching_StrategyOldestDefaultTypeInternal _ModelSequenceBatching_StrategyOldest_default_instance_;
PROTOBUF_CONSTEXPR ModelSequenceBatching::ModelSequenceBatching(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.control_input_)*/{}
  , /*decltype(_impl_.state_)*/{}
  , /*decltype(_impl_.max_sequence_idle_microseconds_)*/uint64_t{0u}
  , /*decltype(_impl_.iterative_sequence_)*/false
  , /*decltype(_impl_.strategy_choice_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModelSequenceBatchingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelSequenceBatchingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelSequenceBatchingDefaultTypeInternal() {}
  union {
    ModelSequenceBatching _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelSequenceBatchingDefaultTypeInternal _ModelSequenceBatching_default_instance_;
PROTOBUF_CONSTEXPR ModelEnsembling_Step_InputMapEntry_DoNotUse::ModelEnsembling_Step_InputMapEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelEnsembling_Step_InputMapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelEnsembling_Step_OutputMapEntry_DoNotUse::ModelEnsembling_Step_OutputMapEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelEnsembling_Step_OutputMapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelEnsembling_Step::ModelEnsembling_Step(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_map_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.output_map_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.model_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_namespace_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_version_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelEnsembling_StepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelEnsembling_StepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelEnsembling_StepDefaultTypeInternal() {}
  union {
    ModelEnsembling_Step _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelEnsembling_StepDefaultTypeInternal _ModelEnsembling_Step_default_instance_;
PROTOBUF_CONSTEXPR ModelEnsembling::ModelEnsembling(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.step_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelEnsemblingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelEnsemblingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelEnsemblingDefaultTypeInternal() {}
  union {
    ModelEnsembling _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelEnsemblingDefaultTypeInternal _ModelEnsembling_default_instance_;
PROTOBUF_CONSTEXPR ModelParameter::ModelParameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.string_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelParameterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelParameterDefaultTypeInternal() {}
  union {
    ModelParameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelParameterDefaultTypeInternal _ModelParameter_default_instance_;
PROTOBUF_CONSTEXPR ModelWarmup_Input::ModelWarmup_Input(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dims_)*/{}
  , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.input_data_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModelWarmup_InputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelWarmup_InputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelWarmup_InputDefaultTypeInternal() {}
  union {
    ModelWarmup_Input _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelWarmup_InputDefaultTypeInternal _ModelWarmup_Input_default_instance_;
PROTOBUF_CONSTEXPR ModelWarmup_InputsEntry_DoNotUse::ModelWarmup_InputsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelWarmup_InputsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal _ModelWarmup_InputsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelWarmup::ModelWarmup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.inputs_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.batch_size_)*/0u
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelWarmupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelWarmupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelWarmupDefaultTypeInternal() {}
  union {
    ModelWarmup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelWarmupDefaultTypeInternal _ModelWarmup_default_instance_;
PROTOBUF_CONSTEXPR ModelOperations::ModelOperations(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.op_library_filename_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelOperationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelOperationsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelOperationsDefaultTypeInternal() {}
  union {
    ModelOperations _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelOperationsDefaultTypeInternal _ModelOperations_default_instance_;
PROTOBUF_CONSTEXPR ModelTransactionPolicy::ModelTransactionPolicy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.decoupled_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelTransactionPolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelTransactionPolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelTransactionPolicyDefaultTypeInternal() {}
  union {
    ModelTransactionPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelTransactionPolicyDefaultTypeInternal _ModelTransactionPolicy_default_instance_;
PROTOBUF_CONSTEXPR ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal _ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelRepositoryAgents_Agent::ModelRepositoryAgents_Agent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parameters_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelRepositoryAgents_AgentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelRepositoryAgents_AgentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelRepositoryAgents_AgentDefaultTypeInternal() {}
  union {
    ModelRepositoryAgents_Agent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelRepositoryAgents_AgentDefaultTypeInternal _ModelRepositoryAgents_Agent_default_instance_;
PROTOBUF_CONSTEXPR ModelRepositoryAgents::ModelRepositoryAgents(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.agents_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelRepositoryAgentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelRepositoryAgentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelRepositoryAgentsDefaultTypeInternal() {}
  union {
    ModelRepositoryAgents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelRepositoryAgentsDefaultTypeInternal _ModelRepositoryAgents_default_instance_;
PROTOBUF_CONSTEXPR ModelResponseCache::ModelResponseCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.enable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelResponseCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelResponseCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelResponseCacheDefaultTypeInternal() {}
  union {
    ModelResponseCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelResponseCacheDefaultTypeInternal _ModelResponseCache_default_instance_;
PROTOBUF_CONSTEXPR ModelConfig_CcModelFilenamesEntry_DoNotUse::ModelConfig_CcModelFilenamesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelConfig_CcModelFilenamesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal _ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelConfig_MetricTagsEntry_DoNotUse::ModelConfig_MetricTagsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelConfig_MetricTagsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal _ModelConfig_MetricTagsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelConfig_ParametersEntry_DoNotUse::ModelConfig_ParametersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelConfig_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal _ModelConfig_ParametersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelConfig::ModelConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_)*/{}
  , /*decltype(_impl_.output_)*/{}
  , /*decltype(_impl_.instance_group_)*/{}
  , /*decltype(_impl_.cc_model_filenames_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.metric_tags_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.parameters_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.model_warmup_)*/{}
  , /*decltype(_impl_.batch_input_)*/{}
  , /*decltype(_impl_.batch_output_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.platform_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default_model_filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.backend_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.runtime_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_policy_)*/nullptr
  , /*decltype(_impl_.optimization_)*/nullptr
  , /*decltype(_impl_.model_operations_)*/nullptr
  , /*decltype(_impl_.model_transaction_policy_)*/nullptr
  , /*decltype(_impl_.model_repository_agents_)*/nullptr
  , /*decltype(_impl_.response_cache_)*/nullptr
  , /*decltype(_impl_.max_batch_size_)*/0
  , /*decltype(_impl_.scheduling_choice_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModelConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelConfigDefaultTypeInternal() {}
  union {
    ModelConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelConfigDefaultTypeInternal _ModelConfig_default_instance_;
}  // namespace inference
static ::_pb::Metadata file_level_metadata_model_5fconfig_2eproto[53];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_model_5fconfig_2eproto[9];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_model_5fconfig_2eproto = nullptr;

const uint32_t TableStruct_model_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, _impl_.global_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, _impl_.count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter, _impl_.resources_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter, _impl_.priority_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup_SecondaryDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup_SecondaryDevice, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup_SecondaryDevice, _impl_.device_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.rate_limiter_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.gpus_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.secondary_devices_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.profile_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.passive_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _impl_.host_policy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTensorReshape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTensorReshape, _impl_.shape_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.dims_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.reshape_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.is_shape_tensor_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.allow_ragged_batch_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _impl_.optional_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _impl_.dims_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _impl_.reshape_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _impl_.label_filename_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _impl_.is_shape_tensor_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, _impl_.target_name_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, _impl_.source_input_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, _impl_.target_name_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, _impl_.source_input_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Latest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Latest, _impl_.num_versions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_All, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Specific, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Specific, _impl_.versions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy, _impl_.policy_choice_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Graph, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Graph, _impl_.level_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape, _impl_.dim_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound, _impl_.batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound, _impl_.input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, _impl_.batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, _impl_.input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, _impl_.graph_lower_bound_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, _impl_.graphs_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, _impl_.busy_wait_events_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, _impl_.graph_spec_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, _impl_.output_copy_stream_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator, _impl_.parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators, _impl_.gpu_execution_accelerator_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators, _impl_.cpu_execution_accelerator_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer, _impl_.enable_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.graph_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.cuda_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.execution_accelerators_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.input_pinned_memory_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.output_pinned_memory_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.gather_kernel_buffer_threshold_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _impl_.eager_batching_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, _impl_.timeout_action_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, _impl_.default_timeout_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, _impl_.allow_timeout_override_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, _impl_.max_queue_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.preferred_batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.max_queue_delay_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.preserve_ordering_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.priority_levels_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.default_priority_level_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.default_queue_policy_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _impl_.priority_queue_policy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _impl_.int32_false_true_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _impl_.fp32_false_true_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _impl_.bool_false_true_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _impl_.data_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_ControlInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_ControlInput, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_ControlInput, _impl_.control_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _impl_.dims_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _impl_.state_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.input_name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.output_name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.dims_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.initial_state_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.use_same_buffer_for_input_output_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _impl_.use_growable_memory_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyDirect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyDirect, _impl_.max_queue_delay_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyDirect, _impl_.minimum_slot_utilization_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, _impl_.max_candidate_sequences_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, _impl_.preferred_batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, _impl_.max_queue_delay_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, _impl_.preserve_ordering_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _impl_.max_sequence_idle_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _impl_.control_input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _impl_.iterative_sequence_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _impl_.strategy_choice_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _impl_.model_name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _impl_.model_version_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _impl_.input_map_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _impl_.output_map_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _impl_.model_namespace_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling, _impl_.step_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelParameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelParameter, _impl_.string_value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _impl_.dims_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _impl_.input_data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, _impl_.batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, _impl_.inputs_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, _impl_.count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOperations, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOperations, _impl_.op_library_filename_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTransactionPolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTransactionPolicy, _impl_.decoupled_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent, _impl_.parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents, _impl_.agents_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelResponseCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelResponseCache, _impl_.enable_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.platform_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.backend_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.runtime_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.version_policy_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.max_batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.output_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.batch_input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.batch_output_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.optimization_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.instance_group_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.default_model_filename_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.cc_model_filenames_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.metric_tags_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.model_warmup_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.model_operations_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.model_transaction_policy_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.model_repository_agents_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.response_cache_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _impl_.scheduling_choice_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::inference::ModelRateLimiter_Resource)},
  { 9, -1, -1, sizeof(::inference::ModelRateLimiter)},
  { 17, -1, -1, sizeof(::inference::ModelInstanceGroup_SecondaryDevice)},
  { 25, -1, -1, sizeof(::inference::ModelInstanceGroup)},
  { 40, -1, -1, sizeof(::inference::ModelTensorReshape)},
  { 47, -1, -1, sizeof(::inference::ModelInput)},
  { 61, -1, -1, sizeof(::inference::ModelOutput)},
  { 73, -1, -1, sizeof(::inference::BatchInput)},
  { 83, -1, -1, sizeof(::inference::BatchOutput)},
  { 92, -1, -1, sizeof(::inference::ModelVersionPolicy_Latest)},
  { 99, -1, -1, sizeof(::inference::ModelVersionPolicy_All)},
  { 105, -1, -1, sizeof(::inference::ModelVersionPolicy_Specific)},
  { 112, -1, -1, sizeof(::inference::ModelVersionPolicy)},
  { 122, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Graph)},
  { 129, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape)},
  { 136, 144, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse)},
  { 146, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound)},
  { 154, 162, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse)},
  { 164, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec)},
  { 173, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda)},
  { 183, 191, -1, sizeof(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse)},
  { 193, -1, -1, sizeof(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator)},
  { 201, -1, -1, sizeof(::inference::ModelOptimizationPolicy_ExecutionAccelerators)},
  { 209, -1, -1, sizeof(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer)},
  { 216, -1, -1, sizeof(::inference::ModelOptimizationPolicy)},
  { 230, -1, -1, sizeof(::inference::ModelQueuePolicy)},
  { 240, 248, -1, sizeof(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse)},
  { 250, -1, -1, sizeof(::inference::ModelDynamicBatching)},
  { 263, -1, -1, sizeof(::inference::ModelSequenceBatching_Control)},
  { 274, -1, -1, sizeof(::inference::ModelSequenceBatching_ControlInput)},
  { 282, -1, -1, sizeof(::inference::ModelSequenceBatching_InitialState)},
  { 294, -1, -1, sizeof(::inference::ModelSequenceBatching_State)},
  { 307, -1, -1, sizeof(::inference::ModelSequenceBatching_StrategyDirect)},
  { 315, -1, -1, sizeof(::inference::ModelSequenceBatching_StrategyOldest)},
  { 325, -1, -1, sizeof(::inference::ModelSequenceBatching)},
  { 338, 346, -1, sizeof(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse)},
  { 348, 356, -1, sizeof(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse)},
  { 358, -1, -1, sizeof(::inference::ModelEnsembling_Step)},
  { 369, -1, -1, sizeof(::inference::ModelEnsembling)},
  { 376, -1, -1, sizeof(::inference::ModelParameter)},
  { 383, -1, -1, sizeof(::inference::ModelWarmup_Input)},
  { 395, 403, -1, sizeof(::inference::ModelWarmup_InputsEntry_DoNotUse)},
  { 405, -1, -1, sizeof(::inference::ModelWarmup)},
  { 415, -1, -1, sizeof(::inference::ModelOperations)},
  { 422, -1, -1, sizeof(::inference::ModelTransactionPolicy)},
  { 429, 437, -1, sizeof(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse)},
  { 439, -1, -1, sizeof(::inference::ModelRepositoryAgents_Agent)},
  { 447, -1, -1, sizeof(::inference::ModelRepositoryAgents)},
  { 454, -1, -1, sizeof(::inference::ModelResponseCache)},
  { 461, 469, -1, sizeof(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse)},
  { 471, 479, -1, sizeof(::inference::ModelConfig_MetricTagsEntry_DoNotUse)},
  { 481, 489, -1, sizeof(::inference::ModelConfig_ParametersEntry_DoNotUse)},
  { 491, -1, -1, sizeof(::inference::ModelConfig)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::inference::_ModelRateLimiter_Resource_default_instance_._instance,
  &::inference::_ModelRateLimiter_default_instance_._instance,
  &::inference::_ModelInstanceGroup_SecondaryDevice_default_instance_._instance,
  &::inference::_ModelInstanceGroup_default_instance_._instance,
  &::inference::_ModelTensorReshape_default_instance_._instance,
  &::inference::_ModelInput_default_instance_._instance,
  &::inference::_ModelOutput_default_instance_._instance,
  &::inference::_BatchInput_default_instance_._instance,
  &::inference::_BatchOutput_default_instance_._instance,
  &::inference::_ModelVersionPolicy_Latest_default_instance_._instance,
  &::inference::_ModelVersionPolicy_All_default_instance_._instance,
  &::inference::_ModelVersionPolicy_Specific_default_instance_._instance,
  &::inference::_ModelVersionPolicy_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Graph_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_Cuda_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_ExecutionAccelerators_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_._instance,
  &::inference::_ModelOptimizationPolicy_default_instance_._instance,
  &::inference::_ModelQueuePolicy_default_instance_._instance,
  &::inference::_ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelDynamicBatching_default_instance_._instance,
  &::inference::_ModelSequenceBatching_Control_default_instance_._instance,
  &::inference::_ModelSequenceBatching_ControlInput_default_instance_._instance,
  &::inference::_ModelSequenceBatching_InitialState_default_instance_._instance,
  &::inference::_ModelSequenceBatching_State_default_instance_._instance,
  &::inference::_ModelSequenceBatching_StrategyDirect_default_instance_._instance,
  &::inference::_ModelSequenceBatching_StrategyOldest_default_instance_._instance,
  &::inference::_ModelSequenceBatching_default_instance_._instance,
  &::inference::_ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelEnsembling_Step_default_instance_._instance,
  &::inference::_ModelEnsembling_default_instance_._instance,
  &::inference::_ModelParameter_default_instance_._instance,
  &::inference::_ModelWarmup_Input_default_instance_._instance,
  &::inference::_ModelWarmup_InputsEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelWarmup_default_instance_._instance,
  &::inference::_ModelOperations_default_instance_._instance,
  &::inference::_ModelTransactionPolicy_default_instance_._instance,
  &::inference::_ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelRepositoryAgents_Agent_default_instance_._instance,
  &::inference::_ModelRepositoryAgents_default_instance_._instance,
  &::inference::_ModelResponseCache_default_instance_._instance,
  &::inference::_ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelConfig_MetricTagsEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelConfig_ParametersEntry_DoNotUse_default_instance_._instance,
  &::inference::_ModelConfig_default_instance_._instance,
};

const char descriptor_table_protodef_model_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022model_config.proto\022\tinference\"\226\001\n\020Mode"
  "lRateLimiter\0227\n\tresources\030\001 \003(\0132$.infere"
  "nce.ModelRateLimiter.Resource\022\020\n\010priorit"
  "y\030\002 \001(\r\0327\n\010Resource\022\014\n\004name\030\001 \001(\t\022\016\n\006glo"
  "bal\030\002 \001(\010\022\r\n\005count\030\003 \001(\r\"\207\004\n\022ModelInstan"
  "ceGroup\022\014\n\004name\030\001 \001(\t\0220\n\004kind\030\004 \001(\0162\".in"
  "ference.ModelInstanceGroup.Kind\022\r\n\005count"
  "\030\002 \001(\005\0221\n\014rate_limiter\030\006 \001(\0132\033.inference"
  ".ModelRateLimiter\022\014\n\004gpus\030\003 \003(\005\022H\n\021secon"
  "dary_devices\030\010 \003(\0132-.inference.ModelInst"
  "anceGroup.SecondaryDevice\022\017\n\007profile\030\005 \003"
  "(\t\022\017\n\007passive\030\007 \001(\010\022\023\n\013host_policy\030\t \001(\t"
  "\032\234\001\n\017SecondaryDevice\022O\n\004kind\030\001 \001(\0162A.inf"
  "erence.ModelInstanceGroup.SecondaryDevic"
  "e.SecondaryDeviceKind\022\021\n\tdevice_id\030\002 \001(\003"
  "\"%\n\023SecondaryDeviceKind\022\016\n\nKIND_NVDLA\020\000\""
  "A\n\004Kind\022\r\n\tKIND_AUTO\020\000\022\014\n\010KIND_GPU\020\001\022\014\n\010"
  "KIND_CPU\020\002\022\016\n\nKIND_MODEL\020\003\"#\n\022ModelTenso"
  "rReshape\022\r\n\005shape\030\001 \003(\003\"\262\002\n\nModelInput\022\014"
  "\n\004name\030\001 \001(\t\022&\n\tdata_type\030\002 \001(\0162\023.infere"
  "nce.DataType\022,\n\006format\030\003 \001(\0162\034.inference"
  ".ModelInput.Format\022\014\n\004dims\030\004 \003(\003\022.\n\007resh"
  "ape\030\005 \001(\0132\035.inference.ModelTensorReshape"
  "\022\027\n\017is_shape_tensor\030\006 \001(\010\022\032\n\022allow_ragge"
  "d_batch\030\007 \001(\010\022\020\n\010optional\030\010 \001(\010\";\n\006Forma"
  "t\022\017\n\013FORMAT_NONE\020\000\022\017\n\013FORMAT_NHWC\020\001\022\017\n\013F"
  "ORMAT_NCHW\020\002\"\262\001\n\013ModelOutput\022\014\n\004name\030\001 \001"
  "(\t\022&\n\tdata_type\030\002 \001(\0162\023.inference.DataTy"
  "pe\022\014\n\004dims\030\003 \003(\003\022.\n\007reshape\030\005 \001(\0132\035.infe"
  "rence.ModelTensorReshape\022\026\n\016label_filena"
  "me\030\004 \001(\t\022\027\n\017is_shape_tensor\030\006 \001(\010\"\331\002\n\nBa"
  "tchInput\022(\n\004kind\030\001 \001(\0162\032.inference.Batch"
  "Input.Kind\022\023\n\013target_name\030\002 \003(\t\022&\n\tdata_"
  "type\030\003 \001(\0162\023.inference.DataType\022\024\n\014sourc"
  "e_input\030\004 \003(\t\"\315\001\n\004Kind\022\027\n\023BATCH_ELEMENT_"
  "COUNT\020\000\022#\n\037BATCH_ACCUMULATED_ELEMENT_COU"
  "NT\020\001\022-\n)BATCH_ACCUMULATED_ELEMENT_COUNT_"
  "WITH_ZERO\020\002\022$\n BATCH_MAX_ELEMENT_COUNT_A"
  "S_SHAPE\020\003\022\024\n\020BATCH_ITEM_SHAPE\020\004\022\034\n\030BATCH"
  "_ITEM_SHAPE_FLATTEN\020\005\"\217\001\n\013BatchOutput\022\023\n"
  "\013target_name\030\001 \003(\t\022)\n\004kind\030\002 \001(\0162\033.infer"
  "ence.BatchOutput.Kind\022\024\n\014source_input\030\003 "
  "\003(\t\"*\n\004Kind\022\"\n\036BATCH_SCATTER_WITH_INPUT_"
  "SHAPE\020\000\"\220\002\n\022ModelVersionPolicy\0226\n\006latest"
  "\030\001 \001(\0132$.inference.ModelVersionPolicy.La"
  "testH\000\0220\n\003all\030\002 \001(\0132!.inference.ModelVer"
  "sionPolicy.AllH\000\022:\n\010specific\030\003 \001(\0132&.inf"
  "erence.ModelVersionPolicy.SpecificH\000\032\036\n\006"
  "Latest\022\024\n\014num_versions\030\001 \001(\r\032\005\n\003All\032\034\n\010S"
  "pecific\022\020\n\010versions\030\001 \003(\003B\017\n\rpolicy_choi"
  "ce\"\375\r\n\027ModelOptimizationPolicy\0227\n\005graph\030"
  "\001 \001(\0132(.inference.ModelOptimizationPolic"
  "y.Graph\022B\n\010priority\030\002 \001(\01620.inference.Mo"
  "delOptimizationPolicy.ModelPriority\0225\n\004c"
  "uda\030\003 \001(\0132\'.inference.ModelOptimizationP"
  "olicy.Cuda\022X\n\026execution_accelerators\030\004 \001"
  "(\01328.inference.ModelOptimizationPolicy.E"
  "xecutionAccelerators\022R\n\023input_pinned_mem"
  "ory\030\005 \001(\01325.inference.ModelOptimizationP"
  "olicy.PinnedMemoryBuffer\022S\n\024output_pinne"
  "d_memory\030\006 \001(\01325.inference.ModelOptimiza"
  "tionPolicy.PinnedMemoryBuffer\022&\n\036gather_"
  "kernel_buffer_threshold\030\007 \001(\r\022\026\n\016eager_b"
  "atching\030\010 \001(\010\032\026\n\005Graph\022\r\n\005level\030\001 \001(\005\032\272\005"
  "\n\004Cuda\022\016\n\006graphs\030\001 \001(\010\022\030\n\020busy_wait_even"
  "ts\030\002 \001(\010\022E\n\ngraph_spec\030\003 \003(\01321.inference"
  ".ModelOptimizationPolicy.Cuda.GraphSpec\022"
  "\032\n\022output_copy_stream\030\004 \001(\010\032\244\004\n\tGraphSpe"
  "c\022\022\n\nbatch_size\030\001 \001(\005\022K\n\005input\030\002 \003(\0132<.i"
  "nference.ModelOptimizationPolicy.Cuda.Gr"
  "aphSpec.InputEntry\022W\n\021graph_lower_bound\030"
  "\003 \001(\0132<.inference.ModelOptimizationPolic"
  "y.Cuda.GraphSpec.LowerBound\032\024\n\005Shape\022\013\n\003"
  "dim\030\001 \003(\003\032\337\001\n\nLowerBound\022\022\n\nbatch_size\030\001"
  " \001(\005\022V\n\005input\030\002 \003(\0132G.inference.ModelOpt"
  "imizationPolicy.Cuda.GraphSpec.LowerBoun"
  "d.InputEntry\032e\n\nInputEntry\022\013\n\003key\030\001 \001(\t\022"
  "F\n\005value\030\002 \001(\01327.inference.ModelOptimiza"
  "tionPolicy.Cuda.GraphSpec.Shape:\0028\001\032e\n\nI"
  "nputEntry\022\013\n\003key\030\001 \001(\t\022F\n\005value\030\002 \001(\01327."
  "inference.ModelOptimizationPolicy.Cuda.G"
  "raphSpec.Shape:\0028\001\032\244\003\n\025ExecutionAccelera"
  "tors\022g\n\031gpu_execution_accelerator\030\001 \003(\0132"
  "D.inference.ModelOptimizationPolicy.Exec"
  "utionAccelerators.Accelerator\022g\n\031cpu_exe"
  "cution_accelerator\030\002 \003(\0132D.inference.Mod"
  "elOptimizationPolicy.ExecutionAccelerato"
  "rs.Accelerator\032\270\001\n\013Accelerator\022\014\n\004name\030\001"
  " \001(\t\022h\n\nparameters\030\002 \003(\0132T.inference.Mod"
  "elOptimizationPolicy.ExecutionAccelerato"
  "rs.Accelerator.ParametersEntry\0321\n\017Parame"
  "tersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028"
  "\001\032$\n\022PinnedMemoryBuffer\022\016\n\006enable\030\001 \001(\010\""
  "I\n\rModelPriority\022\024\n\020PRIORITY_DEFAULT\020\000\022\020"
  "\n\014PRIORITY_MAX\020\001\022\020\n\014PRIORITY_MIN\020\002\"\333\001\n\020M"
  "odelQueuePolicy\022A\n\016timeout_action\030\001 \001(\0162"
  ").inference.ModelQueuePolicy.TimeoutActi"
  "on\022$\n\034default_timeout_microseconds\030\002 \001(\004"
  "\022\036\n\026allow_timeout_override\030\003 \001(\010\022\026\n\016max_"
  "queue_size\030\004 \001(\r\"&\n\rTimeoutAction\022\n\n\006REJ"
  "ECT\020\000\022\t\n\005DELAY\020\001\"\233\003\n\024ModelDynamicBatchin"
  "g\022\034\n\024preferred_batch_size\030\001 \003(\005\022$\n\034max_q"
  "ueue_delay_microseconds\030\002 \001(\004\022\031\n\021preserv"
  "e_ordering\030\003 \001(\010\022\027\n\017priority_levels\030\004 \001("
  "\004\022\036\n\026default_priority_level\030\005 \001(\004\0229\n\024def"
  "ault_queue_policy\030\006 \001(\0132\033.inference.Mode"
  "lQueuePolicy\022W\n\025priority_queue_policy\030\007 "
  "\003(\01328.inference.ModelDynamicBatching.Pri"
  "orityQueuePolicyEntry\032W\n\030PriorityQueuePo"
  "licyEntry\022\013\n\003key\030\001 \001(\004\022*\n\005value\030\002 \001(\0132\033."
  "inference.ModelQueuePolicy:\0028\001\"\356\n\n\025Model"
  "SequenceBatching\022A\n\006direct\030\003 \001(\0132/.infer"
  "ence.ModelSequenceBatching.StrategyDirec"
  "tH\000\022A\n\006oldest\030\004 \001(\0132/.inference.ModelSeq"
  "uenceBatching.StrategyOldestH\000\022&\n\036max_se"
  "quence_idle_microseconds\030\001 \001(\004\022D\n\rcontro"
  "l_input\030\002 \003(\0132-.inference.ModelSequenceB"
  "atching.ControlInput\0225\n\005state\030\005 \003(\0132&.in"
  "ference.ModelSequenceBatching.State\022\032\n\022i"
  "terative_sequence\030\006 \001(\010\032\261\002\n\007Control\022;\n\004k"
  "ind\030\001 \001(\0162-.inference.ModelSequenceBatch"
  "ing.Control.Kind\022\030\n\020int32_false_true\030\002 \003"
  "(\005\022\027\n\017fp32_false_true\030\003 \003(\002\022\027\n\017bool_fals"
  "e_true\030\005 \003(\010\022&\n\tdata_type\030\004 \001(\0162\023.infere"
  "nce.DataType\"u\n\004Kind\022\032\n\026CONTROL_SEQUENCE"
  "_START\020\000\022\032\n\026CONTROL_SEQUENCE_READY\020\001\022\030\n\024"
  "CONTROL_SEQUENCE_END\020\002\022\033\n\027CONTROL_SEQUEN"
  "CE_CORRID\020\003\032W\n\014ControlInput\022\014\n\004name\030\001 \001("
  "\t\0229\n\007control\030\002 \003(\0132(.inference.ModelSequ"
  "enceBatching.Control\032\212\001\n\014InitialState\022&\n"
  "\tdata_type\030\001 \001(\0162\023.inference.DataType\022\014\n"
  "\004dims\030\002 \003(\003\022\023\n\tzero_data\030\003 \001(\010H\000\022\023\n\tdata"
  "_file\030\004 \001(\tH\000\022\014\n\004name\030\005 \001(\tB\014\n\nstate_dat"
  "a\032\363\001\n\005State\022\022\n\ninput_name\030\001 \001(\t\022\023\n\013outpu"
  "t_name\030\002 \001(\t\022&\n\tdata_type\030\003 \001(\0162\023.infere"
  "nce.DataType\022\014\n\004dims\030\004 \003(\003\022D\n\rinitial_st"
  "ate\030\005 \003(\0132-.inference.ModelSequenceBatch"
  "ing.InitialState\022(\n use_same_buffer_for_"
  "input_output\030\006 \001(\010\022\033\n\023use_growable_memor"
  "y\030\007 \001(\010\032X\n\016StrategyDirect\022$\n\034max_queue_d"
  "elay_microseconds\030\001 \001(\004\022 \n\030minimum_slot_"
  "utilization\030\002 \001(\002\032\220\001\n\016StrategyOldest\022\037\n\027"
  "max_candidate_sequences\030\001 \001(\005\022\034\n\024preferr"
  "ed_batch_size\030\002 \003(\005\022$\n\034max_queue_delay_m"
  "icroseconds\030\003 \001(\004\022\031\n\021preserve_ordering\030\004"
  " \001(\010B\021\n\017strategy_choice\"\366\002\n\017ModelEnsembl"
  "ing\022-\n\004step\030\001 \003(\0132\037.inference.ModelEnsem"
  "bling.Step\032\263\002\n\004Step\022\022\n\nmodel_name\030\001 \001(\t\022"
  "\025\n\rmodel_version\030\002 \001(\003\022@\n\tinput_map\030\003 \003("
  "\0132-.inference.ModelEnsembling.Step.Input"
  "MapEntry\022B\n\noutput_map\030\004 \003(\0132..inference"
  ".ModelEnsembling.Step.OutputMapEntry\022\027\n\017"
  "model_namespace\030\005 \001(\t\032/\n\rInputMapEntry\022\013"
  "\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0320\n\016Output"
  "MapEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001"
  "\"&\n\016ModelParameter\022\024\n\014string_value\030\001 \001(\t"
  "\"\331\002\n\013ModelWarmup\022\014\n\004name\030\001 \001(\t\022\022\n\nbatch_"
  "size\030\002 \001(\r\0222\n\006inputs\030\003 \003(\0132\".inference.M"
  "odelWarmup.InputsEntry\022\r\n\005count\030\004 \001(\r\032\227\001"
  "\n\005Input\022&\n\tdata_type\030\001 \001(\0162\023.inference.D"
  "ataType\022\014\n\004dims\030\002 \003(\003\022\023\n\tzero_data\030\003 \001(\010"
  "H\000\022\025\n\013random_data\030\004 \001(\010H\000\022\031\n\017input_data_"
  "file\030\005 \001(\tH\000B\021\n\017input_data_type\032K\n\013Input"
  "sEntry\022\013\n\003key\030\001 \001(\t\022+\n\005value\030\002 \001(\0132\034.inf"
  "erence.ModelWarmup.Input:\0028\001\".\n\017ModelOpe"
  "rations\022\033\n\023op_library_filename\030\001 \003(\t\"+\n\026"
  "ModelTransactionPolicy\022\021\n\tdecoupled\030\001 \001("
  "\010\"\346\001\n\025ModelRepositoryAgents\0226\n\006agents\030\001 "
  "\003(\0132&.inference.ModelRepositoryAgents.Ag"
  "ent\032\224\001\n\005Agent\022\014\n\004name\030\001 \001(\t\022J\n\nparameter"
  "s\030\002 \003(\01326.inference.ModelRepositoryAgent"
  "s.Agent.ParametersEntry\0321\n\017ParametersEnt"
  "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"$\n\022Mo"
  "delResponseCache\022\016\n\006enable\030\001 \001(\010\"\303\n\n\013Mod"
  "elConfig\022\014\n\004name\030\001 \001(\t\022\020\n\010platform\030\002 \001(\t"
  "\022\017\n\007backend\030\021 \001(\t\022\017\n\007runtime\030\031 \001(\t\0225\n\016ve"
  "rsion_policy\030\003 \001(\0132\035.inference.ModelVers"
  "ionPolicy\022\026\n\016max_batch_size\030\004 \001(\005\022$\n\005inp"
  "ut\030\005 \003(\0132\025.inference.ModelInput\022&\n\006outpu"
  "t\030\006 \003(\0132\026.inference.ModelOutput\022*\n\013batch"
  "_input\030\024 \003(\0132\025.inference.BatchInput\022,\n\014b"
  "atch_output\030\025 \003(\0132\026.inference.BatchOutpu"
  "t\0228\n\014optimization\030\014 \001(\0132\".inference.Mode"
  "lOptimizationPolicy\022;\n\020dynamic_batching\030"
  "\013 \001(\0132\037.inference.ModelDynamicBatchingH\000"
  "\022=\n\021sequence_batching\030\r \001(\0132 .inference."
  "ModelSequenceBatchingH\000\0229\n\023ensemble_sche"
  "duling\030\017 \001(\0132\032.inference.ModelEnsembling"
  "H\000\0225\n\016instance_group\030\007 \003(\0132\035.inference.M"
  "odelInstanceGroup\022\036\n\026default_model_filen"
  "ame\030\010 \001(\t\022H\n\022cc_model_filenames\030\t \003(\0132,."
  "inference.ModelConfig.CcModelFilenamesEn"
  "try\022;\n\013metric_tags\030\n \003(\0132&.inference.Mod"
  "elConfig.MetricTagsEntry\022:\n\nparameters\030\016"
  " \003(\0132&.inference.ModelConfig.ParametersE"
  "ntry\022,\n\014model_warmup\030\020 \003(\0132\026.inference.M"
  "odelWarmup\0224\n\020model_operations\030\022 \001(\0132\032.i"
  "nference.ModelOperations\022C\n\030model_transa"
  "ction_policy\030\023 \001(\0132!.inference.ModelTran"
  "sactionPolicy\022A\n\027model_repository_agents"
  "\030\027 \001(\0132 .inference.ModelRepositoryAgents"
  "\0225\n\016response_cache\030\030 \001(\0132\035.inference.Mod"
  "elResponseCache\0327\n\025CcModelFilenamesEntry"
  "\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0321\n\017Metr"
  "icTagsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
  "\0028\001\032L\n\017ParametersEntry\022\013\n\003key\030\001 \001(\t\022(\n\005v"
  "alue\030\002 \001(\0132\031.inference.ModelParameter:\0028"
  "\001B\023\n\021scheduling_choice*\372\001\n\010DataType\022\020\n\014T"
  "YPE_INVALID\020\000\022\r\n\tTYPE_BOOL\020\001\022\016\n\nTYPE_UIN"
  "T8\020\002\022\017\n\013TYPE_UINT16\020\003\022\017\n\013TYPE_UINT32\020\004\022\017"
  "\n\013TYPE_UINT64\020\005\022\r\n\tTYPE_INT8\020\006\022\016\n\nTYPE_I"
  "NT16\020\007\022\016\n\nTYPE_INT32\020\010\022\016\n\nTYPE_INT64\020\t\022\r"
  "\n\tTYPE_FP16\020\n\022\r\n\tTYPE_FP32\020\013\022\r\n\tTYPE_FP6"
  "4\020\014\022\017\n\013TYPE_STRING\020\r\022\r\n\tTYPE_BF16\020\016b\006pro"
  "to3"
  ;
static ::_pbi::once_flag descriptor_table_model_5fconfig_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_model_5fconfig_2eproto = {
    false, false, 8563, descriptor_table_protodef_model_5fconfig_2eproto,
    "model_config.proto",
    &descriptor_table_model_5fconfig_2eproto_once, nullptr, 0, 53,
    schemas, file_default_instances, TableStruct_model_5fconfig_2eproto::offsets,
    file_level_metadata_model_5fconfig_2eproto, file_level_enum_descriptors_model_5fconfig_2eproto,
    file_level_service_descriptors_model_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_model_5fconfig_2eproto_getter() {
  return &descriptor_table_model_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_model_5fconfig_2eproto(&descriptor_table_model_5fconfig_2eproto);
namespace inference {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[0];
}
bool ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::KIND_NVDLA;
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::SecondaryDeviceKind_MIN;
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::SecondaryDeviceKind_MAX;
constexpr int ModelInstanceGroup_SecondaryDevice::SecondaryDeviceKind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[1];
}
bool ModelInstanceGroup_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_AUTO;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_GPU;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_CPU;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_MODEL;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::Kind_MIN;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::Kind_MAX;
constexpr int ModelInstanceGroup::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInput_Format_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[2];
}
bool ModelInput_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelInput_Format ModelInput::FORMAT_NONE;
constexpr ModelInput_Format ModelInput::FORMAT_NHWC;
constexpr ModelInput_Format ModelInput::FORMAT_NCHW;
constexpr ModelInput_Format ModelInput::Format_MIN;
constexpr ModelInput_Format ModelInput::Format_MAX;
constexpr int ModelInput::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchInput_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[3];
}
bool BatchInput_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BatchInput_Kind BatchInput::BATCH_ELEMENT_COUNT;
constexpr BatchInput_Kind BatchInput::BATCH_ACCUMULATED_ELEMENT_COUNT;
constexpr BatchInput_Kind BatchInput::BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO;
constexpr BatchInput_Kind BatchInput::BATCH_MAX_ELEMENT_COUNT_AS_SHAPE;
constexpr BatchInput_Kind BatchInput::BATCH_ITEM_SHAPE;
constexpr BatchInput_Kind BatchInput::BATCH_ITEM_SHAPE_FLATTEN;
constexpr BatchInput_Kind BatchInput::Kind_MIN;
constexpr BatchInput_Kind BatchInput::Kind_MAX;
constexpr int BatchInput::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchOutput_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[4];
}
bool BatchOutput_Kind_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BatchOutput_Kind BatchOutput::BATCH_SCATTER_WITH_INPUT_SHAPE;
constexpr BatchOutput_Kind BatchOutput::Kind_MIN;
constexpr BatchOutput_Kind BatchOutput::Kind_MAX;
constexpr int BatchOutput::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelOptimizationPolicy_ModelPriority_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[5];
}
bool ModelOptimizationPolicy_ModelPriority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::PRIORITY_DEFAULT;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::PRIORITY_MAX;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::PRIORITY_MIN;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::ModelPriority_MIN;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::ModelPriority_MAX;
constexpr int ModelOptimizationPolicy::ModelPriority_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelQueuePolicy_TimeoutAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[6];
}
bool ModelQueuePolicy_TimeoutAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::REJECT;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::DELAY;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::TimeoutAction_MIN;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::TimeoutAction_MAX;
constexpr int ModelQueuePolicy::TimeoutAction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelSequenceBatching_Control_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[7];
}
bool ModelSequenceBatching_Control_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_START;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_READY;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_END;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_CORRID;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::Kind_MIN;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::Kind_MAX;
constexpr int ModelSequenceBatching_Control::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[8];
}
bool DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ModelRateLimiter_Resource::_Internal {
 public:
};

ModelRateLimiter_Resource::ModelRateLimiter_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelRateLimiter.Resource)
}
ModelRateLimiter_Resource::ModelRateLimiter_Resource(const ModelRateLimiter_Resource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelRateLimiter_Resource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.global_){}
    , decltype(_impl_.count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.global_, &from._impl_.global_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.global_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelRateLimiter.Resource)
}

inline void ModelRateLimiter_Resource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.global_){false}
    , decltype(_impl_.count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelRateLimiter_Resource::~ModelRateLimiter_Resource() {
  // @@protoc_insertion_point(destructor:inference.ModelRateLimiter.Resource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelRateLimiter_Resource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ModelRateLimiter_Resource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelRateLimiter_Resource::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRateLimiter.Resource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.global_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.global_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRateLimiter_Resource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelRateLimiter.Resource.name"));
        } else
          goto handle_unusual;
        continue;
      // bool global = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.global_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRateLimiter_Resource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRateLimiter.Resource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelRateLimiter.Resource.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool global = 2;
  if (this->_internal_global() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_global(), target);
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRateLimiter.Resource)
  return target;
}

size_t ModelRateLimiter_Resource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRateLimiter.Resource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool global = 2;
  if (this->_internal_global() != 0) {
    total_size += 1 + 1;
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRateLimiter_Resource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelRateLimiter_Resource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRateLimiter_Resource::GetClassData() const { return &_class_data_; }


void ModelRateLimiter_Resource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelRateLimiter_Resource*>(&to_msg);
  auto& from = static_cast<const ModelRateLimiter_Resource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRateLimiter.Resource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_global() != 0) {
    _this->_internal_set_global(from._internal_global());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRateLimiter_Resource::CopyFrom(const ModelRateLimiter_Resource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRateLimiter.Resource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRateLimiter_Resource::IsInitialized() const {
  return true;
}

void ModelRateLimiter_Resource::InternalSwap(ModelRateLimiter_Resource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelRateLimiter_Resource, _impl_.count_)
      + sizeof(ModelRateLimiter_Resource::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(ModelRateLimiter_Resource, _impl_.global_)>(
          reinterpret_cast<char*>(&_impl_.global_),
          reinterpret_cast<char*>(&other->_impl_.global_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRateLimiter_Resource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[0]);
}

// ===================================================================

class ModelRateLimiter::_Internal {
 public:
};

ModelRateLimiter::ModelRateLimiter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelRateLimiter)
}
ModelRateLimiter::ModelRateLimiter(const ModelRateLimiter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelRateLimiter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.resources_){from._impl_.resources_}
    , decltype(_impl_.priority_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.priority_ = from._impl_.priority_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelRateLimiter)
}

inline void ModelRateLimiter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.resources_){arena}
    , decltype(_impl_.priority_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelRateLimiter::~ModelRateLimiter() {
  // @@protoc_insertion_point(destructor:inference.ModelRateLimiter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelRateLimiter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resources_.~RepeatedPtrField();
}

void ModelRateLimiter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelRateLimiter::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRateLimiter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resources_.Clear();
  _impl_.priority_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRateLimiter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelRateLimiter.Resource resources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRateLimiter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRateLimiter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelRateLimiter.Resource resources = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
    const auto& repfield = this->_internal_resources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 priority = 2;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRateLimiter)
  return target;
}

size_t ModelRateLimiter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRateLimiter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelRateLimiter.Resource resources = 1;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->_impl_.resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 priority = 2;
  if (this->_internal_priority() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRateLimiter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelRateLimiter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRateLimiter::GetClassData() const { return &_class_data_; }


void ModelRateLimiter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelRateLimiter*>(&to_msg);
  auto& from = static_cast<const ModelRateLimiter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRateLimiter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.resources_.MergeFrom(from._impl_.resources_);
  if (from._internal_priority() != 0) {
    _this->_internal_set_priority(from._internal_priority());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRateLimiter::CopyFrom(const ModelRateLimiter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRateLimiter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRateLimiter::IsInitialized() const {
  return true;
}

void ModelRateLimiter::InternalSwap(ModelRateLimiter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.resources_.InternalSwap(&other->_impl_.resources_);
  swap(_impl_.priority_, other->_impl_.priority_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRateLimiter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[1]);
}

// ===================================================================

class ModelInstanceGroup_SecondaryDevice::_Internal {
 public:
};

ModelInstanceGroup_SecondaryDevice::ModelInstanceGroup_SecondaryDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelInstanceGroup.SecondaryDevice)
}
ModelInstanceGroup_SecondaryDevice::ModelInstanceGroup_SecondaryDevice(const ModelInstanceGroup_SecondaryDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelInstanceGroup_SecondaryDevice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_id_){}
    , decltype(_impl_.kind_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.device_id_, &from._impl_.device_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kind_) -
    reinterpret_cast<char*>(&_impl_.device_id_)) + sizeof(_impl_.kind_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelInstanceGroup.SecondaryDevice)
}

inline void ModelInstanceGroup_SecondaryDevice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_id_){int64_t{0}}
    , decltype(_impl_.kind_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelInstanceGroup_SecondaryDevice::~ModelInstanceGroup_SecondaryDevice() {
  // @@protoc_insertion_point(destructor:inference.ModelInstanceGroup.SecondaryDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelInstanceGroup_SecondaryDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelInstanceGroup_SecondaryDevice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelInstanceGroup_SecondaryDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelInstanceGroup.SecondaryDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.device_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.kind_) -
      reinterpret_cast<char*>(&_impl_.device_id_)) + sizeof(_impl_.kind_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInstanceGroup_SecondaryDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInstanceGroup_SecondaryDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelInstanceGroup.SecondaryDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // int64 device_id = 2;
  if (this->_internal_device_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelInstanceGroup.SecondaryDevice)
  return target;
}

size_t ModelInstanceGroup_SecondaryDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelInstanceGroup.SecondaryDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 device_id = 2;
  if (this->_internal_device_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_id());
  }

  // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInstanceGroup_SecondaryDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelInstanceGroup_SecondaryDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInstanceGroup_SecondaryDevice::GetClassData() const { return &_class_data_; }


void ModelInstanceGroup_SecondaryDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelInstanceGroup_SecondaryDevice*>(&to_msg);
  auto& from = static_cast<const ModelInstanceGroup_SecondaryDevice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelInstanceGroup.SecondaryDevice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_device_id() != 0) {
    _this->_internal_set_device_id(from._internal_device_id());
  }
  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInstanceGroup_SecondaryDevice::CopyFrom(const ModelInstanceGroup_SecondaryDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelInstanceGroup.SecondaryDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInstanceGroup_SecondaryDevice::IsInitialized() const {
  return true;
}

void ModelInstanceGroup_SecondaryDevice::InternalSwap(ModelInstanceGroup_SecondaryDevice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInstanceGroup_SecondaryDevice, _impl_.kind_)
      + sizeof(ModelInstanceGroup_SecondaryDevice::_impl_.kind_)
      - PROTOBUF_FIELD_OFFSET(ModelInstanceGroup_SecondaryDevice, _impl_.device_id_)>(
          reinterpret_cast<char*>(&_impl_.device_id_),
          reinterpret_cast<char*>(&other->_impl_.device_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInstanceGroup_SecondaryDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[2]);
}

// ===================================================================

class ModelInstanceGroup::_Internal {
 public:
  static const ::inference::ModelRateLimiter& rate_limiter(const ModelInstanceGroup* msg);
};

const ::inference::ModelRateLimiter&
ModelInstanceGroup::_Internal::rate_limiter(const ModelInstanceGroup* msg) {
  return *msg->_impl_.rate_limiter_;
}
ModelInstanceGroup::ModelInstanceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelInstanceGroup)
}
ModelInstanceGroup::ModelInstanceGroup(const ModelInstanceGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelInstanceGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gpus_){from._impl_.gpus_}
    , /*decltype(_impl_._gpus_cached_byte_size_)*/{0}
    , decltype(_impl_.profile_){from._impl_.profile_}
    , decltype(_impl_.secondary_devices_){from._impl_.secondary_devices_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.host_policy_){}
    , decltype(_impl_.rate_limiter_){nullptr}
    , decltype(_impl_.count_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.passive_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.host_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host_policy().empty()) {
    _this->_impl_.host_policy_.Set(from._internal_host_policy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_rate_limiter()) {
    _this->_impl_.rate_limiter_ = new ::inference::ModelRateLimiter(*from._impl_.rate_limiter_);
  }
  ::memcpy(&_impl_.count_, &from._impl_.count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.passive_) -
    reinterpret_cast<char*>(&_impl_.count_)) + sizeof(_impl_.passive_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelInstanceGroup)
}

inline void ModelInstanceGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gpus_){arena}
    , /*decltype(_impl_._gpus_cached_byte_size_)*/{0}
    , decltype(_impl_.profile_){arena}
    , decltype(_impl_.secondary_devices_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.host_policy_){}
    , decltype(_impl_.rate_limiter_){nullptr}
    , decltype(_impl_.count_){0}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.passive_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelInstanceGroup::~ModelInstanceGroup() {
  // @@protoc_insertion_point(destructor:inference.ModelInstanceGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelInstanceGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gpus_.~RepeatedField();
  _impl_.profile_.~RepeatedPtrField();
  _impl_.secondary_devices_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.host_policy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.rate_limiter_;
}

void ModelInstanceGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelInstanceGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelInstanceGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gpus_.Clear();
  _impl_.profile_.Clear();
  _impl_.secondary_devices_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.host_policy_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.rate_limiter_ != nullptr) {
    delete _impl_.rate_limiter_;
  }
  _impl_.rate_limiter_ = nullptr;
  ::memset(&_impl_.count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.passive_) -
      reinterpret_cast<char*>(&_impl_.count_)) + sizeof(_impl_.passive_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInstanceGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelInstanceGroup.name"));
        } else
          goto handle_unusual;
        continue;
      // int32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 gpus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_gpus(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_gpus(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelInstanceGroup.Kind kind = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::ModelInstanceGroup_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string profile = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_profile();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "inference.ModelInstanceGroup.profile"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelRateLimiter rate_limiter = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rate_limiter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool passive = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.passive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_secondary_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string host_policy = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_host_policy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelInstanceGroup.host_policy"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInstanceGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelInstanceGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInstanceGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // int32 count = 2;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_count(), target);
  }

  // repeated int32 gpus = 3;
  {
    int byte_size = _impl_._gpus_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_gpus(), byte_size, target);
    }
  }

  // .inference.ModelInstanceGroup.Kind kind = 4;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_kind(), target);
  }

  // repeated string profile = 5;
  for (int i = 0, n = this->_internal_profile_size(); i < n; i++) {
    const auto& s = this->_internal_profile(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInstanceGroup.profile");
    target = stream->WriteString(5, s, target);
  }

  // .inference.ModelRateLimiter rate_limiter = 6;
  if (this->_internal_has_rate_limiter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::rate_limiter(this),
        _Internal::rate_limiter(this).GetCachedSize(), target, stream);
  }

  // bool passive = 7;
  if (this->_internal_passive() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_passive(), target);
  }

  // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_secondary_devices_size()); i < n; i++) {
    const auto& repfield = this->_internal_secondary_devices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string host_policy = 9;
  if (!this->_internal_host_policy().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host_policy().data(), static_cast<int>(this->_internal_host_policy().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInstanceGroup.host_policy");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_host_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelInstanceGroup)
  return target;
}

size_t ModelInstanceGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelInstanceGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 gpus = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.gpus_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._gpus_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated string profile = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.profile_.size());
  for (int i = 0, n = _impl_.profile_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.profile_.Get(i));
  }

  // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
  total_size += 1UL * this->_internal_secondary_devices_size();
  for (const auto& msg : this->_impl_.secondary_devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string host_policy = 9;
  if (!this->_internal_host_policy().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host_policy());
  }

  // .inference.ModelRateLimiter rate_limiter = 6;
  if (this->_internal_has_rate_limiter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rate_limiter_);
  }

  // int32 count = 2;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  // .inference.ModelInstanceGroup.Kind kind = 4;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // bool passive = 7;
  if (this->_internal_passive() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInstanceGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelInstanceGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInstanceGroup::GetClassData() const { return &_class_data_; }


void ModelInstanceGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelInstanceGroup*>(&to_msg);
  auto& from = static_cast<const ModelInstanceGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelInstanceGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gpus_.MergeFrom(from._impl_.gpus_);
  _this->_impl_.profile_.MergeFrom(from._impl_.profile_);
  _this->_impl_.secondary_devices_.MergeFrom(from._impl_.secondary_devices_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_host_policy().empty()) {
    _this->_internal_set_host_policy(from._internal_host_policy());
  }
  if (from._internal_has_rate_limiter()) {
    _this->_internal_mutable_rate_limiter()->::inference::ModelRateLimiter::MergeFrom(
        from._internal_rate_limiter());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  if (from._internal_passive() != 0) {
    _this->_internal_set_passive(from._internal_passive());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInstanceGroup::CopyFrom(const ModelInstanceGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelInstanceGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInstanceGroup::IsInitialized() const {
  return true;
}

void ModelInstanceGroup::InternalSwap(ModelInstanceGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gpus_.InternalSwap(&other->_impl_.gpus_);
  _impl_.profile_.InternalSwap(&other->_impl_.profile_);
  _impl_.secondary_devices_.InternalSwap(&other->_impl_.secondary_devices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_policy_, lhs_arena,
      &other->_impl_.host_policy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInstanceGroup, _impl_.passive_)
      + sizeof(ModelInstanceGroup::_impl_.passive_)
      - PROTOBUF_FIELD_OFFSET(ModelInstanceGroup, _impl_.rate_limiter_)>(
          reinterpret_cast<char*>(&_impl_.rate_limiter_),
          reinterpret_cast<char*>(&other->_impl_.rate_limiter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInstanceGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[3]);
}

// ===================================================================

class ModelTensorReshape::_Internal {
 public:
};

ModelTensorReshape::ModelTensorReshape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelTensorReshape)
}
ModelTensorReshape::ModelTensorReshape(const ModelTensorReshape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelTensorReshape* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shape_){from._impl_.shape_}
    , /*decltype(_impl_._shape_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelTensorReshape)
}

inline void ModelTensorReshape::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shape_){arena}
    , /*decltype(_impl_._shape_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelTensorReshape::~ModelTensorReshape() {
  // @@protoc_insertion_point(destructor:inference.ModelTensorReshape)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelTensorReshape::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shape_.~RepeatedField();
}

void ModelTensorReshape::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelTensorReshape::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelTensorReshape)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shape_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelTensorReshape::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelTensorReshape::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelTensorReshape)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    int byte_size = _impl_._shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelTensorReshape)
  return target;
}

size_t ModelTensorReshape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelTensorReshape)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelTensorReshape::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelTensorReshape::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelTensorReshape::GetClassData() const { return &_class_data_; }


void ModelTensorReshape::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelTensorReshape*>(&to_msg);
  auto& from = static_cast<const ModelTensorReshape&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelTensorReshape)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.shape_.MergeFrom(from._impl_.shape_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelTensorReshape::CopyFrom(const ModelTensorReshape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelTensorReshape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelTensorReshape::IsInitialized() const {
  return true;
}

void ModelTensorReshape::InternalSwap(ModelTensorReshape* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.shape_.InternalSwap(&other->_impl_.shape_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelTensorReshape::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[4]);
}

// ===================================================================

class ModelInput::_Internal {
 public:
  static const ::inference::ModelTensorReshape& reshape(const ModelInput* msg);
};

const ::inference::ModelTensorReshape&
ModelInput::_Internal::reshape(const ModelInput* msg) {
  return *msg->_impl_.reshape_;
}
ModelInput::ModelInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelInput)
}
ModelInput::ModelInput(const ModelInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){from._impl_.dims_}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.reshape_){nullptr}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.is_shape_tensor_){}
    , decltype(_impl_.allow_ragged_batch_){}
    , decltype(_impl_.optional_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_reshape()) {
    _this->_impl_.reshape_ = new ::inference::ModelTensorReshape(*from._impl_.reshape_);
  }
  ::memcpy(&_impl_.data_type_, &from._impl_.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.optional_) -
    reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.optional_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelInput)
}

inline void ModelInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){arena}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.reshape_){nullptr}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.is_shape_tensor_){false}
    , decltype(_impl_.allow_ragged_batch_){false}
    , decltype(_impl_.optional_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelInput::~ModelInput() {
  // @@protoc_insertion_point(destructor:inference.ModelInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dims_.~RepeatedField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.reshape_;
}

void ModelInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelInput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dims_.Clear();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.reshape_ != nullptr) {
    delete _impl_.reshape_;
  }
  _impl_.reshape_ = nullptr;
  ::memset(&_impl_.data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.optional_) -
      reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.optional_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelInput.name"));
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelInput.Format format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_format(static_cast<::inference::ModelInput_Format>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelTensorReshape reshape = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_shape_tensor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_shape_tensor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_ragged_batch = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.allow_ragged_batch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool optional = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInput.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // .inference.ModelInput.Format format = 3;
  if (this->_internal_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_format(), target);
  }

  // repeated int64 dims = 4;
  {
    int byte_size = _impl_._dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_dims(), byte_size, target);
    }
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::reshape(this),
        _Internal::reshape(this).GetCachedSize(), target, stream);
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_shape_tensor(), target);
  }

  // bool allow_ragged_batch = 7;
  if (this->_internal_allow_ragged_batch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_ragged_batch(), target);
  }

  // bool optional = 8;
  if (this->_internal_optional() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelInput)
  return target;
}

size_t ModelInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reshape_);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // .inference.ModelInput.Format format = 3;
  if (this->_internal_format() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_ragged_batch = 7;
  if (this->_internal_allow_ragged_batch() != 0) {
    total_size += 1 + 1;
  }

  // bool optional = 8;
  if (this->_internal_optional() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInput::GetClassData() const { return &_class_data_; }


void ModelInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelInput*>(&to_msg);
  auto& from = static_cast<const ModelInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dims_.MergeFrom(from._impl_.dims_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_reshape()) {
    _this->_internal_mutable_reshape()->::inference::ModelTensorReshape::MergeFrom(
        from._internal_reshape());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_format() != 0) {
    _this->_internal_set_format(from._internal_format());
  }
  if (from._internal_is_shape_tensor() != 0) {
    _this->_internal_set_is_shape_tensor(from._internal_is_shape_tensor());
  }
  if (from._internal_allow_ragged_batch() != 0) {
    _this->_internal_set_allow_ragged_batch(from._internal_allow_ragged_batch());
  }
  if (from._internal_optional() != 0) {
    _this->_internal_set_optional(from._internal_optional());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInput::CopyFrom(const ModelInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInput::IsInitialized() const {
  return true;
}

void ModelInput::InternalSwap(ModelInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dims_.InternalSwap(&other->_impl_.dims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInput, _impl_.optional_)
      + sizeof(ModelInput::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(ModelInput, _impl_.reshape_)>(
          reinterpret_cast<char*>(&_impl_.reshape_),
          reinterpret_cast<char*>(&other->_impl_.reshape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[5]);
}

// ===================================================================

class ModelOutput::_Internal {
 public:
  static const ::inference::ModelTensorReshape& reshape(const ModelOutput* msg);
};

const ::inference::ModelTensorReshape&
ModelOutput::_Internal::reshape(const ModelOutput* msg) {
  return *msg->_impl_.reshape_;
}
ModelOutput::ModelOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOutput)
}
ModelOutput::ModelOutput(const ModelOutput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOutput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){from._impl_.dims_}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.label_filename_){}
    , decltype(_impl_.reshape_){nullptr}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.is_shape_tensor_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.label_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_label_filename().empty()) {
    _this->_impl_.label_filename_.Set(from._internal_label_filename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_reshape()) {
    _this->_impl_.reshape_ = new ::inference::ModelTensorReshape(*from._impl_.reshape_);
  }
  ::memcpy(&_impl_.data_type_, &from._impl_.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_shape_tensor_) -
    reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.is_shape_tensor_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelOutput)
}

inline void ModelOutput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){arena}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.label_filename_){}
    , decltype(_impl_.reshape_){nullptr}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.is_shape_tensor_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelOutput::~ModelOutput() {
  // @@protoc_insertion_point(destructor:inference.ModelOutput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOutput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dims_.~RepeatedField();
  _impl_.name_.Destroy();
  _impl_.label_filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.reshape_;
}

void ModelOutput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOutput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOutput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dims_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.label_filename_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.reshape_ != nullptr) {
    delete _impl_.reshape_;
  }
  _impl_.reshape_ = nullptr;
  ::memset(&_impl_.data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_shape_tensor_) -
      reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.is_shape_tensor_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOutput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelOutput.name"));
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string label_filename = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_label_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelOutput.label_filename"));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelTensorReshape reshape = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_shape_tensor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_shape_tensor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOutput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOutput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOutput.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 3;
  {
    int byte_size = _impl_._dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_dims(), byte_size, target);
    }
  }

  // string label_filename = 4;
  if (!this->_internal_label_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_label_filename().data(), static_cast<int>(this->_internal_label_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOutput.label_filename");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_label_filename(), target);
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::reshape(this),
        _Internal::reshape(this).GetCachedSize(), target, stream);
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_shape_tensor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOutput)
  return target;
}

size_t ModelOutput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOutput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string label_filename = 4;
  if (!this->_internal_label_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label_filename());
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reshape_);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOutput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOutput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOutput::GetClassData() const { return &_class_data_; }


void ModelOutput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOutput*>(&to_msg);
  auto& from = static_cast<const ModelOutput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOutput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dims_.MergeFrom(from._impl_.dims_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_label_filename().empty()) {
    _this->_internal_set_label_filename(from._internal_label_filename());
  }
  if (from._internal_has_reshape()) {
    _this->_internal_mutable_reshape()->::inference::ModelTensorReshape::MergeFrom(
        from._internal_reshape());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_is_shape_tensor() != 0) {
    _this->_internal_set_is_shape_tensor(from._internal_is_shape_tensor());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOutput::CopyFrom(const ModelOutput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOutput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOutput::IsInitialized() const {
  return true;
}

void ModelOutput::InternalSwap(ModelOutput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dims_.InternalSwap(&other->_impl_.dims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_filename_, lhs_arena,
      &other->_impl_.label_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOutput, _impl_.is_shape_tensor_)
      + sizeof(ModelOutput::_impl_.is_shape_tensor_)
      - PROTOBUF_FIELD_OFFSET(ModelOutput, _impl_.reshape_)>(
          reinterpret_cast<char*>(&_impl_.reshape_),
          reinterpret_cast<char*>(&other->_impl_.reshape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOutput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[6]);
}

// ===================================================================

class BatchInput::_Internal {
 public:
};

BatchInput::BatchInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.BatchInput)
}
BatchInput::BatchInput(const BatchInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_name_){from._impl_.target_name_}
    , decltype(_impl_.source_input_){from._impl_.source_input_}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.data_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.kind_, &from._impl_.kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.data_type_) -
    reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.data_type_));
  // @@protoc_insertion_point(copy_constructor:inference.BatchInput)
}

inline void BatchInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_name_){arena}
    , decltype(_impl_.source_input_){arena}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.data_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchInput::~BatchInput() {
  // @@protoc_insertion_point(destructor:inference.BatchInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.target_name_.~RepeatedPtrField();
  _impl_.source_input_.~RepeatedPtrField();
}

void BatchInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchInput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.BatchInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.target_name_.Clear();
  _impl_.source_input_.Clear();
  ::memset(&_impl_.kind_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.data_type_) -
      reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.data_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.BatchInput.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::BatchInput_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string target_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_target_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "inference.BatchInput.target_name"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string source_input = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_source_input();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "inference.BatchInput.source_input"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.BatchInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.BatchInput.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // repeated string target_name = 2;
  for (int i = 0, n = this->_internal_target_name_size(); i < n; i++) {
    const auto& s = this->_internal_target_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchInput.target_name");
    target = stream->WriteString(2, s, target);
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_data_type(), target);
  }

  // repeated string source_input = 4;
  for (int i = 0, n = this->_internal_source_input_size(); i < n; i++) {
    const auto& s = this->_internal_source_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchInput.source_input");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.BatchInput)
  return target;
}

size_t BatchInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.BatchInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string target_name = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.target_name_.size());
  for (int i = 0, n = _impl_.target_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.target_name_.Get(i));
  }

  // repeated string source_input = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.source_input_.size());
  for (int i = 0, n = _impl_.source_input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.source_input_.Get(i));
  }

  // .inference.BatchInput.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchInput::GetClassData() const { return &_class_data_; }


void BatchInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchInput*>(&to_msg);
  auto& from = static_cast<const BatchInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.BatchInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.target_name_.MergeFrom(from._impl_.target_name_);
  _this->_impl_.source_input_.MergeFrom(from._impl_.source_input_);
  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchInput::CopyFrom(const BatchInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.BatchInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchInput::IsInitialized() const {
  return true;
}

void BatchInput::InternalSwap(BatchInput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.target_name_.InternalSwap(&other->_impl_.target_name_);
  _impl_.source_input_.InternalSwap(&other->_impl_.source_input_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchInput, _impl_.data_type_)
      + sizeof(BatchInput::_impl_.data_type_)
      - PROTOBUF_FIELD_OFFSET(BatchInput, _impl_.kind_)>(
          reinterpret_cast<char*>(&_impl_.kind_),
          reinterpret_cast<char*>(&other->_impl_.kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[7]);
}

// ===================================================================

class BatchOutput::_Internal {
 public:
};

BatchOutput::BatchOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.BatchOutput)
}
BatchOutput::BatchOutput(const BatchOutput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchOutput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_name_){from._impl_.target_name_}
    , decltype(_impl_.source_input_){from._impl_.source_input_}
    , decltype(_impl_.kind_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.kind_ = from._impl_.kind_;
  // @@protoc_insertion_point(copy_constructor:inference.BatchOutput)
}

inline void BatchOutput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_name_){arena}
    , decltype(_impl_.source_input_){arena}
    , decltype(_impl_.kind_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchOutput::~BatchOutput() {
  // @@protoc_insertion_point(destructor:inference.BatchOutput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchOutput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.target_name_.~RepeatedPtrField();
  _impl_.source_input_.~RepeatedPtrField();
}

void BatchOutput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchOutput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.BatchOutput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.target_name_.Clear();
  _impl_.source_input_.Clear();
  _impl_.kind_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchOutput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string target_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_target_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "inference.BatchOutput.target_name"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.BatchOutput.Kind kind = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::BatchOutput_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string source_input = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_source_input();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "inference.BatchOutput.source_input"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchOutput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.BatchOutput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string target_name = 1;
  for (int i = 0, n = this->_internal_target_name_size(); i < n; i++) {
    const auto& s = this->_internal_target_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchOutput.target_name");
    target = stream->WriteString(1, s, target);
  }

  // .inference.BatchOutput.Kind kind = 2;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_kind(), target);
  }

  // repeated string source_input = 3;
  for (int i = 0, n = this->_internal_source_input_size(); i < n; i++) {
    const auto& s = this->_internal_source_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchOutput.source_input");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.BatchOutput)
  return target;
}

size_t BatchOutput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.BatchOutput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string target_name = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.target_name_.size());
  for (int i = 0, n = _impl_.target_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.target_name_.Get(i));
  }

  // repeated string source_input = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.source_input_.size());
  for (int i = 0, n = _impl_.source_input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.source_input_.Get(i));
  }

  // .inference.BatchOutput.Kind kind = 2;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchOutput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchOutput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchOutput::GetClassData() const { return &_class_data_; }


void BatchOutput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchOutput*>(&to_msg);
  auto& from = static_cast<const BatchOutput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.BatchOutput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.target_name_.MergeFrom(from._impl_.target_name_);
  _this->_impl_.source_input_.MergeFrom(from._impl_.source_input_);
  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchOutput::CopyFrom(const BatchOutput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.BatchOutput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchOutput::IsInitialized() const {
  return true;
}

void BatchOutput::InternalSwap(BatchOutput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.target_name_.InternalSwap(&other->_impl_.target_name_);
  _impl_.source_input_.InternalSwap(&other->_impl_.source_input_);
  swap(_impl_.kind_, other->_impl_.kind_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchOutput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[8]);
}

// ===================================================================

class ModelVersionPolicy_Latest::_Internal {
 public:
};

ModelVersionPolicy_Latest::ModelVersionPolicy_Latest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy.Latest)
}
ModelVersionPolicy_Latest::ModelVersionPolicy_Latest(const ModelVersionPolicy_Latest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelVersionPolicy_Latest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.num_versions_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.num_versions_ = from._impl_.num_versions_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy.Latest)
}

inline void ModelVersionPolicy_Latest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.num_versions_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelVersionPolicy_Latest::~ModelVersionPolicy_Latest() {
  // @@protoc_insertion_point(destructor:inference.ModelVersionPolicy.Latest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelVersionPolicy_Latest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelVersionPolicy_Latest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelVersionPolicy_Latest::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelVersionPolicy.Latest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.num_versions_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelVersionPolicy_Latest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 num_versions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_versions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelVersionPolicy_Latest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelVersionPolicy.Latest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 num_versions = 1;
  if (this->_internal_num_versions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_versions(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelVersionPolicy.Latest)
  return target;
}

size_t ModelVersionPolicy_Latest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelVersionPolicy.Latest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 num_versions = 1;
  if (this->_internal_num_versions() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_versions());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy_Latest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelVersionPolicy_Latest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy_Latest::GetClassData() const { return &_class_data_; }


void ModelVersionPolicy_Latest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelVersionPolicy_Latest*>(&to_msg);
  auto& from = static_cast<const ModelVersionPolicy_Latest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelVersionPolicy.Latest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_num_versions() != 0) {
    _this->_internal_set_num_versions(from._internal_num_versions());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelVersionPolicy_Latest::CopyFrom(const ModelVersionPolicy_Latest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelVersionPolicy.Latest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelVersionPolicy_Latest::IsInitialized() const {
  return true;
}

void ModelVersionPolicy_Latest::InternalSwap(ModelVersionPolicy_Latest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.num_versions_, other->_impl_.num_versions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy_Latest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[9]);
}

// ===================================================================

class ModelVersionPolicy_All::_Internal {
 public:
};

ModelVersionPolicy_All::ModelVersionPolicy_All(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy.All)
}
ModelVersionPolicy_All::ModelVersionPolicy_All(const ModelVersionPolicy_All& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ModelVersionPolicy_All* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy.All)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy_All::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy_All::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy_All::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[10]);
}

// ===================================================================

class ModelVersionPolicy_Specific::_Internal {
 public:
};

ModelVersionPolicy_Specific::ModelVersionPolicy_Specific(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy.Specific)
}
ModelVersionPolicy_Specific::ModelVersionPolicy_Specific(const ModelVersionPolicy_Specific& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelVersionPolicy_Specific* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.versions_){from._impl_.versions_}
    , /*decltype(_impl_._versions_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy.Specific)
}

inline void ModelVersionPolicy_Specific::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.versions_){arena}
    , /*decltype(_impl_._versions_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelVersionPolicy_Specific::~ModelVersionPolicy_Specific() {
  // @@protoc_insertion_point(destructor:inference.ModelVersionPolicy.Specific)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelVersionPolicy_Specific::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.versions_.~RepeatedField();
}

void ModelVersionPolicy_Specific::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelVersionPolicy_Specific::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelVersionPolicy.Specific)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.versions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelVersionPolicy_Specific::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 versions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_versions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_versions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelVersionPolicy_Specific::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelVersionPolicy.Specific)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 versions = 1;
  {
    int byte_size = _impl_._versions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_versions(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelVersionPolicy.Specific)
  return target;
}

size_t ModelVersionPolicy_Specific::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelVersionPolicy.Specific)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 versions = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.versions_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._versions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy_Specific::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelVersionPolicy_Specific::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy_Specific::GetClassData() const { return &_class_data_; }


void ModelVersionPolicy_Specific::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelVersionPolicy_Specific*>(&to_msg);
  auto& from = static_cast<const ModelVersionPolicy_Specific&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelVersionPolicy.Specific)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.versions_.MergeFrom(from._impl_.versions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelVersionPolicy_Specific::CopyFrom(const ModelVersionPolicy_Specific& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelVersionPolicy.Specific)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelVersionPolicy_Specific::IsInitialized() const {
  return true;
}

void ModelVersionPolicy_Specific::InternalSwap(ModelVersionPolicy_Specific* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.versions_.InternalSwap(&other->_impl_.versions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy_Specific::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[11]);
}

// ===================================================================

class ModelVersionPolicy::_Internal {
 public:
  static const ::inference::ModelVersionPolicy_Latest& latest(const ModelVersionPolicy* msg);
  static const ::inference::ModelVersionPolicy_All& all(const ModelVersionPolicy* msg);
  static const ::inference::ModelVersionPolicy_Specific& specific(const ModelVersionPolicy* msg);
};

const ::inference::ModelVersionPolicy_Latest&
ModelVersionPolicy::_Internal::latest(const ModelVersionPolicy* msg) {
  return *msg->_impl_.policy_choice_.latest_;
}
const ::inference::ModelVersionPolicy_All&
ModelVersionPolicy::_Internal::all(const ModelVersionPolicy* msg) {
  return *msg->_impl_.policy_choice_.all_;
}
const ::inference::ModelVersionPolicy_Specific&
ModelVersionPolicy::_Internal::specific(const ModelVersionPolicy* msg) {
  return *msg->_impl_.policy_choice_.specific_;
}
void ModelVersionPolicy::set_allocated_latest(::inference::ModelVersionPolicy_Latest* latest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_policy_choice();
  if (latest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(latest);
    if (message_arena != submessage_arena) {
      latest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest, submessage_arena);
    }
    set_has_latest();
    _impl_.policy_choice_.latest_ = latest;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelVersionPolicy.latest)
}
void ModelVersionPolicy::set_allocated_all(::inference::ModelVersionPolicy_All* all) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_policy_choice();
  if (all) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(all);
    if (message_arena != submessage_arena) {
      all = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all, submessage_arena);
    }
    set_has_all();
    _impl_.policy_choice_.all_ = all;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelVersionPolicy.all)
}
void ModelVersionPolicy::set_allocated_specific(::inference::ModelVersionPolicy_Specific* specific) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_policy_choice();
  if (specific) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(specific);
    if (message_arena != submessage_arena) {
      specific = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, specific, submessage_arena);
    }
    set_has_specific();
    _impl_.policy_choice_.specific_ = specific;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelVersionPolicy.specific)
}
ModelVersionPolicy::ModelVersionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy)
}
ModelVersionPolicy::ModelVersionPolicy(const ModelVersionPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelVersionPolicy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.policy_choice_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_policy_choice();
  switch (from.policy_choice_case()) {
    case kLatest: {
      _this->_internal_mutable_latest()->::inference::ModelVersionPolicy_Latest::MergeFrom(
          from._internal_latest());
      break;
    }
    case kAll: {
      _this->_internal_mutable_all()->::inference::ModelVersionPolicy_All::MergeFrom(
          from._internal_all());
      break;
    }
    case kSpecific: {
      _this->_internal_mutable_specific()->::inference::ModelVersionPolicy_Specific::MergeFrom(
          from._internal_specific());
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy)
}

inline void ModelVersionPolicy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.policy_choice_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_policy_choice();
}

ModelVersionPolicy::~ModelVersionPolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelVersionPolicy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelVersionPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_policy_choice()) {
    clear_policy_choice();
  }
}

void ModelVersionPolicy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelVersionPolicy::clear_policy_choice() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelVersionPolicy)
  switch (policy_choice_case()) {
    case kLatest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.policy_choice_.latest_;
      }
      break;
    }
    case kAll: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.policy_choice_.all_;
      }
      break;
    }
    case kSpecific: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.policy_choice_.specific_;
      }
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = POLICY_CHOICE_NOT_SET;
}


void ModelVersionPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelVersionPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_policy_choice();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelVersionPolicy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelVersionPolicy.Latest latest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_latest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelVersionPolicy.All all = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_all(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelVersionPolicy.Specific specific = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_specific(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelVersionPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelVersionPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelVersionPolicy.Latest latest = 1;
  if (_internal_has_latest()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::latest(this),
        _Internal::latest(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelVersionPolicy.All all = 2;
  if (_internal_has_all()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::all(this),
        _Internal::all(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelVersionPolicy.Specific specific = 3;
  if (_internal_has_specific()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::specific(this),
        _Internal::specific(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelVersionPolicy)
  return target;
}

size_t ModelVersionPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelVersionPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (policy_choice_case()) {
    // .inference.ModelVersionPolicy.Latest latest = 1;
    case kLatest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_choice_.latest_);
      break;
    }
    // .inference.ModelVersionPolicy.All all = 2;
    case kAll: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_choice_.all_);
      break;
    }
    // .inference.ModelVersionPolicy.Specific specific = 3;
    case kSpecific: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_choice_.specific_);
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelVersionPolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy::GetClassData() const { return &_class_data_; }


void ModelVersionPolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelVersionPolicy*>(&to_msg);
  auto& from = static_cast<const ModelVersionPolicy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelVersionPolicy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.policy_choice_case()) {
    case kLatest: {
      _this->_internal_mutable_latest()->::inference::ModelVersionPolicy_Latest::MergeFrom(
          from._internal_latest());
      break;
    }
    case kAll: {
      _this->_internal_mutable_all()->::inference::ModelVersionPolicy_All::MergeFrom(
          from._internal_all());
      break;
    }
    case kSpecific: {
      _this->_internal_mutable_specific()->::inference::ModelVersionPolicy_Specific::MergeFrom(
          from._internal_specific());
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelVersionPolicy::CopyFrom(const ModelVersionPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelVersionPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelVersionPolicy::IsInitialized() const {
  return true;
}

void ModelVersionPolicy::InternalSwap(ModelVersionPolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.policy_choice_, other->_impl_.policy_choice_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[12]);
}

// ===================================================================

class ModelOptimizationPolicy_Graph::_Internal {
 public:
};

ModelOptimizationPolicy_Graph::ModelOptimizationPolicy_Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Graph)
}
ModelOptimizationPolicy_Graph::ModelOptimizationPolicy_Graph(const ModelOptimizationPolicy_Graph& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_Graph* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.level_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Graph)
}

inline void ModelOptimizationPolicy_Graph::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.level_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_Graph::~ModelOptimizationPolicy_Graph() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Graph)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_Graph::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_Graph::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_Graph::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Graph)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.level_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Graph::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Graph::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Graph)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Graph)
  return target;
}

size_t ModelOptimizationPolicy_Graph::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Graph)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 level = 1;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Graph::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_Graph::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Graph::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_Graph::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_Graph*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_Graph&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Graph)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Graph::CopyFrom(const ModelOptimizationPolicy_Graph& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Graph)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Graph::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Graph::InternalSwap(ModelOptimizationPolicy_Graph* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.level_, other->_impl_.level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Graph::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[13]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_Internal {
 public:
};

ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ModelOptimizationPolicy_Cuda_GraphSpec_Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
}
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ModelOptimizationPolicy_Cuda_GraphSpec_Shape(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_Cuda_GraphSpec_Shape* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dim_){from._impl_.dim_}
    , /*decltype(_impl_._dim_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dim_){arena}
    , /*decltype(_impl_._dim_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_Cuda_GraphSpec_Shape::~ModelOptimizationPolicy_Cuda_GraphSpec_Shape() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dim_.~RepeatedField();
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dim_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 dim = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dim(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_dim(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dim = 1;
  {
    int byte_size = _impl_._dim_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_dim(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  return target;
}

size_t ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dim = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.dim_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dim_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_Cuda_GraphSpec_Shape::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda_GraphSpec_Shape::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_Cuda_GraphSpec_Shape*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_Shape&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dim_.MergeFrom(from._impl_.dim_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda_GraphSpec_Shape::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dim_.InternalSwap(&other->_impl_.dim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_Shape::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[14]);
}

// ===================================================================

ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse() {}
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[15]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_Internal {
 public:
};

ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
}
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_)*/{}
    , decltype(_impl_.batch_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  _this->_impl_.batch_size_ = from._impl_.batch_size_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.batch_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_.Destruct();
  _impl_.input_.~MapField();
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* _this = reinterpret_cast< ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* >(object);
  _this->_impl_.input_.Destruct();
}
void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_.Clear();
  _impl_.batch_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.input_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_batch_size(), target);
  }

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  if (!this->_internal_input().empty()) {
    using MapType = ::_pb::Map<std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape>;
    using WireHelper = ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_input();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.InputEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  return target;
}

size_t ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
      it = this->_internal_input().begin();
      it != this->_internal_input().end(); ++it) {
    total_size += ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_batch_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  if (from._internal_batch_size() != 0) {
    _this->_internal_set_batch_size(from._internal_batch_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_.InternalSwap(&other->_impl_.input_);
  swap(_impl_.batch_size_, other->_impl_.batch_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[16]);
}

// ===================================================================

ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse() {}
ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[17]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda_GraphSpec::_Internal {
 public:
  static const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& graph_lower_bound(const ModelOptimizationPolicy_Cuda_GraphSpec* msg);
};

const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&
ModelOptimizationPolicy_Cuda_GraphSpec::_Internal::graph_lower_bound(const ModelOptimizationPolicy_Cuda_GraphSpec* msg) {
  return *msg->_impl_.graph_lower_bound_;
}
ModelOptimizationPolicy_Cuda_GraphSpec::ModelOptimizationPolicy_Cuda_GraphSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelOptimizationPolicy_Cuda_GraphSpec::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
}
ModelOptimizationPolicy_Cuda_GraphSpec::ModelOptimizationPolicy_Cuda_GraphSpec(const ModelOptimizationPolicy_Cuda_GraphSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_Cuda_GraphSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_)*/{}
    , decltype(_impl_.graph_lower_bound_){nullptr}
    , decltype(_impl_.batch_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  if (from._internal_has_graph_lower_bound()) {
    _this->_impl_.graph_lower_bound_ = new ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(*from._impl_.graph_lower_bound_);
  }
  _this->_impl_.batch_size_ = from._impl_.batch_size_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.graph_lower_bound_){nullptr}
    , decltype(_impl_.batch_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_Cuda_GraphSpec::~ModelOptimizationPolicy_Cuda_GraphSpec() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_.Destruct();
  _impl_.input_.~MapField();
  if (this != internal_default_instance()) delete _impl_.graph_lower_bound_;
}

void ModelOptimizationPolicy_Cuda_GraphSpec::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Cuda_GraphSpec* _this = reinterpret_cast< ModelOptimizationPolicy_Cuda_GraphSpec* >(object);
  _this->_impl_.input_.Destruct();
}
void ModelOptimizationPolicy_Cuda_GraphSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda_GraphSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.graph_lower_bound_ != nullptr) {
    delete _impl_.graph_lower_bound_;
  }
  _impl_.graph_lower_bound_ = nullptr;
  _impl_.batch_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda_GraphSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.input_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph_lower_bound(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda_GraphSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_batch_size(), target);
  }

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  if (!this->_internal_input().empty()) {
    using MapType = ::_pb::Map<std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape>;
    using WireHelper = ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_input();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelOptimizationPolicy.Cuda.GraphSpec.InputEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
  if (this->_internal_has_graph_lower_bound()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::graph_lower_bound(this),
        _Internal::graph_lower_bound(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  return target;
}

size_t ModelOptimizationPolicy_Cuda_GraphSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
      it = this->_internal_input().begin();
      it != this->_internal_input().end(); ++it) {
    total_size += ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
  if (this->_internal_has_graph_lower_bound()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.graph_lower_bound_);
  }

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_batch_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda_GraphSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_Cuda_GraphSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda_GraphSpec::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_Cuda_GraphSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_Cuda_GraphSpec*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_Cuda_GraphSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  if (from._internal_has_graph_lower_bound()) {
    _this->_internal_mutable_graph_lower_bound()->::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeFrom(
        from._internal_graph_lower_bound());
  }
  if (from._internal_batch_size() != 0) {
    _this->_internal_set_batch_size(from._internal_batch_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda_GraphSpec::CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda_GraphSpec::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda_GraphSpec::InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_.InternalSwap(&other->_impl_.input_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda_GraphSpec, _impl_.batch_size_)
      + sizeof(ModelOptimizationPolicy_Cuda_GraphSpec::_impl_.batch_size_)
      - PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda_GraphSpec, _impl_.graph_lower_bound_)>(
          reinterpret_cast<char*>(&_impl_.graph_lower_bound_),
          reinterpret_cast<char*>(&other->_impl_.graph_lower_bound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[18]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda::_Internal {
 public:
};

ModelOptimizationPolicy_Cuda::ModelOptimizationPolicy_Cuda(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda)
}
ModelOptimizationPolicy_Cuda::ModelOptimizationPolicy_Cuda(const ModelOptimizationPolicy_Cuda& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_Cuda* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_spec_){from._impl_.graph_spec_}
    , decltype(_impl_.graphs_){}
    , decltype(_impl_.busy_wait_events_){}
    , decltype(_impl_.output_copy_stream_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.graphs_, &from._impl_.graphs_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.output_copy_stream_) -
    reinterpret_cast<char*>(&_impl_.graphs_)) + sizeof(_impl_.output_copy_stream_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda)
}

inline void ModelOptimizationPolicy_Cuda::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_spec_){arena}
    , decltype(_impl_.graphs_){false}
    , decltype(_impl_.busy_wait_events_){false}
    , decltype(_impl_.output_copy_stream_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_Cuda::~ModelOptimizationPolicy_Cuda() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_Cuda::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.graph_spec_.~RepeatedPtrField();
}

void ModelOptimizationPolicy_Cuda::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.graph_spec_.Clear();
  ::memset(&_impl_.graphs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.output_copy_stream_) -
      reinterpret_cast<char*>(&_impl_.graphs_)) + sizeof(_impl_.output_copy_stream_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool graphs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.graphs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool busy_wait_events = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.busy_wait_events_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_graph_spec(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool output_copy_stream = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.output_copy_stream_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool graphs = 1;
  if (this->_internal_graphs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_graphs(), target);
  }

  // bool busy_wait_events = 2;
  if (this->_internal_busy_wait_events() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_busy_wait_events(), target);
  }

  // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_graph_spec_size()); i < n; i++) {
    const auto& repfield = this->_internal_graph_spec(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool output_copy_stream = 4;
  if (this->_internal_output_copy_stream() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_output_copy_stream(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda)
  return target;
}

size_t ModelOptimizationPolicy_Cuda::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
  total_size += 1UL * this->_internal_graph_spec_size();
  for (const auto& msg : this->_impl_.graph_spec_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool graphs = 1;
  if (this->_internal_graphs() != 0) {
    total_size += 1 + 1;
  }

  // bool busy_wait_events = 2;
  if (this->_internal_busy_wait_events() != 0) {
    total_size += 1 + 1;
  }

  // bool output_copy_stream = 4;
  if (this->_internal_output_copy_stream() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_Cuda::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_Cuda::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_Cuda*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_Cuda&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.graph_spec_.MergeFrom(from._impl_.graph_spec_);
  if (from._internal_graphs() != 0) {
    _this->_internal_set_graphs(from._internal_graphs());
  }
  if (from._internal_busy_wait_events() != 0) {
    _this->_internal_set_busy_wait_events(from._internal_busy_wait_events());
  }
  if (from._internal_output_copy_stream() != 0) {
    _this->_internal_set_output_copy_stream(from._internal_output_copy_stream());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda::CopyFrom(const ModelOptimizationPolicy_Cuda& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda::InternalSwap(ModelOptimizationPolicy_Cuda* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.graph_spec_.InternalSwap(&other->_impl_.graph_spec_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda, _impl_.output_copy_stream_)
      + sizeof(ModelOptimizationPolicy_Cuda::_impl_.output_copy_stream_)
      - PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda, _impl_.graphs_)>(
          reinterpret_cast<char*>(&_impl_.graphs_),
          reinterpret_cast<char*>(&other->_impl_.graphs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[19]);
}

// ===================================================================

ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse() {}
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[20]);
}

// ===================================================================

class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_Internal {
 public:
};

ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
}
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
}

inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::~ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.Destruct();
  _impl_.parameters_.~MapField();
  _impl_.name_.Destroy();
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ArenaDtor(void* object) {
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _this = reinterpret_cast< ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* >(object);
  _this->_impl_.parameters_.Destruct();
}
void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // map<string, string> parameters = 2;
  if (!this->_internal_parameters().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_parameters();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  return target;
}

size_t ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[21]);
}

// ===================================================================

class ModelOptimizationPolicy_ExecutionAccelerators::_Internal {
 public:
};

ModelOptimizationPolicy_ExecutionAccelerators::ModelOptimizationPolicy_ExecutionAccelerators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators)
}
ModelOptimizationPolicy_ExecutionAccelerators::ModelOptimizationPolicy_ExecutionAccelerators(const ModelOptimizationPolicy_ExecutionAccelerators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_ExecutionAccelerators* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gpu_execution_accelerator_){from._impl_.gpu_execution_accelerator_}
    , decltype(_impl_.cpu_execution_accelerator_){from._impl_.cpu_execution_accelerator_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators)
}

inline void ModelOptimizationPolicy_ExecutionAccelerators::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gpu_execution_accelerator_){arena}
    , decltype(_impl_.cpu_execution_accelerator_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_ExecutionAccelerators::~ModelOptimizationPolicy_ExecutionAccelerators() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_ExecutionAccelerators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gpu_execution_accelerator_.~RepeatedPtrField();
  _impl_.cpu_execution_accelerator_.~RepeatedPtrField();
}

void ModelOptimizationPolicy_ExecutionAccelerators::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_ExecutionAccelerators::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gpu_execution_accelerator_.Clear();
  _impl_.cpu_execution_accelerator_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_ExecutionAccelerators::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gpu_execution_accelerator(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cpu_execution_accelerator(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_ExecutionAccelerators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gpu_execution_accelerator_size()); i < n; i++) {
    const auto& repfield = this->_internal_gpu_execution_accelerator(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cpu_execution_accelerator_size()); i < n; i++) {
    const auto& repfield = this->_internal_cpu_execution_accelerator(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  return target;
}

size_t ModelOptimizationPolicy_ExecutionAccelerators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
  total_size += 1UL * this->_internal_gpu_execution_accelerator_size();
  for (const auto& msg : this->_impl_.gpu_execution_accelerator_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
  total_size += 1UL * this->_internal_cpu_execution_accelerator_size();
  for (const auto& msg : this->_impl_.cpu_execution_accelerator_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_ExecutionAccelerators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_ExecutionAccelerators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_ExecutionAccelerators::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_ExecutionAccelerators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_ExecutionAccelerators*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_ExecutionAccelerators&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gpu_execution_accelerator_.MergeFrom(from._impl_.gpu_execution_accelerator_);
  _this->_impl_.cpu_execution_accelerator_.MergeFrom(from._impl_.cpu_execution_accelerator_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_ExecutionAccelerators::CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_ExecutionAccelerators::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_ExecutionAccelerators::InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gpu_execution_accelerator_.InternalSwap(&other->_impl_.gpu_execution_accelerator_);
  _impl_.cpu_execution_accelerator_.InternalSwap(&other->_impl_.cpu_execution_accelerator_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_ExecutionAccelerators::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[22]);
}

// ===================================================================

class ModelOptimizationPolicy_PinnedMemoryBuffer::_Internal {
 public:
};

ModelOptimizationPolicy_PinnedMemoryBuffer::ModelOptimizationPolicy_PinnedMemoryBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
}
ModelOptimizationPolicy_PinnedMemoryBuffer::ModelOptimizationPolicy_PinnedMemoryBuffer(const ModelOptimizationPolicy_PinnedMemoryBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy_PinnedMemoryBuffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.enable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enable_ = from._impl_.enable_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
}

inline void ModelOptimizationPolicy_PinnedMemoryBuffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.enable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy_PinnedMemoryBuffer::~ModelOptimizationPolicy_PinnedMemoryBuffer() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy_PinnedMemoryBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_PinnedMemoryBuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_PinnedMemoryBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  return target;
}

size_t ModelOptimizationPolicy_PinnedMemoryBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_PinnedMemoryBuffer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy_PinnedMemoryBuffer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_PinnedMemoryBuffer::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy_PinnedMemoryBuffer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy_PinnedMemoryBuffer*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy_PinnedMemoryBuffer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_enable() != 0) {
    _this->_internal_set_enable(from._internal_enable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::CopyFrom(const ModelOptimizationPolicy_PinnedMemoryBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_PinnedMemoryBuffer::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::InternalSwap(ModelOptimizationPolicy_PinnedMemoryBuffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.enable_, other->_impl_.enable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_PinnedMemoryBuffer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[23]);
}

// ===================================================================

class ModelOptimizationPolicy::_Internal {
 public:
  static const ::inference::ModelOptimizationPolicy_Graph& graph(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_Cuda& cuda(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& execution_accelerators(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& input_pinned_memory(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& output_pinned_memory(const ModelOptimizationPolicy* msg);
};

const ::inference::ModelOptimizationPolicy_Graph&
ModelOptimizationPolicy::_Internal::graph(const ModelOptimizationPolicy* msg) {
  return *msg->_impl_.graph_;
}
const ::inference::ModelOptimizationPolicy_Cuda&
ModelOptimizationPolicy::_Internal::cuda(const ModelOptimizationPolicy* msg) {
  return *msg->_impl_.cuda_;
}
const ::inference::ModelOptimizationPolicy_ExecutionAccelerators&
ModelOptimizationPolicy::_Internal::execution_accelerators(const ModelOptimizationPolicy* msg) {
  return *msg->_impl_.execution_accelerators_;
}
const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&
ModelOptimizationPolicy::_Internal::input_pinned_memory(const ModelOptimizationPolicy* msg) {
  return *msg->_impl_.input_pinned_memory_;
}
const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&
ModelOptimizationPolicy::_Internal::output_pinned_memory(const ModelOptimizationPolicy* msg) {
  return *msg->_impl_.output_pinned_memory_;
}
ModelOptimizationPolicy::ModelOptimizationPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy)
}
ModelOptimizationPolicy::ModelOptimizationPolicy(const ModelOptimizationPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOptimizationPolicy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_){nullptr}
    , decltype(_impl_.cuda_){nullptr}
    , decltype(_impl_.execution_accelerators_){nullptr}
    , decltype(_impl_.input_pinned_memory_){nullptr}
    , decltype(_impl_.output_pinned_memory_){nullptr}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.gather_kernel_buffer_threshold_){}
    , decltype(_impl_.eager_batching_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_graph()) {
    _this->_impl_.graph_ = new ::inference::ModelOptimizationPolicy_Graph(*from._impl_.graph_);
  }
  if (from._internal_has_cuda()) {
    _this->_impl_.cuda_ = new ::inference::ModelOptimizationPolicy_Cuda(*from._impl_.cuda_);
  }
  if (from._internal_has_execution_accelerators()) {
    _this->_impl_.execution_accelerators_ = new ::inference::ModelOptimizationPolicy_ExecutionAccelerators(*from._impl_.execution_accelerators_);
  }
  if (from._internal_has_input_pinned_memory()) {
    _this->_impl_.input_pinned_memory_ = new ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer(*from._impl_.input_pinned_memory_);
  }
  if (from._internal_has_output_pinned_memory()) {
    _this->_impl_.output_pinned_memory_ = new ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer(*from._impl_.output_pinned_memory_);
  }
  ::memcpy(&_impl_.priority_, &from._impl_.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eager_batching_) -
    reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.eager_batching_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy)
}

inline void ModelOptimizationPolicy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_){nullptr}
    , decltype(_impl_.cuda_){nullptr}
    , decltype(_impl_.execution_accelerators_){nullptr}
    , decltype(_impl_.input_pinned_memory_){nullptr}
    , decltype(_impl_.output_pinned_memory_){nullptr}
    , decltype(_impl_.priority_){0}
    , decltype(_impl_.gather_kernel_buffer_threshold_){0u}
    , decltype(_impl_.eager_batching_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOptimizationPolicy::~ModelOptimizationPolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOptimizationPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.graph_;
  if (this != internal_default_instance()) delete _impl_.cuda_;
  if (this != internal_default_instance()) delete _impl_.execution_accelerators_;
  if (this != internal_default_instance()) delete _impl_.input_pinned_memory_;
  if (this != internal_default_instance()) delete _impl_.output_pinned_memory_;
}

void ModelOptimizationPolicy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOptimizationPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.graph_ != nullptr) {
    delete _impl_.graph_;
  }
  _impl_.graph_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.cuda_ != nullptr) {
    delete _impl_.cuda_;
  }
  _impl_.cuda_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.execution_accelerators_ != nullptr) {
    delete _impl_.execution_accelerators_;
  }
  _impl_.execution_accelerators_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.input_pinned_memory_ != nullptr) {
    delete _impl_.input_pinned_memory_;
  }
  _impl_.input_pinned_memory_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.output_pinned_memory_ != nullptr) {
    delete _impl_.output_pinned_memory_;
  }
  _impl_.output_pinned_memory_ = nullptr;
  ::memset(&_impl_.priority_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.eager_batching_) -
      reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.eager_batching_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelOptimizationPolicy.Graph graph = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_priority(static_cast<::inference::ModelOptimizationPolicy_ModelPriority>(val));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cuda(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_accelerators(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_input_pinned_memory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_output_pinned_memory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 gather_kernel_buffer_threshold = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.gather_kernel_buffer_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool eager_batching = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.eager_batching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelOptimizationPolicy.Graph graph = 1;
  if (this->_internal_has_graph()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::graph(this),
        _Internal::graph(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_priority(), target);
  }

  // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
  if (this->_internal_has_cuda()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cuda(this),
        _Internal::cuda(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
  if (this->_internal_has_execution_accelerators()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::execution_accelerators(this),
        _Internal::execution_accelerators(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
  if (this->_internal_has_input_pinned_memory()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::input_pinned_memory(this),
        _Internal::input_pinned_memory(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
  if (this->_internal_has_output_pinned_memory()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::output_pinned_memory(this),
        _Internal::output_pinned_memory(this).GetCachedSize(), target, stream);
  }

  // uint32 gather_kernel_buffer_threshold = 7;
  if (this->_internal_gather_kernel_buffer_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_gather_kernel_buffer_threshold(), target);
  }

  // bool eager_batching = 8;
  if (this->_internal_eager_batching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_eager_batching(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy)
  return target;
}

size_t ModelOptimizationPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .inference.ModelOptimizationPolicy.Graph graph = 1;
  if (this->_internal_has_graph()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.graph_);
  }

  // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
  if (this->_internal_has_cuda()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cuda_);
  }

  // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
  if (this->_internal_has_execution_accelerators()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.execution_accelerators_);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
  if (this->_internal_has_input_pinned_memory()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.input_pinned_memory_);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
  if (this->_internal_has_output_pinned_memory()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.output_pinned_memory_);
  }

  // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
  if (this->_internal_priority() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_priority());
  }

  // uint32 gather_kernel_buffer_threshold = 7;
  if (this->_internal_gather_kernel_buffer_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gather_kernel_buffer_threshold());
  }

  // bool eager_batching = 8;
  if (this->_internal_eager_batching() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOptimizationPolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy::GetClassData() const { return &_class_data_; }


void ModelOptimizationPolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOptimizationPolicy*>(&to_msg);
  auto& from = static_cast<const ModelOptimizationPolicy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_graph()) {
    _this->_internal_mutable_graph()->::inference::ModelOptimizationPolicy_Graph::MergeFrom(
        from._internal_graph());
  }
  if (from._internal_has_cuda()) {
    _this->_internal_mutable_cuda()->::inference::ModelOptimizationPolicy_Cuda::MergeFrom(
        from._internal_cuda());
  }
  if (from._internal_has_execution_accelerators()) {
    _this->_internal_mutable_execution_accelerators()->::inference::ModelOptimizationPolicy_ExecutionAccelerators::MergeFrom(
        from._internal_execution_accelerators());
  }
  if (from._internal_has_input_pinned_memory()) {
    _this->_internal_mutable_input_pinned_memory()->::inference::ModelOptimizationPolicy_PinnedMemoryBuffer::MergeFrom(
        from._internal_input_pinned_memory());
  }
  if (from._internal_has_output_pinned_memory()) {
    _this->_internal_mutable_output_pinned_memory()->::inference::ModelOptimizationPolicy_PinnedMemoryBuffer::MergeFrom(
        from._internal_output_pinned_memory());
  }
  if (from._internal_priority() != 0) {
    _this->_internal_set_priority(from._internal_priority());
  }
  if (from._internal_gather_kernel_buffer_threshold() != 0) {
    _this->_internal_set_gather_kernel_buffer_threshold(from._internal_gather_kernel_buffer_threshold());
  }
  if (from._internal_eager_batching() != 0) {
    _this->_internal_set_eager_batching(from._internal_eager_batching());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy::CopyFrom(const ModelOptimizationPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy::InternalSwap(ModelOptimizationPolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy, _impl_.eager_batching_)
      + sizeof(ModelOptimizationPolicy::_impl_.eager_batching_)
      - PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy, _impl_.graph_)>(
          reinterpret_cast<char*>(&_impl_.graph_),
          reinterpret_cast<char*>(&other->_impl_.graph_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[24]);
}

// ===================================================================

class ModelQueuePolicy::_Internal {
 public:
};

ModelQueuePolicy::ModelQueuePolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelQueuePolicy)
}
ModelQueuePolicy::ModelQueuePolicy(const ModelQueuePolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelQueuePolicy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.default_timeout_microseconds_){}
    , decltype(_impl_.timeout_action_){}
    , decltype(_impl_.allow_timeout_override_){}
    , decltype(_impl_.max_queue_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.default_timeout_microseconds_, &from._impl_.default_timeout_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_queue_size_) -
    reinterpret_cast<char*>(&_impl_.default_timeout_microseconds_)) + sizeof(_impl_.max_queue_size_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelQueuePolicy)
}

inline void ModelQueuePolicy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.default_timeout_microseconds_){uint64_t{0u}}
    , decltype(_impl_.timeout_action_){0}
    , decltype(_impl_.allow_timeout_override_){false}
    , decltype(_impl_.max_queue_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelQueuePolicy::~ModelQueuePolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelQueuePolicy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelQueuePolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelQueuePolicy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelQueuePolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelQueuePolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.default_timeout_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_queue_size_) -
      reinterpret_cast<char*>(&_impl_.default_timeout_microseconds_)) + sizeof(_impl_.max_queue_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelQueuePolicy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_timeout_action(static_cast<::inference::ModelQueuePolicy_TimeoutAction>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 default_timeout_microseconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.default_timeout_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_timeout_override = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_timeout_override_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_queue_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.max_queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelQueuePolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelQueuePolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
  if (this->_internal_timeout_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_timeout_action(), target);
  }

  // uint64 default_timeout_microseconds = 2;
  if (this->_internal_default_timeout_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_default_timeout_microseconds(), target);
  }

  // bool allow_timeout_override = 3;
  if (this->_internal_allow_timeout_override() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_timeout_override(), target);
  }

  // uint32 max_queue_size = 4;
  if (this->_internal_max_queue_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_max_queue_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelQueuePolicy)
  return target;
}

size_t ModelQueuePolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelQueuePolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 default_timeout_microseconds = 2;
  if (this->_internal_default_timeout_microseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_default_timeout_microseconds());
  }

  // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
  if (this->_internal_timeout_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_timeout_action());
  }

  // bool allow_timeout_override = 3;
  if (this->_internal_allow_timeout_override() != 0) {
    total_size += 1 + 1;
  }

  // uint32 max_queue_size = 4;
  if (this->_internal_max_queue_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_queue_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelQueuePolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelQueuePolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelQueuePolicy::GetClassData() const { return &_class_data_; }


void ModelQueuePolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelQueuePolicy*>(&to_msg);
  auto& from = static_cast<const ModelQueuePolicy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelQueuePolicy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_default_timeout_microseconds() != 0) {
    _this->_internal_set_default_timeout_microseconds(from._internal_default_timeout_microseconds());
  }
  if (from._internal_timeout_action() != 0) {
    _this->_internal_set_timeout_action(from._internal_timeout_action());
  }
  if (from._internal_allow_timeout_override() != 0) {
    _this->_internal_set_allow_timeout_override(from._internal_allow_timeout_override());
  }
  if (from._internal_max_queue_size() != 0) {
    _this->_internal_set_max_queue_size(from._internal_max_queue_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelQueuePolicy::CopyFrom(const ModelQueuePolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelQueuePolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelQueuePolicy::IsInitialized() const {
  return true;
}

void ModelQueuePolicy::InternalSwap(ModelQueuePolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelQueuePolicy, _impl_.max_queue_size_)
      + sizeof(ModelQueuePolicy::_impl_.max_queue_size_)
      - PROTOBUF_FIELD_OFFSET(ModelQueuePolicy, _impl_.default_timeout_microseconds_)>(
          reinterpret_cast<char*>(&_impl_.default_timeout_microseconds_),
          reinterpret_cast<char*>(&other->_impl_.default_timeout_microseconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelQueuePolicy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[25]);
}

// ===================================================================

ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse() {}
ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::MergeFrom(const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[26]);
}

// ===================================================================

class ModelDynamicBatching::_Internal {
 public:
  static const ::inference::ModelQueuePolicy& default_queue_policy(const ModelDynamicBatching* msg);
};

const ::inference::ModelQueuePolicy&
ModelDynamicBatching::_Internal::default_queue_policy(const ModelDynamicBatching* msg) {
  return *msg->_impl_.default_queue_policy_;
}
ModelDynamicBatching::ModelDynamicBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelDynamicBatching::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelDynamicBatching)
}
ModelDynamicBatching::ModelDynamicBatching(const ModelDynamicBatching& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelDynamicBatching* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.preferred_batch_size_){from._impl_.preferred_batch_size_}
    , /*decltype(_impl_._preferred_batch_size_cached_byte_size_)*/{0}
    , /*decltype(_impl_.priority_queue_policy_)*/{}
    , decltype(_impl_.default_queue_policy_){nullptr}
    , decltype(_impl_.max_queue_delay_microseconds_){}
    , decltype(_impl_.priority_levels_){}
    , decltype(_impl_.default_priority_level_){}
    , decltype(_impl_.preserve_ordering_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.priority_queue_policy_.MergeFrom(from._impl_.priority_queue_policy_);
  if (from._internal_has_default_queue_policy()) {
    _this->_impl_.default_queue_policy_ = new ::inference::ModelQueuePolicy(*from._impl_.default_queue_policy_);
  }
  ::memcpy(&_impl_.max_queue_delay_microseconds_, &from._impl_.max_queue_delay_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.preserve_ordering_) -
    reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_)) + sizeof(_impl_.preserve_ordering_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelDynamicBatching)
}

inline void ModelDynamicBatching::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.preferred_batch_size_){arena}
    , /*decltype(_impl_._preferred_batch_size_cached_byte_size_)*/{0}
    , /*decltype(_impl_.priority_queue_policy_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.default_queue_policy_){nullptr}
    , decltype(_impl_.max_queue_delay_microseconds_){uint64_t{0u}}
    , decltype(_impl_.priority_levels_){uint64_t{0u}}
    , decltype(_impl_.default_priority_level_){uint64_t{0u}}
    , decltype(_impl_.preserve_ordering_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelDynamicBatching::~ModelDynamicBatching() {
  // @@protoc_insertion_point(destructor:inference.ModelDynamicBatching)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelDynamicBatching::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.preferred_batch_size_.~RepeatedField();
  _impl_.priority_queue_policy_.Destruct();
  _impl_.priority_queue_policy_.~MapField();
  if (this != internal_default_instance()) delete _impl_.default_queue_policy_;
}

void ModelDynamicBatching::ArenaDtor(void* object) {
  ModelDynamicBatching* _this = reinterpret_cast< ModelDynamicBatching* >(object);
  _this->_impl_.priority_queue_policy_.Destruct();
}
void ModelDynamicBatching::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelDynamicBatching::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelDynamicBatching)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.preferred_batch_size_.Clear();
  _impl_.priority_queue_policy_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.default_queue_policy_ != nullptr) {
    delete _impl_.default_queue_policy_;
  }
  _impl_.default_queue_policy_ = nullptr;
  ::memset(&_impl_.max_queue_delay_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.preserve_ordering_) -
      reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_)) + sizeof(_impl_.preserve_ordering_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelDynamicBatching::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 preferred_batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_preferred_batch_size(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_queue_delay_microseconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.max_queue_delay_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool preserve_ordering = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.preserve_ordering_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 priority_levels = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.priority_levels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 default_priority_level = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.default_priority_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelQueuePolicy default_queue_policy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_queue_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.priority_queue_policy_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelDynamicBatching::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelDynamicBatching)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 preferred_batch_size = 1;
  {
    int byte_size = _impl_._preferred_batch_size_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_preferred_batch_size(), byte_size, target);
    }
  }

  // uint64 max_queue_delay_microseconds = 2;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_queue_delay_microseconds(), target);
  }

  // bool preserve_ordering = 3;
  if (this->_internal_preserve_ordering() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_preserve_ordering(), target);
  }

  // uint64 priority_levels = 4;
  if (this->_internal_priority_levels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_priority_levels(), target);
  }

  // uint64 default_priority_level = 5;
  if (this->_internal_default_priority_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_default_priority_level(), target);
  }

  // .inference.ModelQueuePolicy default_queue_policy = 6;
  if (this->_internal_has_default_queue_policy()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::default_queue_policy(this),
        _Internal::default_queue_policy(this).GetCachedSize(), target, stream);
  }

  // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
  if (!this->_internal_priority_queue_policy().empty()) {
    using MapType = ::_pb::Map<uint64_t, ::inference::ModelQueuePolicy>;
    using WireHelper = ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_priority_queue_policy();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelDynamicBatching)
  return target;
}

size_t ModelDynamicBatching::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelDynamicBatching)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 preferred_batch_size = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.preferred_batch_size_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._preferred_batch_size_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_priority_queue_policy_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >::const_iterator
      it = this->_internal_priority_queue_policy().begin();
      it != this->_internal_priority_queue_policy().end(); ++it) {
    total_size += ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .inference.ModelQueuePolicy default_queue_policy = 6;
  if (this->_internal_has_default_queue_policy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_queue_policy_);
  }

  // uint64 max_queue_delay_microseconds = 2;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_queue_delay_microseconds());
  }

  // uint64 priority_levels = 4;
  if (this->_internal_priority_levels() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_priority_levels());
  }

  // uint64 default_priority_level = 5;
  if (this->_internal_default_priority_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_default_priority_level());
  }

  // bool preserve_ordering = 3;
  if (this->_internal_preserve_ordering() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelDynamicBatching::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelDynamicBatching::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelDynamicBatching::GetClassData() const { return &_class_data_; }


void ModelDynamicBatching::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelDynamicBatching*>(&to_msg);
  auto& from = static_cast<const ModelDynamicBatching&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelDynamicBatching)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.preferred_batch_size_.MergeFrom(from._impl_.preferred_batch_size_);
  _this->_impl_.priority_queue_policy_.MergeFrom(from._impl_.priority_queue_policy_);
  if (from._internal_has_default_queue_policy()) {
    _this->_internal_mutable_default_queue_policy()->::inference::ModelQueuePolicy::MergeFrom(
        from._internal_default_queue_policy());
  }
  if (from._internal_max_queue_delay_microseconds() != 0) {
    _this->_internal_set_max_queue_delay_microseconds(from._internal_max_queue_delay_microseconds());
  }
  if (from._internal_priority_levels() != 0) {
    _this->_internal_set_priority_levels(from._internal_priority_levels());
  }
  if (from._internal_default_priority_level() != 0) {
    _this->_internal_set_default_priority_level(from._internal_default_priority_level());
  }
  if (from._internal_preserve_ordering() != 0) {
    _this->_internal_set_preserve_ordering(from._internal_preserve_ordering());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelDynamicBatching::CopyFrom(const ModelDynamicBatching& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelDynamicBatching)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelDynamicBatching::IsInitialized() const {
  return true;
}

void ModelDynamicBatching::InternalSwap(ModelDynamicBatching* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.preferred_batch_size_.InternalSwap(&other->_impl_.preferred_batch_size_);
  _impl_.priority_queue_policy_.InternalSwap(&other->_impl_.priority_queue_policy_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelDynamicBatching, _impl_.preserve_ordering_)
      + sizeof(ModelDynamicBatching::_impl_.preserve_ordering_)
      - PROTOBUF_FIELD_OFFSET(ModelDynamicBatching, _impl_.default_queue_policy_)>(
          reinterpret_cast<char*>(&_impl_.default_queue_policy_),
          reinterpret_cast<char*>(&other->_impl_.default_queue_policy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelDynamicBatching::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[27]);
}

// ===================================================================

class ModelSequenceBatching_Control::_Internal {
 public:
};

ModelSequenceBatching_Control::ModelSequenceBatching_Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.Control)
}
ModelSequenceBatching_Control::ModelSequenceBatching_Control(const ModelSequenceBatching_Control& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching_Control* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.int32_false_true_){from._impl_.int32_false_true_}
    , /*decltype(_impl_._int32_false_true_cached_byte_size_)*/{0}
    , decltype(_impl_.fp32_false_true_){from._impl_.fp32_false_true_}
    , decltype(_impl_.bool_false_true_){from._impl_.bool_false_true_}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.data_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.kind_, &from._impl_.kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.data_type_) -
    reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.data_type_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.Control)
}

inline void ModelSequenceBatching_Control::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.int32_false_true_){arena}
    , /*decltype(_impl_._int32_false_true_cached_byte_size_)*/{0}
    , decltype(_impl_.fp32_false_true_){arena}
    , decltype(_impl_.bool_false_true_){arena}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.data_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelSequenceBatching_Control::~ModelSequenceBatching_Control() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.Control)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching_Control::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.int32_false_true_.~RepeatedField();
  _impl_.fp32_false_true_.~RepeatedField();
  _impl_.bool_false_true_.~RepeatedField();
}

void ModelSequenceBatching_Control::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching_Control::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.Control)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.int32_false_true_.Clear();
  _impl_.fp32_false_true_.Clear();
  _impl_.bool_false_true_.Clear();
  ::memset(&_impl_.kind_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.data_type_) -
      reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.data_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_Control::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelSequenceBatching.Control.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::ModelSequenceBatching_Control_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 int32_false_true = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_int32_false_true(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_int32_false_true(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float fp32_false_true = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_fp32_false_true(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 29) {
          _internal_add_fp32_false_true(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated bool bool_false_true = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_bool_false_true(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_bool_false_true(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_Control::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.Control)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelSequenceBatching.Control.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // repeated int32 int32_false_true = 2;
  {
    int byte_size = _impl_._int32_false_true_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_int32_false_true(), byte_size, target);
    }
  }

  // repeated float fp32_false_true = 3;
  if (this->_internal_fp32_false_true_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_fp32_false_true(), target);
  }

  // .inference.DataType data_type = 4;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_data_type(), target);
  }

  // repeated bool bool_false_true = 5;
  if (this->_internal_bool_false_true_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_bool_false_true(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.Control)
  return target;
}

size_t ModelSequenceBatching_Control::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.Control)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 int32_false_true = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.int32_false_true_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._int32_false_true_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float fp32_false_true = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_fp32_false_true_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated bool bool_false_true = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_bool_false_true_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .inference.ModelSequenceBatching.Control.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // .inference.DataType data_type = 4;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_Control::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching_Control::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_Control::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching_Control::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching_Control*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching_Control&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.Control)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.int32_false_true_.MergeFrom(from._impl_.int32_false_true_);
  _this->_impl_.fp32_false_true_.MergeFrom(from._impl_.fp32_false_true_);
  _this->_impl_.bool_false_true_.MergeFrom(from._impl_.bool_false_true_);
  if (from._internal_kind() != 0) {
    _this->_internal_set_kind(from._internal_kind());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_Control::CopyFrom(const ModelSequenceBatching_Control& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.Control)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_Control::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_Control::InternalSwap(ModelSequenceBatching_Control* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.int32_false_true_.InternalSwap(&other->_impl_.int32_false_true_);
  _impl_.fp32_false_true_.InternalSwap(&other->_impl_.fp32_false_true_);
  _impl_.bool_false_true_.InternalSwap(&other->_impl_.bool_false_true_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_Control, _impl_.data_type_)
      + sizeof(ModelSequenceBatching_Control::_impl_.data_type_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_Control, _impl_.kind_)>(
          reinterpret_cast<char*>(&_impl_.kind_),
          reinterpret_cast<char*>(&other->_impl_.kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_Control::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[28]);
}

// ===================================================================

class ModelSequenceBatching_ControlInput::_Internal {
 public:
};

ModelSequenceBatching_ControlInput::ModelSequenceBatching_ControlInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.ControlInput)
}
ModelSequenceBatching_ControlInput::ModelSequenceBatching_ControlInput(const ModelSequenceBatching_ControlInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching_ControlInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.control_){from._impl_.control_}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.ControlInput)
}

inline void ModelSequenceBatching_ControlInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.control_){arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelSequenceBatching_ControlInput::~ModelSequenceBatching_ControlInput() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.ControlInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching_ControlInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.control_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void ModelSequenceBatching_ControlInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching_ControlInput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.ControlInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.control_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_ControlInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelSequenceBatching.ControlInput.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.Control control = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_control(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_ControlInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.ControlInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.ControlInput.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .inference.ModelSequenceBatching.Control control = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_control_size()); i < n; i++) {
    const auto& repfield = this->_internal_control(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.ControlInput)
  return target;
}

size_t ModelSequenceBatching_ControlInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.ControlInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelSequenceBatching.Control control = 2;
  total_size += 1UL * this->_internal_control_size();
  for (const auto& msg : this->_impl_.control_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_ControlInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching_ControlInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_ControlInput::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching_ControlInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching_ControlInput*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching_ControlInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.ControlInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.control_.MergeFrom(from._impl_.control_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_ControlInput::CopyFrom(const ModelSequenceBatching_ControlInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.ControlInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_ControlInput::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_ControlInput::InternalSwap(ModelSequenceBatching_ControlInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.control_.InternalSwap(&other->_impl_.control_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_ControlInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[29]);
}

// ===================================================================

class ModelSequenceBatching_InitialState::_Internal {
 public:
};

ModelSequenceBatching_InitialState::ModelSequenceBatching_InitialState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.InitialState)
}
ModelSequenceBatching_InitialState::ModelSequenceBatching_InitialState(const ModelSequenceBatching_InitialState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching_InitialState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){from._impl_.dims_}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.state_data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.data_type_ = from._impl_.data_type_;
  clear_has_state_data();
  switch (from.state_data_case()) {
    case kZeroData: {
      _this->_internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kDataFile: {
      _this->_internal_set_data_file(from._internal_data_file());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.InitialState)
}

inline void ModelSequenceBatching_InitialState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){arena}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.state_data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_state_data();
}

ModelSequenceBatching_InitialState::~ModelSequenceBatching_InitialState() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.InitialState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching_InitialState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dims_.~RepeatedField();
  _impl_.name_.Destroy();
  if (has_state_data()) {
    clear_state_data();
  }
}

void ModelSequenceBatching_InitialState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching_InitialState::clear_state_data() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelSequenceBatching.InitialState)
  switch (state_data_case()) {
    case kZeroData: {
      // No need to clear
      break;
    }
    case kDataFile: {
      _impl_.state_data_.data_file_.Destroy();
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STATE_DATA_NOT_SET;
}


void ModelSequenceBatching_InitialState::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.InitialState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dims_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.data_type_ = 0;
  clear_state_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_InitialState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.DataType data_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_zero_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string data_file = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelSequenceBatching.InitialState.data_file"));
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelSequenceBatching.InitialState.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_InitialState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.InitialState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 2;
  {
    int byte_size = _impl_._dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_dims(), byte_size, target);
    }
  }

  // bool zero_data = 3;
  if (_internal_has_zero_data()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_zero_data(), target);
  }

  // string data_file = 4;
  if (_internal_has_data_file()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_data_file().data(), static_cast<int>(this->_internal_data_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.InitialState.data_file");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_data_file(), target);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.InitialState.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.InitialState)
  return target;
}

size_t ModelSequenceBatching_InitialState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.InitialState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  switch (state_data_case()) {
    // bool zero_data = 3;
    case kZeroData: {
      total_size += 1 + 1;
      break;
    }
    // string data_file = 4;
    case kDataFile: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_data_file());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_InitialState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching_InitialState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_InitialState::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching_InitialState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching_InitialState*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching_InitialState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.InitialState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dims_.MergeFrom(from._impl_.dims_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  switch (from.state_data_case()) {
    case kZeroData: {
      _this->_internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kDataFile: {
      _this->_internal_set_data_file(from._internal_data_file());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_InitialState::CopyFrom(const ModelSequenceBatching_InitialState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.InitialState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_InitialState::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_InitialState::InternalSwap(ModelSequenceBatching_InitialState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dims_.InternalSwap(&other->_impl_.dims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.data_type_, other->_impl_.data_type_);
  swap(_impl_.state_data_, other->_impl_.state_data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_InitialState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[30]);
}

// ===================================================================

class ModelSequenceBatching_State::_Internal {
 public:
};

ModelSequenceBatching_State::ModelSequenceBatching_State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.State)
}
ModelSequenceBatching_State::ModelSequenceBatching_State(const ModelSequenceBatching_State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching_State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){from._impl_.dims_}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.initial_state_){from._impl_.initial_state_}
    , decltype(_impl_.input_name_){}
    , decltype(_impl_.output_name_){}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.use_same_buffer_for_input_output_){}
    , decltype(_impl_.use_growable_memory_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.input_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_input_name().empty()) {
    _this->_impl_.input_name_.Set(from._internal_input_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.output_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_output_name().empty()) {
    _this->_impl_.output_name_.Set(from._internal_output_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.data_type_, &from._impl_.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_growable_memory_) -
    reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.use_growable_memory_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.State)
}

inline void ModelSequenceBatching_State::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){arena}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.initial_state_){arena}
    , decltype(_impl_.input_name_){}
    , decltype(_impl_.output_name_){}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.use_same_buffer_for_input_output_){false}
    , decltype(_impl_.use_growable_memory_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.input_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.output_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelSequenceBatching_State::~ModelSequenceBatching_State() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching_State::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dims_.~RepeatedField();
  _impl_.initial_state_.~RepeatedPtrField();
  _impl_.input_name_.Destroy();
  _impl_.output_name_.Destroy();
}

void ModelSequenceBatching_State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching_State::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.State)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dims_.Clear();
  _impl_.initial_state_.Clear();
  _impl_.input_name_.ClearToEmpty();
  _impl_.output_name_.ClearToEmpty();
  ::memset(&_impl_.data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.use_growable_memory_) -
      reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.use_growable_memory_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string input_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_input_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelSequenceBatching.State.input_name"));
        } else
          goto handle_unusual;
        continue;
      // string output_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_output_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelSequenceBatching.State.output_name"));
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_initial_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool use_same_buffer_for_input_output = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.use_same_buffer_for_input_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool use_growable_memory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.use_growable_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_State::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.State)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string input_name = 1;
  if (!this->_internal_input_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input_name().data(), static_cast<int>(this->_internal_input_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.State.input_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_input_name(), target);
  }

  // string output_name = 2;
  if (!this->_internal_output_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_output_name().data(), static_cast<int>(this->_internal_output_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.State.output_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_output_name(), target);
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 4;
  {
    int byte_size = _impl_._dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_dims(), byte_size, target);
    }
  }

  // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_initial_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_initial_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool use_same_buffer_for_input_output = 6;
  if (this->_internal_use_same_buffer_for_input_output() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_use_same_buffer_for_input_output(), target);
  }

  // bool use_growable_memory = 7;
  if (this->_internal_use_growable_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_use_growable_memory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.State)
  return target;
}

size_t ModelSequenceBatching_State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.State)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
  total_size += 1UL * this->_internal_initial_state_size();
  for (const auto& msg : this->_impl_.initial_state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string input_name = 1;
  if (!this->_internal_input_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_input_name());
  }

  // string output_name = 2;
  if (!this->_internal_output_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_output_name());
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // bool use_same_buffer_for_input_output = 6;
  if (this->_internal_use_same_buffer_for_input_output() != 0) {
    total_size += 1 + 1;
  }

  // bool use_growable_memory = 7;
  if (this->_internal_use_growable_memory() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching_State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_State::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching_State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching_State*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching_State&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.State)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dims_.MergeFrom(from._impl_.dims_);
  _this->_impl_.initial_state_.MergeFrom(from._impl_.initial_state_);
  if (!from._internal_input_name().empty()) {
    _this->_internal_set_input_name(from._internal_input_name());
  }
  if (!from._internal_output_name().empty()) {
    _this->_internal_set_output_name(from._internal_output_name());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_use_same_buffer_for_input_output() != 0) {
    _this->_internal_set_use_same_buffer_for_input_output(from._internal_use_same_buffer_for_input_output());
  }
  if (from._internal_use_growable_memory() != 0) {
    _this->_internal_set_use_growable_memory(from._internal_use_growable_memory());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_State::CopyFrom(const ModelSequenceBatching_State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_State::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_State::InternalSwap(ModelSequenceBatching_State* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dims_.InternalSwap(&other->_impl_.dims_);
  _impl_.initial_state_.InternalSwap(&other->_impl_.initial_state_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.input_name_, lhs_arena,
      &other->_impl_.input_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.output_name_, lhs_arena,
      &other->_impl_.output_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_State, _impl_.use_growable_memory_)
      + sizeof(ModelSequenceBatching_State::_impl_.use_growable_memory_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_State, _impl_.data_type_)>(
          reinterpret_cast<char*>(&_impl_.data_type_),
          reinterpret_cast<char*>(&other->_impl_.data_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_State::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[31]);
}

// ===================================================================

class ModelSequenceBatching_StrategyDirect::_Internal {
 public:
};

ModelSequenceBatching_StrategyDirect::ModelSequenceBatching_StrategyDirect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.StrategyDirect)
}
ModelSequenceBatching_StrategyDirect::ModelSequenceBatching_StrategyDirect(const ModelSequenceBatching_StrategyDirect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching_StrategyDirect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.max_queue_delay_microseconds_){}
    , decltype(_impl_.minimum_slot_utilization_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_queue_delay_microseconds_, &from._impl_.max_queue_delay_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.minimum_slot_utilization_) -
    reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_)) + sizeof(_impl_.minimum_slot_utilization_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.StrategyDirect)
}

inline void ModelSequenceBatching_StrategyDirect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.max_queue_delay_microseconds_){uint64_t{0u}}
    , decltype(_impl_.minimum_slot_utilization_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelSequenceBatching_StrategyDirect::~ModelSequenceBatching_StrategyDirect() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.StrategyDirect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching_StrategyDirect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelSequenceBatching_StrategyDirect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching_StrategyDirect::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.StrategyDirect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.max_queue_delay_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.minimum_slot_utilization_) -
      reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_)) + sizeof(_impl_.minimum_slot_utilization_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_StrategyDirect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 max_queue_delay_microseconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.max_queue_delay_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float minimum_slot_utilization = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.minimum_slot_utilization_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_StrategyDirect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.StrategyDirect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 max_queue_delay_microseconds = 1;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_max_queue_delay_microseconds(), target);
  }

  // float minimum_slot_utilization = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minimum_slot_utilization = this->_internal_minimum_slot_utilization();
  uint32_t raw_minimum_slot_utilization;
  memcpy(&raw_minimum_slot_utilization, &tmp_minimum_slot_utilization, sizeof(tmp_minimum_slot_utilization));
  if (raw_minimum_slot_utilization != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_minimum_slot_utilization(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.StrategyDirect)
  return target;
}

size_t ModelSequenceBatching_StrategyDirect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.StrategyDirect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 max_queue_delay_microseconds = 1;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_queue_delay_microseconds());
  }

  // float minimum_slot_utilization = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minimum_slot_utilization = this->_internal_minimum_slot_utilization();
  uint32_t raw_minimum_slot_utilization;
  memcpy(&raw_minimum_slot_utilization, &tmp_minimum_slot_utilization, sizeof(tmp_minimum_slot_utilization));
  if (raw_minimum_slot_utilization != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_StrategyDirect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching_StrategyDirect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_StrategyDirect::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching_StrategyDirect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching_StrategyDirect*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching_StrategyDirect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.StrategyDirect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_max_queue_delay_microseconds() != 0) {
    _this->_internal_set_max_queue_delay_microseconds(from._internal_max_queue_delay_microseconds());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minimum_slot_utilization = from._internal_minimum_slot_utilization();
  uint32_t raw_minimum_slot_utilization;
  memcpy(&raw_minimum_slot_utilization, &tmp_minimum_slot_utilization, sizeof(tmp_minimum_slot_utilization));
  if (raw_minimum_slot_utilization != 0) {
    _this->_internal_set_minimum_slot_utilization(from._internal_minimum_slot_utilization());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_StrategyDirect::CopyFrom(const ModelSequenceBatching_StrategyDirect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.StrategyDirect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_StrategyDirect::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_StrategyDirect::InternalSwap(ModelSequenceBatching_StrategyDirect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyDirect, _impl_.minimum_slot_utilization_)
      + sizeof(ModelSequenceBatching_StrategyDirect::_impl_.minimum_slot_utilization_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyDirect, _impl_.max_queue_delay_microseconds_)>(
          reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_),
          reinterpret_cast<char*>(&other->_impl_.max_queue_delay_microseconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_StrategyDirect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[32]);
}

// ===================================================================

class ModelSequenceBatching_StrategyOldest::_Internal {
 public:
};

ModelSequenceBatching_StrategyOldest::ModelSequenceBatching_StrategyOldest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.StrategyOldest)
}
ModelSequenceBatching_StrategyOldest::ModelSequenceBatching_StrategyOldest(const ModelSequenceBatching_StrategyOldest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching_StrategyOldest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.preferred_batch_size_){from._impl_.preferred_batch_size_}
    , /*decltype(_impl_._preferred_batch_size_cached_byte_size_)*/{0}
    , decltype(_impl_.max_candidate_sequences_){}
    , decltype(_impl_.preserve_ordering_){}
    , decltype(_impl_.max_queue_delay_microseconds_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_candidate_sequences_, &from._impl_.max_candidate_sequences_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_) -
    reinterpret_cast<char*>(&_impl_.max_candidate_sequences_)) + sizeof(_impl_.max_queue_delay_microseconds_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.StrategyOldest)
}

inline void ModelSequenceBatching_StrategyOldest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.preferred_batch_size_){arena}
    , /*decltype(_impl_._preferred_batch_size_cached_byte_size_)*/{0}
    , decltype(_impl_.max_candidate_sequences_){0}
    , decltype(_impl_.preserve_ordering_){false}
    , decltype(_impl_.max_queue_delay_microseconds_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelSequenceBatching_StrategyOldest::~ModelSequenceBatching_StrategyOldest() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.StrategyOldest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching_StrategyOldest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.preferred_batch_size_.~RepeatedField();
}

void ModelSequenceBatching_StrategyOldest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching_StrategyOldest::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.StrategyOldest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.preferred_batch_size_.Clear();
  ::memset(&_impl_.max_candidate_sequences_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_queue_delay_microseconds_) -
      reinterpret_cast<char*>(&_impl_.max_candidate_sequences_)) + sizeof(_impl_.max_queue_delay_microseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_StrategyOldest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 max_candidate_sequences = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.max_candidate_sequences_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 preferred_batch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_preferred_batch_size(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_queue_delay_microseconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.max_queue_delay_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool preserve_ordering = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.preserve_ordering_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_StrategyOldest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.StrategyOldest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 max_candidate_sequences = 1;
  if (this->_internal_max_candidate_sequences() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_candidate_sequences(), target);
  }

  // repeated int32 preferred_batch_size = 2;
  {
    int byte_size = _impl_._preferred_batch_size_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_preferred_batch_size(), byte_size, target);
    }
  }

  // uint64 max_queue_delay_microseconds = 3;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_queue_delay_microseconds(), target);
  }

  // bool preserve_ordering = 4;
  if (this->_internal_preserve_ordering() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_preserve_ordering(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.StrategyOldest)
  return target;
}

size_t ModelSequenceBatching_StrategyOldest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.StrategyOldest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 preferred_batch_size = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.preferred_batch_size_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._preferred_batch_size_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 max_candidate_sequences = 1;
  if (this->_internal_max_candidate_sequences() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_candidate_sequences());
  }

  // bool preserve_ordering = 4;
  if (this->_internal_preserve_ordering() != 0) {
    total_size += 1 + 1;
  }

  // uint64 max_queue_delay_microseconds = 3;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_queue_delay_microseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_StrategyOldest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching_StrategyOldest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_StrategyOldest::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching_StrategyOldest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching_StrategyOldest*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching_StrategyOldest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.StrategyOldest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.preferred_batch_size_.MergeFrom(from._impl_.preferred_batch_size_);
  if (from._internal_max_candidate_sequences() != 0) {
    _this->_internal_set_max_candidate_sequences(from._internal_max_candidate_sequences());
  }
  if (from._internal_preserve_ordering() != 0) {
    _this->_internal_set_preserve_ordering(from._internal_preserve_ordering());
  }
  if (from._internal_max_queue_delay_microseconds() != 0) {
    _this->_internal_set_max_queue_delay_microseconds(from._internal_max_queue_delay_microseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_StrategyOldest::CopyFrom(const ModelSequenceBatching_StrategyOldest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.StrategyOldest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_StrategyOldest::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_StrategyOldest::InternalSwap(ModelSequenceBatching_StrategyOldest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.preferred_batch_size_.InternalSwap(&other->_impl_.preferred_batch_size_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyOldest, _impl_.max_queue_delay_microseconds_)
      + sizeof(ModelSequenceBatching_StrategyOldest::_impl_.max_queue_delay_microseconds_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyOldest, _impl_.max_candidate_sequences_)>(
          reinterpret_cast<char*>(&_impl_.max_candidate_sequences_),
          reinterpret_cast<char*>(&other->_impl_.max_candidate_sequences_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_StrategyOldest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[33]);
}

// ===================================================================

class ModelSequenceBatching::_Internal {
 public:
  static const ::inference::ModelSequenceBatching_StrategyDirect& direct(const ModelSequenceBatching* msg);
  static const ::inference::ModelSequenceBatching_StrategyOldest& oldest(const ModelSequenceBatching* msg);
};

const ::inference::ModelSequenceBatching_StrategyDirect&
ModelSequenceBatching::_Internal::direct(const ModelSequenceBatching* msg) {
  return *msg->_impl_.strategy_choice_.direct_;
}
const ::inference::ModelSequenceBatching_StrategyOldest&
ModelSequenceBatching::_Internal::oldest(const ModelSequenceBatching* msg) {
  return *msg->_impl_.strategy_choice_.oldest_;
}
void ModelSequenceBatching::set_allocated_direct(::inference::ModelSequenceBatching_StrategyDirect* direct) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_strategy_choice();
  if (direct) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(direct);
    if (message_arena != submessage_arena) {
      direct = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direct, submessage_arena);
    }
    set_has_direct();
    _impl_.strategy_choice_.direct_ = direct;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.direct)
}
void ModelSequenceBatching::set_allocated_oldest(::inference::ModelSequenceBatching_StrategyOldest* oldest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_strategy_choice();
  if (oldest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oldest);
    if (message_arena != submessage_arena) {
      oldest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldest, submessage_arena);
    }
    set_has_oldest();
    _impl_.strategy_choice_.oldest_ = oldest;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.oldest)
}
ModelSequenceBatching::ModelSequenceBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching)
}
ModelSequenceBatching::ModelSequenceBatching(const ModelSequenceBatching& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelSequenceBatching* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.control_input_){from._impl_.control_input_}
    , decltype(_impl_.state_){from._impl_.state_}
    , decltype(_impl_.max_sequence_idle_microseconds_){}
    , decltype(_impl_.iterative_sequence_){}
    , decltype(_impl_.strategy_choice_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_sequence_idle_microseconds_, &from._impl_.max_sequence_idle_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.iterative_sequence_) -
    reinterpret_cast<char*>(&_impl_.max_sequence_idle_microseconds_)) + sizeof(_impl_.iterative_sequence_));
  clear_has_strategy_choice();
  switch (from.strategy_choice_case()) {
    case kDirect: {
      _this->_internal_mutable_direct()->::inference::ModelSequenceBatching_StrategyDirect::MergeFrom(
          from._internal_direct());
      break;
    }
    case kOldest: {
      _this->_internal_mutable_oldest()->::inference::ModelSequenceBatching_StrategyOldest::MergeFrom(
          from._internal_oldest());
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching)
}

inline void ModelSequenceBatching::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.control_input_){arena}
    , decltype(_impl_.state_){arena}
    , decltype(_impl_.max_sequence_idle_microseconds_){uint64_t{0u}}
    , decltype(_impl_.iterative_sequence_){false}
    , decltype(_impl_.strategy_choice_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_strategy_choice();
}

ModelSequenceBatching::~ModelSequenceBatching() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelSequenceBatching::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.control_input_.~RepeatedPtrField();
  _impl_.state_.~RepeatedPtrField();
  if (has_strategy_choice()) {
    clear_strategy_choice();
  }
}

void ModelSequenceBatching::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelSequenceBatching::clear_strategy_choice() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelSequenceBatching)
  switch (strategy_choice_case()) {
    case kDirect: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.strategy_choice_.direct_;
      }
      break;
    }
    case kOldest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.strategy_choice_.oldest_;
      }
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STRATEGY_CHOICE_NOT_SET;
}


void ModelSequenceBatching::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.control_input_.Clear();
  _impl_.state_.Clear();
  ::memset(&_impl_.max_sequence_idle_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.iterative_sequence_) -
      reinterpret_cast<char*>(&_impl_.max_sequence_idle_microseconds_)) + sizeof(_impl_.iterative_sequence_));
  clear_strategy_choice();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 max_sequence_idle_microseconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.max_sequence_idle_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_control_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_direct(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.State state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool iterative_sequence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.iterative_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 max_sequence_idle_microseconds = 1;
  if (this->_internal_max_sequence_idle_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_max_sequence_idle_microseconds(), target);
  }

  // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_control_input_size()); i < n; i++) {
    const auto& repfield = this->_internal_control_input(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
  if (_internal_has_direct()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::direct(this),
        _Internal::direct(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
  if (_internal_has_oldest()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::oldest(this),
        _Internal::oldest(this).GetCachedSize(), target, stream);
  }

  // repeated .inference.ModelSequenceBatching.State state = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool iterative_sequence = 6;
  if (this->_internal_iterative_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_iterative_sequence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching)
  return target;
}

size_t ModelSequenceBatching::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
  total_size += 1UL * this->_internal_control_input_size();
  for (const auto& msg : this->_impl_.control_input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelSequenceBatching.State state = 5;
  total_size += 1UL * this->_internal_state_size();
  for (const auto& msg : this->_impl_.state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 max_sequence_idle_microseconds = 1;
  if (this->_internal_max_sequence_idle_microseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_sequence_idle_microseconds());
  }

  // bool iterative_sequence = 6;
  if (this->_internal_iterative_sequence() != 0) {
    total_size += 1 + 1;
  }

  switch (strategy_choice_case()) {
    // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
    case kDirect: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.strategy_choice_.direct_);
      break;
    }
    // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
    case kOldest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.strategy_choice_.oldest_);
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelSequenceBatching::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching::GetClassData() const { return &_class_data_; }


void ModelSequenceBatching::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelSequenceBatching*>(&to_msg);
  auto& from = static_cast<const ModelSequenceBatching&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.control_input_.MergeFrom(from._impl_.control_input_);
  _this->_impl_.state_.MergeFrom(from._impl_.state_);
  if (from._internal_max_sequence_idle_microseconds() != 0) {
    _this->_internal_set_max_sequence_idle_microseconds(from._internal_max_sequence_idle_microseconds());
  }
  if (from._internal_iterative_sequence() != 0) {
    _this->_internal_set_iterative_sequence(from._internal_iterative_sequence());
  }
  switch (from.strategy_choice_case()) {
    case kDirect: {
      _this->_internal_mutable_direct()->::inference::ModelSequenceBatching_StrategyDirect::MergeFrom(
          from._internal_direct());
      break;
    }
    case kOldest: {
      _this->_internal_mutable_oldest()->::inference::ModelSequenceBatching_StrategyOldest::MergeFrom(
          from._internal_oldest());
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching::CopyFrom(const ModelSequenceBatching& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching::IsInitialized() const {
  return true;
}

void ModelSequenceBatching::InternalSwap(ModelSequenceBatching* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.control_input_.InternalSwap(&other->_impl_.control_input_);
  _impl_.state_.InternalSwap(&other->_impl_.state_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching, _impl_.iterative_sequence_)
      + sizeof(ModelSequenceBatching::_impl_.iterative_sequence_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching, _impl_.max_sequence_idle_microseconds_)>(
          reinterpret_cast<char*>(&_impl_.max_sequence_idle_microseconds_),
          reinterpret_cast<char*>(&other->_impl_.max_sequence_idle_microseconds_));
  swap(_impl_.strategy_choice_, other->_impl_.strategy_choice_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[34]);
}

// ===================================================================

ModelEnsembling_Step_InputMapEntry_DoNotUse::ModelEnsembling_Step_InputMapEntry_DoNotUse() {}
ModelEnsembling_Step_InputMapEntry_DoNotUse::ModelEnsembling_Step_InputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelEnsembling_Step_InputMapEntry_DoNotUse::MergeFrom(const ModelEnsembling_Step_InputMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling_Step_InputMapEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[35]);
}

// ===================================================================

ModelEnsembling_Step_OutputMapEntry_DoNotUse::ModelEnsembling_Step_OutputMapEntry_DoNotUse() {}
ModelEnsembling_Step_OutputMapEntry_DoNotUse::ModelEnsembling_Step_OutputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelEnsembling_Step_OutputMapEntry_DoNotUse::MergeFrom(const ModelEnsembling_Step_OutputMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling_Step_OutputMapEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[36]);
}

// ===================================================================

class ModelEnsembling_Step::_Internal {
 public:
};

ModelEnsembling_Step::ModelEnsembling_Step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelEnsembling_Step::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelEnsembling.Step)
}
ModelEnsembling_Step::ModelEnsembling_Step(const ModelEnsembling_Step& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelEnsembling_Step* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_map_)*/{}
    , /*decltype(_impl_.output_map_)*/{}
    , decltype(_impl_.model_name_){}
    , decltype(_impl_.model_namespace_){}
    , decltype(_impl_.model_version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.input_map_.MergeFrom(from._impl_.input_map_);
  _this->_impl_.output_map_.MergeFrom(from._impl_.output_map_);
  _impl_.model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_name().empty()) {
    _this->_impl_.model_name_.Set(from._internal_model_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_namespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_namespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_namespace().empty()) {
    _this->_impl_.model_namespace_.Set(from._internal_model_namespace(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.model_version_ = from._impl_.model_version_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelEnsembling.Step)
}

inline void ModelEnsembling_Step::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_map_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.output_map_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.model_name_){}
    , decltype(_impl_.model_namespace_){}
    , decltype(_impl_.model_version_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_namespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_namespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelEnsembling_Step::~ModelEnsembling_Step() {
  // @@protoc_insertion_point(destructor:inference.ModelEnsembling.Step)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelEnsembling_Step::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_map_.Destruct();
  _impl_.input_map_.~MapField();
  _impl_.output_map_.Destruct();
  _impl_.output_map_.~MapField();
  _impl_.model_name_.Destroy();
  _impl_.model_namespace_.Destroy();
}

void ModelEnsembling_Step::ArenaDtor(void* object) {
  ModelEnsembling_Step* _this = reinterpret_cast< ModelEnsembling_Step* >(object);
  _this->_impl_.input_map_.Destruct();
  _this->_impl_.output_map_.Destruct();
}
void ModelEnsembling_Step::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelEnsembling_Step::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelEnsembling.Step)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_map_.Clear();
  _impl_.output_map_.Clear();
  _impl_.model_name_.ClearToEmpty();
  _impl_.model_namespace_.ClearToEmpty();
  _impl_.model_version_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelEnsembling_Step::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelEnsembling.Step.model_name"));
        } else
          goto handle_unusual;
        continue;
      // int64 model_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> input_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.input_map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> output_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.output_map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string model_namespace = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_model_namespace();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelEnsembling.Step.model_namespace"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelEnsembling_Step::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelEnsembling.Step)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string model_name = 1;
  if (!this->_internal_model_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelEnsembling.Step.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // int64 model_version = 2;
  if (this->_internal_model_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_model_version(), target);
  }

  // map<string, string> input_map = 3;
  if (!this->_internal_input_map().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ModelEnsembling_Step_InputMapEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_input_map();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelEnsembling.Step.InputMapEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelEnsembling.Step.InputMapEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, string> output_map = 4;
  if (!this->_internal_output_map().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ModelEnsembling_Step_OutputMapEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_output_map();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelEnsembling.Step.OutputMapEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelEnsembling.Step.OutputMapEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string model_namespace = 5;
  if (!this->_internal_model_namespace().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_namespace().data(), static_cast<int>(this->_internal_model_namespace().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelEnsembling.Step.model_namespace");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_model_namespace(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelEnsembling.Step)
  return target;
}

size_t ModelEnsembling_Step::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelEnsembling.Step)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> input_map = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_input_map().begin();
      it != this->_internal_input_map().end(); ++it) {
    total_size += ModelEnsembling_Step_InputMapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> output_map = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_output_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_output_map().begin();
      it != this->_internal_output_map().end(); ++it) {
    total_size += ModelEnsembling_Step_OutputMapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string model_name = 1;
  if (!this->_internal_model_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  // string model_namespace = 5;
  if (!this->_internal_model_namespace().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_namespace());
  }

  // int64 model_version = 2;
  if (this->_internal_model_version() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_model_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelEnsembling_Step::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelEnsembling_Step::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelEnsembling_Step::GetClassData() const { return &_class_data_; }


void ModelEnsembling_Step::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelEnsembling_Step*>(&to_msg);
  auto& from = static_cast<const ModelEnsembling_Step&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelEnsembling.Step)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_map_.MergeFrom(from._impl_.input_map_);
  _this->_impl_.output_map_.MergeFrom(from._impl_.output_map_);
  if (!from._internal_model_name().empty()) {
    _this->_internal_set_model_name(from._internal_model_name());
  }
  if (!from._internal_model_namespace().empty()) {
    _this->_internal_set_model_namespace(from._internal_model_namespace());
  }
  if (from._internal_model_version() != 0) {
    _this->_internal_set_model_version(from._internal_model_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelEnsembling_Step::CopyFrom(const ModelEnsembling_Step& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelEnsembling.Step)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelEnsembling_Step::IsInitialized() const {
  return true;
}

void ModelEnsembling_Step::InternalSwap(ModelEnsembling_Step* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_map_.InternalSwap(&other->_impl_.input_map_);
  _impl_.output_map_.InternalSwap(&other->_impl_.output_map_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_name_, lhs_arena,
      &other->_impl_.model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_namespace_, lhs_arena,
      &other->_impl_.model_namespace_, rhs_arena
  );
  swap(_impl_.model_version_, other->_impl_.model_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling_Step::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[37]);
}

// ===================================================================

class ModelEnsembling::_Internal {
 public:
};

ModelEnsembling::ModelEnsembling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelEnsembling)
}
ModelEnsembling::ModelEnsembling(const ModelEnsembling& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelEnsembling* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.step_){from._impl_.step_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelEnsembling)
}

inline void ModelEnsembling::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.step_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelEnsembling::~ModelEnsembling() {
  // @@protoc_insertion_point(destructor:inference.ModelEnsembling)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelEnsembling::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.step_.~RepeatedPtrField();
}

void ModelEnsembling::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelEnsembling::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelEnsembling)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.step_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelEnsembling::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelEnsembling.Step step = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_step(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelEnsembling::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelEnsembling)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelEnsembling.Step step = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_step_size()); i < n; i++) {
    const auto& repfield = this->_internal_step(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelEnsembling)
  return target;
}

size_t ModelEnsembling::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelEnsembling)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelEnsembling.Step step = 1;
  total_size += 1UL * this->_internal_step_size();
  for (const auto& msg : this->_impl_.step_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelEnsembling::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelEnsembling::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelEnsembling::GetClassData() const { return &_class_data_; }


void ModelEnsembling::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelEnsembling*>(&to_msg);
  auto& from = static_cast<const ModelEnsembling&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelEnsembling)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.step_.MergeFrom(from._impl_.step_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelEnsembling::CopyFrom(const ModelEnsembling& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelEnsembling)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelEnsembling::IsInitialized() const {
  return true;
}

void ModelEnsembling::InternalSwap(ModelEnsembling* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.step_.InternalSwap(&other->_impl_.step_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[38]);
}

// ===================================================================

class ModelParameter::_Internal {
 public:
};

ModelParameter::ModelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelParameter)
}
ModelParameter::ModelParameter(const ModelParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelParameter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.string_value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.string_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_string_value().empty()) {
    _this->_impl_.string_value_.Set(from._internal_string_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelParameter)
}

inline void ModelParameter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.string_value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.string_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelParameter::~ModelParameter() {
  // @@protoc_insertion_point(destructor:inference.ModelParameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelParameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.string_value_.Destroy();
}

void ModelParameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelParameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.string_value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelParameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string string_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_string_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelParameter.string_value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelParameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelParameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string string_value = 1;
  if (!this->_internal_string_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelParameter.string_value");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_string_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelParameter)
  return target;
}

size_t ModelParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelParameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string string_value = 1;
  if (!this->_internal_string_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_string_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelParameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelParameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelParameter::GetClassData() const { return &_class_data_; }


void ModelParameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelParameter*>(&to_msg);
  auto& from = static_cast<const ModelParameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelParameter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_string_value().empty()) {
    _this->_internal_set_string_value(from._internal_string_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelParameter::CopyFrom(const ModelParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelParameter::IsInitialized() const {
  return true;
}

void ModelParameter::InternalSwap(ModelParameter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_value_, lhs_arena,
      &other->_impl_.string_value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelParameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[39]);
}

// ===================================================================

class ModelWarmup_Input::_Internal {
 public:
};

ModelWarmup_Input::ModelWarmup_Input(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelWarmup.Input)
}
ModelWarmup_Input::ModelWarmup_Input(const ModelWarmup_Input& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelWarmup_Input* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){from._impl_.dims_}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.input_data_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.data_type_ = from._impl_.data_type_;
  clear_has_input_data_type();
  switch (from.input_data_type_case()) {
    case kZeroData: {
      _this->_internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kRandomData: {
      _this->_internal_set_random_data(from._internal_random_data());
      break;
    }
    case kInputDataFile: {
      _this->_internal_set_input_data_file(from._internal_input_data_file());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelWarmup.Input)
}

inline void ModelWarmup_Input::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dims_){arena}
    , /*decltype(_impl_._dims_cached_byte_size_)*/{0}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.input_data_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_input_data_type();
}

ModelWarmup_Input::~ModelWarmup_Input() {
  // @@protoc_insertion_point(destructor:inference.ModelWarmup.Input)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelWarmup_Input::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dims_.~RepeatedField();
  if (has_input_data_type()) {
    clear_input_data_type();
  }
}

void ModelWarmup_Input::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelWarmup_Input::clear_input_data_type() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelWarmup.Input)
  switch (input_data_type_case()) {
    case kZeroData: {
      // No need to clear
      break;
    }
    case kRandomData: {
      // No need to clear
      break;
    }
    case kInputDataFile: {
      _impl_.input_data_type_.input_data_file_.Destroy();
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = INPUT_DATA_TYPE_NOT_SET;
}


void ModelWarmup_Input::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelWarmup.Input)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dims_.Clear();
  _impl_.data_type_ = 0;
  clear_input_data_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelWarmup_Input::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.DataType data_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_zero_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool random_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_random_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string input_data_file = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_input_data_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelWarmup.Input.input_data_file"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelWarmup_Input::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelWarmup.Input)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 2;
  {
    int byte_size = _impl_._dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_dims(), byte_size, target);
    }
  }

  // bool zero_data = 3;
  if (_internal_has_zero_data()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_zero_data(), target);
  }

  // bool random_data = 4;
  if (_internal_has_random_data()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_random_data(), target);
  }

  // string input_data_file = 5;
  if (_internal_has_input_data_file()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input_data_file().data(), static_cast<int>(this->_internal_input_data_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelWarmup.Input.input_data_file");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_input_data_file(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelWarmup.Input)
  return target;
}

size_t ModelWarmup_Input::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelWarmup.Input)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  switch (input_data_type_case()) {
    // bool zero_data = 3;
    case kZeroData: {
      total_size += 1 + 1;
      break;
    }
    // bool random_data = 4;
    case kRandomData: {
      total_size += 1 + 1;
      break;
    }
    // string input_data_file = 5;
    case kInputDataFile: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_input_data_file());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelWarmup_Input::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelWarmup_Input::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelWarmup_Input::GetClassData() const { return &_class_data_; }


void ModelWarmup_Input::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelWarmup_Input*>(&to_msg);
  auto& from = static_cast<const ModelWarmup_Input&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelWarmup.Input)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dims_.MergeFrom(from._impl_.dims_);
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  switch (from.input_data_type_case()) {
    case kZeroData: {
      _this->_internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kRandomData: {
      _this->_internal_set_random_data(from._internal_random_data());
      break;
    }
    case kInputDataFile: {
      _this->_internal_set_input_data_file(from._internal_input_data_file());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelWarmup_Input::CopyFrom(const ModelWarmup_Input& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelWarmup.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelWarmup_Input::IsInitialized() const {
  return true;
}

void ModelWarmup_Input::InternalSwap(ModelWarmup_Input* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dims_.InternalSwap(&other->_impl_.dims_);
  swap(_impl_.data_type_, other->_impl_.data_type_);
  swap(_impl_.input_data_type_, other->_impl_.input_data_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelWarmup_Input::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[40]);
}

// ===================================================================

ModelWarmup_InputsEntry_DoNotUse::ModelWarmup_InputsEntry_DoNotUse() {}
ModelWarmup_InputsEntry_DoNotUse::ModelWarmup_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelWarmup_InputsEntry_DoNotUse::MergeFrom(const ModelWarmup_InputsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelWarmup_InputsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[41]);
}

// ===================================================================

class ModelWarmup::_Internal {
 public:
};

ModelWarmup::ModelWarmup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelWarmup::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelWarmup)
}
ModelWarmup::ModelWarmup(const ModelWarmup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelWarmup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.inputs_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.batch_size_){}
    , decltype(_impl_.count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.inputs_.MergeFrom(from._impl_.inputs_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.batch_size_, &from._impl_.batch_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.batch_size_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelWarmup)
}

inline void ModelWarmup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.inputs_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.batch_size_){0u}
    , decltype(_impl_.count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelWarmup::~ModelWarmup() {
  // @@protoc_insertion_point(destructor:inference.ModelWarmup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelWarmup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.inputs_.Destruct();
  _impl_.inputs_.~MapField();
  _impl_.name_.Destroy();
}

void ModelWarmup::ArenaDtor(void* object) {
  ModelWarmup* _this = reinterpret_cast< ModelWarmup* >(object);
  _this->_impl_.inputs_.Destruct();
}
void ModelWarmup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelWarmup::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelWarmup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.inputs_.Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.batch_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.batch_size_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelWarmup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelWarmup.name"));
        } else
          goto handle_unusual;
        continue;
      // uint32 batch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelWarmup.Input> inputs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.inputs_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelWarmup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelWarmup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelWarmup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // uint32 batch_size = 2;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_batch_size(), target);
  }

  // map<string, .inference.ModelWarmup.Input> inputs = 3;
  if (!this->_internal_inputs().empty()) {
    using MapType = ::_pb::Map<std::string, ::inference::ModelWarmup_Input>;
    using WireHelper = ModelWarmup_InputsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_inputs();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelWarmup.InputsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // uint32 count = 4;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelWarmup)
  return target;
}

size_t ModelWarmup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelWarmup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .inference.ModelWarmup.Input> inputs = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_inputs_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >::const_iterator
      it = this->_internal_inputs().begin();
      it != this->_internal_inputs().end(); ++it) {
    total_size += ModelWarmup_InputsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 batch_size = 2;
  if (this->_internal_batch_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_batch_size());
  }

  // uint32 count = 4;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelWarmup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelWarmup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelWarmup::GetClassData() const { return &_class_data_; }


void ModelWarmup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelWarmup*>(&to_msg);
  auto& from = static_cast<const ModelWarmup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelWarmup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.inputs_.MergeFrom(from._impl_.inputs_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_batch_size() != 0) {
    _this->_internal_set_batch_size(from._internal_batch_size());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelWarmup::CopyFrom(const ModelWarmup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelWarmup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelWarmup::IsInitialized() const {
  return true;
}

void ModelWarmup::InternalSwap(ModelWarmup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.inputs_.InternalSwap(&other->_impl_.inputs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelWarmup, _impl_.count_)
      + sizeof(ModelWarmup::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(ModelWarmup, _impl_.batch_size_)>(
          reinterpret_cast<char*>(&_impl_.batch_size_),
          reinterpret_cast<char*>(&other->_impl_.batch_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelWarmup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[42]);
}

// ===================================================================

class ModelOperations::_Internal {
 public:
};

ModelOperations::ModelOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelOperations)
}
ModelOperations::ModelOperations(const ModelOperations& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelOperations* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.op_library_filename_){from._impl_.op_library_filename_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelOperations)
}

inline void ModelOperations::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.op_library_filename_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelOperations::~ModelOperations() {
  // @@protoc_insertion_point(destructor:inference.ModelOperations)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelOperations::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.op_library_filename_.~RepeatedPtrField();
}

void ModelOperations::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelOperations::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOperations)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.op_library_filename_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOperations::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string op_library_filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_op_library_filename();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "inference.ModelOperations.op_library_filename"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOperations::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOperations)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string op_library_filename = 1;
  for (int i = 0, n = this->_internal_op_library_filename_size(); i < n; i++) {
    const auto& s = this->_internal_op_library_filename(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOperations.op_library_filename");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOperations)
  return target;
}

size_t ModelOperations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOperations)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string op_library_filename = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.op_library_filename_.size());
  for (int i = 0, n = _impl_.op_library_filename_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.op_library_filename_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOperations::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelOperations::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOperations::GetClassData() const { return &_class_data_; }


void ModelOperations::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelOperations*>(&to_msg);
  auto& from = static_cast<const ModelOperations&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOperations)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.op_library_filename_.MergeFrom(from._impl_.op_library_filename_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOperations::CopyFrom(const ModelOperations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOperations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOperations::IsInitialized() const {
  return true;
}

void ModelOperations::InternalSwap(ModelOperations* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.op_library_filename_.InternalSwap(&other->_impl_.op_library_filename_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOperations::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[43]);
}

// ===================================================================

class ModelTransactionPolicy::_Internal {
 public:
};

ModelTransactionPolicy::ModelTransactionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelTransactionPolicy)
}
ModelTransactionPolicy::ModelTransactionPolicy(const ModelTransactionPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelTransactionPolicy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.decoupled_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.decoupled_ = from._impl_.decoupled_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelTransactionPolicy)
}

inline void ModelTransactionPolicy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.decoupled_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelTransactionPolicy::~ModelTransactionPolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelTransactionPolicy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelTransactionPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelTransactionPolicy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelTransactionPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelTransactionPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.decoupled_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelTransactionPolicy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool decoupled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.decoupled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelTransactionPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelTransactionPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool decoupled = 1;
  if (this->_internal_decoupled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_decoupled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelTransactionPolicy)
  return target;
}

size_t ModelTransactionPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelTransactionPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool decoupled = 1;
  if (this->_internal_decoupled() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelTransactionPolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelTransactionPolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelTransactionPolicy::GetClassData() const { return &_class_data_; }


void ModelTransactionPolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelTransactionPolicy*>(&to_msg);
  auto& from = static_cast<const ModelTransactionPolicy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelTransactionPolicy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_decoupled() != 0) {
    _this->_internal_set_decoupled(from._internal_decoupled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelTransactionPolicy::CopyFrom(const ModelTransactionPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelTransactionPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelTransactionPolicy::IsInitialized() const {
  return true;
}

void ModelTransactionPolicy::InternalSwap(ModelTransactionPolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.decoupled_, other->_impl_.decoupled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelTransactionPolicy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[44]);
}

// ===================================================================

ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse() {}
ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::MergeFrom(const ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[45]);
}

// ===================================================================

class ModelRepositoryAgents_Agent::_Internal {
 public:
};

ModelRepositoryAgents_Agent::ModelRepositoryAgents_Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelRepositoryAgents_Agent::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelRepositoryAgents.Agent)
}
ModelRepositoryAgents_Agent::ModelRepositoryAgents_Agent(const ModelRepositoryAgents_Agent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelRepositoryAgents_Agent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelRepositoryAgents.Agent)
}

inline void ModelRepositoryAgents_Agent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelRepositoryAgents_Agent::~ModelRepositoryAgents_Agent() {
  // @@protoc_insertion_point(destructor:inference.ModelRepositoryAgents.Agent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelRepositoryAgents_Agent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.Destruct();
  _impl_.parameters_.~MapField();
  _impl_.name_.Destroy();
}

void ModelRepositoryAgents_Agent::ArenaDtor(void* object) {
  ModelRepositoryAgents_Agent* _this = reinterpret_cast< ModelRepositoryAgents_Agent* >(object);
  _this->_impl_.parameters_.Destruct();
}
void ModelRepositoryAgents_Agent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelRepositoryAgents_Agent::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRepositoryAgents.Agent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRepositoryAgents_Agent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelRepositoryAgents.Agent.name"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRepositoryAgents_Agent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRepositoryAgents.Agent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelRepositoryAgents.Agent.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // map<string, string> parameters = 2;
  if (!this->_internal_parameters().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_parameters();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelRepositoryAgents.Agent.ParametersEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelRepositoryAgents.Agent.ParametersEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRepositoryAgents.Agent)
  return target;
}

size_t ModelRepositoryAgents_Agent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRepositoryAgents.Agent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRepositoryAgents_Agent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelRepositoryAgents_Agent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRepositoryAgents_Agent::GetClassData() const { return &_class_data_; }


void ModelRepositoryAgents_Agent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelRepositoryAgents_Agent*>(&to_msg);
  auto& from = static_cast<const ModelRepositoryAgents_Agent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRepositoryAgents.Agent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRepositoryAgents_Agent::CopyFrom(const ModelRepositoryAgents_Agent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRepositoryAgents.Agent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRepositoryAgents_Agent::IsInitialized() const {
  return true;
}

void ModelRepositoryAgents_Agent::InternalSwap(ModelRepositoryAgents_Agent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRepositoryAgents_Agent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[46]);
}

// ===================================================================

class ModelRepositoryAgents::_Internal {
 public:
};

ModelRepositoryAgents::ModelRepositoryAgents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelRepositoryAgents)
}
ModelRepositoryAgents::ModelRepositoryAgents(const ModelRepositoryAgents& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelRepositoryAgents* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.agents_){from._impl_.agents_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelRepositoryAgents)
}

inline void ModelRepositoryAgents::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.agents_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelRepositoryAgents::~ModelRepositoryAgents() {
  // @@protoc_insertion_point(destructor:inference.ModelRepositoryAgents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelRepositoryAgents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.agents_.~RepeatedPtrField();
}

void ModelRepositoryAgents::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelRepositoryAgents::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRepositoryAgents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.agents_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRepositoryAgents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_agents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRepositoryAgents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRepositoryAgents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_agents_size()); i < n; i++) {
    const auto& repfield = this->_internal_agents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRepositoryAgents)
  return target;
}

size_t ModelRepositoryAgents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRepositoryAgents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
  total_size += 1UL * this->_internal_agents_size();
  for (const auto& msg : this->_impl_.agents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRepositoryAgents::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelRepositoryAgents::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRepositoryAgents::GetClassData() const { return &_class_data_; }


void ModelRepositoryAgents::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelRepositoryAgents*>(&to_msg);
  auto& from = static_cast<const ModelRepositoryAgents&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRepositoryAgents)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.agents_.MergeFrom(from._impl_.agents_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRepositoryAgents::CopyFrom(const ModelRepositoryAgents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRepositoryAgents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRepositoryAgents::IsInitialized() const {
  return true;
}

void ModelRepositoryAgents::InternalSwap(ModelRepositoryAgents* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.agents_.InternalSwap(&other->_impl_.agents_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRepositoryAgents::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[47]);
}

// ===================================================================

class ModelResponseCache::_Internal {
 public:
};

ModelResponseCache::ModelResponseCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:inference.ModelResponseCache)
}
ModelResponseCache::ModelResponseCache(const ModelResponseCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelResponseCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.enable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enable_ = from._impl_.enable_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelResponseCache)
}

inline void ModelResponseCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.enable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelResponseCache::~ModelResponseCache() {
  // @@protoc_insertion_point(destructor:inference.ModelResponseCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelResponseCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelResponseCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelResponseCache::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelResponseCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelResponseCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelResponseCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelResponseCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelResponseCache)
  return target;
}

size_t ModelResponseCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelResponseCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelResponseCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelResponseCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelResponseCache::GetClassData() const { return &_class_data_; }


void ModelResponseCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelResponseCache*>(&to_msg);
  auto& from = static_cast<const ModelResponseCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelResponseCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_enable() != 0) {
    _this->_internal_set_enable(from._internal_enable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelResponseCache::CopyFrom(const ModelResponseCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelResponseCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelResponseCache::IsInitialized() const {
  return true;
}

void ModelResponseCache::InternalSwap(ModelResponseCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.enable_, other->_impl_.enable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelResponseCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[48]);
}

// ===================================================================

ModelConfig_CcModelFilenamesEntry_DoNotUse::ModelConfig_CcModelFilenamesEntry_DoNotUse() {}
ModelConfig_CcModelFilenamesEntry_DoNotUse::ModelConfig_CcModelFilenamesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelConfig_CcModelFilenamesEntry_DoNotUse::MergeFrom(const ModelConfig_CcModelFilenamesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig_CcModelFilenamesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[49]);
}

// ===================================================================

ModelConfig_MetricTagsEntry_DoNotUse::ModelConfig_MetricTagsEntry_DoNotUse() {}
ModelConfig_MetricTagsEntry_DoNotUse::ModelConfig_MetricTagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelConfig_MetricTagsEntry_DoNotUse::MergeFrom(const ModelConfig_MetricTagsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig_MetricTagsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[50]);
}

// ===================================================================

ModelConfig_ParametersEntry_DoNotUse::ModelConfig_ParametersEntry_DoNotUse() {}
ModelConfig_ParametersEntry_DoNotUse::ModelConfig_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelConfig_ParametersEntry_DoNotUse::MergeFrom(const ModelConfig_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[51]);
}

// ===================================================================

class ModelConfig::_Internal {
 public:
  static const ::inference::ModelVersionPolicy& version_policy(const ModelConfig* msg);
  static const ::inference::ModelOptimizationPolicy& optimization(const ModelConfig* msg);
  static const ::inference::ModelDynamicBatching& dynamic_batching(const ModelConfig* msg);
  static const ::inference::ModelSequenceBatching& sequence_batching(const ModelConfig* msg);
  static const ::inference::ModelEnsembling& ensemble_scheduling(const ModelConfig* msg);
  static const ::inference::ModelOperations& model_operations(const ModelConfig* msg);
  static const ::inference::ModelTransactionPolicy& model_transaction_policy(const ModelConfig* msg);
  static const ::inference::ModelRepositoryAgents& model_repository_agents(const ModelConfig* msg);
  static const ::inference::ModelResponseCache& response_cache(const ModelConfig* msg);
};

const ::inference::ModelVersionPolicy&
ModelConfig::_Internal::version_policy(const ModelConfig* msg) {
  return *msg->_impl_.version_policy_;
}
const ::inference::ModelOptimizationPolicy&
ModelConfig::_Internal::optimization(const ModelConfig* msg) {
  return *msg->_impl_.optimization_;
}
const ::inference::ModelDynamicBatching&
ModelConfig::_Internal::dynamic_batching(const ModelConfig* msg) {
  return *msg->_impl_.scheduling_choice_.dynamic_batching_;
}
const ::inference::ModelSequenceBatching&
ModelConfig::_Internal::sequence_batching(const ModelConfig* msg) {
  return *msg->_impl_.scheduling_choice_.sequence_batching_;
}
const ::inference::ModelEnsembling&
ModelConfig::_Internal::ensemble_scheduling(const ModelConfig* msg) {
  return *msg->_impl_.scheduling_choice_.ensemble_scheduling_;
}
const ::inference::ModelOperations&
ModelConfig::_Internal::model_operations(const ModelConfig* msg) {
  return *msg->_impl_.model_operations_;
}
const ::inference::ModelTransactionPolicy&
ModelConfig::_Internal::model_transaction_policy(const ModelConfig* msg) {
  return *msg->_impl_.model_transaction_policy_;
}
const ::inference::ModelRepositoryAgents&
ModelConfig::_Internal::model_repository_agents(const ModelConfig* msg) {
  return *msg->_impl_.model_repository_agents_;
}
const ::inference::ModelResponseCache&
ModelConfig::_Internal::response_cache(const ModelConfig* msg) {
  return *msg->_impl_.response_cache_;
}
void ModelConfig::set_allocated_dynamic_batching(::inference::ModelDynamicBatching* dynamic_batching) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scheduling_choice();
  if (dynamic_batching) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dynamic_batching);
    if (message_arena != submessage_arena) {
      dynamic_batching = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_batching, submessage_arena);
    }
    set_has_dynamic_batching();
    _impl_.scheduling_choice_.dynamic_batching_ = dynamic_batching;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.dynamic_batching)
}
void ModelConfig::set_allocated_sequence_batching(::inference::ModelSequenceBatching* sequence_batching) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scheduling_choice();
  if (sequence_batching) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sequence_batching);
    if (message_arena != submessage_arena) {
      sequence_batching = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence_batching, submessage_arena);
    }
    set_has_sequence_batching();
    _impl_.scheduling_choice_.sequence_batching_ = sequence_batching;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.sequence_batching)
}
void ModelConfig::set_allocated_ensemble_scheduling(::inference::ModelEnsembling* ensemble_scheduling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scheduling_choice();
  if (ensemble_scheduling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ensemble_scheduling);
    if (message_arena != submessage_arena) {
      ensemble_scheduling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ensemble_scheduling, submessage_arena);
    }
    set_has_ensemble_scheduling();
    _impl_.scheduling_choice_.ensemble_scheduling_ = ensemble_scheduling;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.ensemble_scheduling)
}
ModelConfig::ModelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelConfig::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelConfig)
}
ModelConfig::ModelConfig(const ModelConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.input_){from._impl_.input_}
    , decltype(_impl_.output_){from._impl_.output_}
    , decltype(_impl_.instance_group_){from._impl_.instance_group_}
    , /*decltype(_impl_.cc_model_filenames_)*/{}
    , /*decltype(_impl_.metric_tags_)*/{}
    , /*decltype(_impl_.parameters_)*/{}
    , decltype(_impl_.model_warmup_){from._impl_.model_warmup_}
    , decltype(_impl_.batch_input_){from._impl_.batch_input_}
    , decltype(_impl_.batch_output_){from._impl_.batch_output_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.default_model_filename_){}
    , decltype(_impl_.backend_){}
    , decltype(_impl_.runtime_){}
    , decltype(_impl_.version_policy_){nullptr}
    , decltype(_impl_.optimization_){nullptr}
    , decltype(_impl_.model_operations_){nullptr}
    , decltype(_impl_.model_transaction_policy_){nullptr}
    , decltype(_impl_.model_repository_agents_){nullptr}
    , decltype(_impl_.response_cache_){nullptr}
    , decltype(_impl_.max_batch_size_){}
    , decltype(_impl_.scheduling_choice_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.cc_model_filenames_.MergeFrom(from._impl_.cc_model_filenames_);
  _this->_impl_.metric_tags_.MergeFrom(from._impl_.metric_tags_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_platform().empty()) {
    _this->_impl_.platform_.Set(from._internal_platform(), 
      _this->GetArenaForAllocation());
  }
  _impl_.default_model_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_model_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_model_filename().empty()) {
    _this->_impl_.default_model_filename_.Set(from._internal_default_model_filename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.backend_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.backend_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_backend().empty()) {
    _this->_impl_.backend_.Set(from._internal_backend(), 
      _this->GetArenaForAllocation());
  }
  _impl_.runtime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.runtime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_runtime().empty()) {
    _this->_impl_.runtime_.Set(from._internal_runtime(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_version_policy()) {
    _this->_impl_.version_policy_ = new ::inference::ModelVersionPolicy(*from._impl_.version_policy_);
  }
  if (from._internal_has_optimization()) {
    _this->_impl_.optimization_ = new ::inference::ModelOptimizationPolicy(*from._impl_.optimization_);
  }
  if (from._internal_has_model_operations()) {
    _this->_impl_.model_operations_ = new ::inference::ModelOperations(*from._impl_.model_operations_);
  }
  if (from._internal_has_model_transaction_policy()) {
    _this->_impl_.model_transaction_policy_ = new ::inference::ModelTransactionPolicy(*from._impl_.model_transaction_policy_);
  }
  if (from._internal_has_model_repository_agents()) {
    _this->_impl_.model_repository_agents_ = new ::inference::ModelRepositoryAgents(*from._impl_.model_repository_agents_);
  }
  if (from._internal_has_response_cache()) {
    _this->_impl_.response_cache_ = new ::inference::ModelResponseCache(*from._impl_.response_cache_);
  }
  _this->_impl_.max_batch_size_ = from._impl_.max_batch_size_;
  clear_has_scheduling_choice();
  switch (from.scheduling_choice_case()) {
    case kDynamicBatching: {
      _this->_internal_mutable_dynamic_batching()->::inference::ModelDynamicBatching::MergeFrom(
          from._internal_dynamic_batching());
      break;
    }
    case kSequenceBatching: {
      _this->_internal_mutable_sequence_batching()->::inference::ModelSequenceBatching::MergeFrom(
          from._internal_sequence_batching());
      break;
    }
    case kEnsembleScheduling: {
      _this->_internal_mutable_ensemble_scheduling()->::inference::ModelEnsembling::MergeFrom(
          from._internal_ensemble_scheduling());
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelConfig)
}

inline void ModelConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.input_){arena}
    , decltype(_impl_.output_){arena}
    , decltype(_impl_.instance_group_){arena}
    , /*decltype(_impl_.cc_model_filenames_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.metric_tags_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.parameters_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.model_warmup_){arena}
    , decltype(_impl_.batch_input_){arena}
    , decltype(_impl_.batch_output_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.default_model_filename_){}
    , decltype(_impl_.backend_){}
    , decltype(_impl_.runtime_){}
    , decltype(_impl_.version_policy_){nullptr}
    , decltype(_impl_.optimization_){nullptr}
    , decltype(_impl_.model_operations_){nullptr}
    , decltype(_impl_.model_transaction_policy_){nullptr}
    , decltype(_impl_.model_repository_agents_){nullptr}
    , decltype(_impl_.response_cache_){nullptr}
    , decltype(_impl_.max_batch_size_){0}
    , decltype(_impl_.scheduling_choice_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_model_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_model_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.backend_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.backend_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.runtime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.runtime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_scheduling_choice();
}

ModelConfig::~ModelConfig() {
  // @@protoc_insertion_point(destructor:inference.ModelConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_.~RepeatedPtrField();
  _impl_.output_.~RepeatedPtrField();
  _impl_.instance_group_.~RepeatedPtrField();
  _impl_.cc_model_filenames_.Destruct();
  _impl_.cc_model_filenames_.~MapField();
  _impl_.metric_tags_.Destruct();
  _impl_.metric_tags_.~MapField();
  _impl_.parameters_.Destruct();
  _impl_.parameters_.~MapField();
  _impl_.model_warmup_.~RepeatedPtrField();
  _impl_.batch_input_.~RepeatedPtrField();
  _impl_.batch_output_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.platform_.Destroy();
  _impl_.default_model_filename_.Destroy();
  _impl_.backend_.Destroy();
  _impl_.runtime_.Destroy();
  if (this != internal_default_instance()) delete _impl_.version_policy_;
  if (this != internal_default_instance()) delete _impl_.optimization_;
  if (this != internal_default_instance()) delete _impl_.model_operations_;
  if (this != internal_default_instance()) delete _impl_.model_transaction_policy_;
  if (this != internal_default_instance()) delete _impl_.model_repository_agents_;
  if (this != internal_default_instance()) delete _impl_.response_cache_;
  if (has_scheduling_choice()) {
    clear_scheduling_choice();
  }
}

void ModelConfig::ArenaDtor(void* object) {
  ModelConfig* _this = reinterpret_cast< ModelConfig* >(object);
  _this->_impl_.cc_model_filenames_.Destruct();
  _this->_impl_.metric_tags_.Destruct();
  _this->_impl_.parameters_.Destruct();
}
void ModelConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelConfig::clear_scheduling_choice() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelConfig)
  switch (scheduling_choice_case()) {
    case kDynamicBatching: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scheduling_choice_.dynamic_batching_;
      }
      break;
    }
    case kSequenceBatching: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scheduling_choice_.sequence_batching_;
      }
      break;
    }
    case kEnsembleScheduling: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scheduling_choice_.ensemble_scheduling_;
      }
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SCHEDULING_CHOICE_NOT_SET;
}


void ModelConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_.Clear();
  _impl_.output_.Clear();
  _impl_.instance_group_.Clear();
  _impl_.cc_model_filenames_.Clear();
  _impl_.metric_tags_.Clear();
  _impl_.parameters_.Clear();
  _impl_.model_warmup_.Clear();
  _impl_.batch_input_.Clear();
  _impl_.batch_output_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.platform_.ClearToEmpty();
  _impl_.default_model_filename_.ClearToEmpty();
  _impl_.backend_.ClearToEmpty();
  _impl_.runtime_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.version_policy_ != nullptr) {
    delete _impl_.version_policy_;
  }
  _impl_.version_policy_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.optimization_ != nullptr) {
    delete _impl_.optimization_;
  }
  _impl_.optimization_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.model_operations_ != nullptr) {
    delete _impl_.model_operations_;
  }
  _impl_.model_operations_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.model_transaction_policy_ != nullptr) {
    delete _impl_.model_transaction_policy_;
  }
  _impl_.model_transaction_policy_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.model_repository_agents_ != nullptr) {
    delete _impl_.model_repository_agents_;
  }
  _impl_.model_repository_agents_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.response_cache_ != nullptr) {
    delete _impl_.response_cache_;
  }
  _impl_.response_cache_ = nullptr;
  _impl_.max_batch_size_ = 0;
  clear_scheduling_choice();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelConfig.name"));
        } else
          goto handle_unusual;
        continue;
      // string platform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelConfig.platform"));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelVersionPolicy version_policy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_version_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_batch_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.max_batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelInput input = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelOutput output = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelInstanceGroup instance_group = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_instance_group(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string default_model_filename = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_default_model_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelConfig.default_model_filename"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> cc_model_filenames = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.cc_model_filenames_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> metric_tags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.metric_tags_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelDynamicBatching dynamic_batching = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_dynamic_batching(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy optimization = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_optimization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelSequenceBatching sequence_batching = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_sequence_batching(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelParameter> parameters = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelEnsembling ensemble_scheduling = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_ensemble_scheduling(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelWarmup model_warmup = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_model_warmup(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string backend = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_backend();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelConfig.backend"));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOperations model_operations = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_operations(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelTransactionPolicy model_transaction_policy = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_transaction_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.BatchInput batch_input = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_batch_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.BatchOutput batch_output = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_batch_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelRepositoryAgents model_repository_agents = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_repository_agents(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelResponseCache response_cache = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_cache(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string runtime = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_runtime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "inference.ModelConfig.runtime"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string platform = 2;
  if (!this->_internal_platform().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.platform");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_platform(), target);
  }

  // .inference.ModelVersionPolicy version_policy = 3;
  if (this->_internal_has_version_policy()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::version_policy(this),
        _Internal::version_policy(this).GetCachedSize(), target, stream);
  }

  // int32 max_batch_size = 4;
  if (this->_internal_max_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_batch_size(), target);
  }

  // repeated .inference.ModelInput input = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_size()); i < n; i++) {
    const auto& repfield = this->_internal_input(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .inference.ModelOutput output = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_output_size()); i < n; i++) {
    const auto& repfield = this->_internal_output(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .inference.ModelInstanceGroup instance_group = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_instance_group_size()); i < n; i++) {
    const auto& repfield = this->_internal_instance_group(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string default_model_filename = 8;
  if (!this->_internal_default_model_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_default_model_filename().data(), static_cast<int>(this->_internal_default_model_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.default_model_filename");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_default_model_filename(), target);
  }

  // map<string, string> cc_model_filenames = 9;
  if (!this->_internal_cc_model_filenames().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ModelConfig_CcModelFilenamesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_cc_model_filenames();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelConfig.CcModelFilenamesEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelConfig.CcModelFilenamesEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(9, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(9, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, string> metric_tags = 10;
  if (!this->_internal_metric_tags().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ModelConfig_MetricTagsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_metric_tags();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelConfig.MetricTagsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelConfig.MetricTagsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .inference.ModelDynamicBatching dynamic_batching = 11;
  if (_internal_has_dynamic_batching()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::dynamic_batching(this),
        _Internal::dynamic_batching(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelOptimizationPolicy optimization = 12;
  if (this->_internal_has_optimization()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::optimization(this),
        _Internal::optimization(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelSequenceBatching sequence_batching = 13;
  if (_internal_has_sequence_batching()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::sequence_batching(this),
        _Internal::sequence_batching(this).GetCachedSize(), target, stream);
  }

  // map<string, .inference.ModelParameter> parameters = 14;
  if (!this->_internal_parameters().empty()) {
    using MapType = ::_pb::Map<std::string, ::inference::ModelParameter>;
    using WireHelper = ModelConfig_ParametersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_parameters();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "inference.ModelConfig.ParametersEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(14, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(14, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .inference.ModelEnsembling ensemble_scheduling = 15;
  if (_internal_has_ensemble_scheduling()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::ensemble_scheduling(this),
        _Internal::ensemble_scheduling(this).GetCachedSize(), target, stream);
  }

  // repeated .inference.ModelWarmup model_warmup = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_model_warmup_size()); i < n; i++) {
    const auto& repfield = this->_internal_model_warmup(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string backend = 17;
  if (!this->_internal_backend().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_backend().data(), static_cast<int>(this->_internal_backend().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.backend");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_backend(), target);
  }

  // .inference.ModelOperations model_operations = 18;
  if (this->_internal_has_model_operations()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::model_operations(this),
        _Internal::model_operations(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelTransactionPolicy model_transaction_policy = 19;
  if (this->_internal_has_model_transaction_policy()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::model_transaction_policy(this),
        _Internal::model_transaction_policy(this).GetCachedSize(), target, stream);
  }

  // repeated .inference.BatchInput batch_input = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_batch_input_size()); i < n; i++) {
    const auto& repfield = this->_internal_batch_input(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .inference.BatchOutput batch_output = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_batch_output_size()); i < n; i++) {
    const auto& repfield = this->_internal_batch_output(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .inference.ModelRepositoryAgents model_repository_agents = 23;
  if (this->_internal_has_model_repository_agents()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::model_repository_agents(this),
        _Internal::model_repository_agents(this).GetCachedSize(), target, stream);
  }

  // .inference.ModelResponseCache response_cache = 24;
  if (this->_internal_has_response_cache()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::response_cache(this),
        _Internal::response_cache(this).GetCachedSize(), target, stream);
  }

  // string runtime = 25;
  if (!this->_internal_runtime().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_runtime().data(), static_cast<int>(this->_internal_runtime().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.runtime");
    target = stream->WriteStringMaybeAliased(
        25, this->_internal_runtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelConfig)
  return target;
}

size_t ModelConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelInput input = 5;
  total_size += 1UL * this->_internal_input_size();
  for (const auto& msg : this->_impl_.input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelOutput output = 6;
  total_size += 1UL * this->_internal_output_size();
  for (const auto& msg : this->_impl_.output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelInstanceGroup instance_group = 7;
  total_size += 1UL * this->_internal_instance_group_size();
  for (const auto& msg : this->_impl_.instance_group_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> cc_model_filenames = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_cc_model_filenames_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_cc_model_filenames().begin();
      it != this->_internal_cc_model_filenames().end(); ++it) {
    total_size += ModelConfig_CcModelFilenamesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> metric_tags = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_metric_tags_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_metric_tags().begin();
      it != this->_internal_metric_tags().end(); ++it) {
    total_size += ModelConfig_MetricTagsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .inference.ModelParameter> parameters = 14;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += ModelConfig_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .inference.ModelWarmup model_warmup = 16;
  total_size += 2UL * this->_internal_model_warmup_size();
  for (const auto& msg : this->_impl_.model_warmup_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.BatchInput batch_input = 20;
  total_size += 2UL * this->_internal_batch_input_size();
  for (const auto& msg : this->_impl_.batch_input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.BatchOutput batch_output = 21;
  total_size += 2UL * this->_internal_batch_output_size();
  for (const auto& msg : this->_impl_.batch_output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string platform = 2;
  if (!this->_internal_platform().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_platform());
  }

  // string default_model_filename = 8;
  if (!this->_internal_default_model_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_default_model_filename());
  }

  // string backend = 17;
  if (!this->_internal_backend().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_backend());
  }

  // string runtime = 25;
  if (!this->_internal_runtime().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_runtime());
  }

  // .inference.ModelVersionPolicy version_policy = 3;
  if (this->_internal_has_version_policy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.version_policy_);
  }

  // .inference.ModelOptimizationPolicy optimization = 12;
  if (this->_internal_has_optimization()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.optimization_);
  }

  // .inference.ModelOperations model_operations = 18;
  if (this->_internal_has_model_operations()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.model_operations_);
  }

  // .inference.ModelTransactionPolicy model_transaction_policy = 19;
  if (this->_internal_has_model_transaction_policy()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.model_transaction_policy_);
  }

  // .inference.ModelRepositoryAgents model_repository_agents = 23;
  if (this->_internal_has_model_repository_agents()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.model_repository_agents_);
  }

  // .inference.ModelResponseCache response_cache = 24;
  if (this->_internal_has_response_cache()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_cache_);
  }

  // int32 max_batch_size = 4;
  if (this->_internal_max_batch_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_batch_size());
  }

  switch (scheduling_choice_case()) {
    // .inference.ModelDynamicBatching dynamic_batching = 11;
    case kDynamicBatching: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scheduling_choice_.dynamic_batching_);
      break;
    }
    // .inference.ModelSequenceBatching sequence_batching = 13;
    case kSequenceBatching: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scheduling_choice_.sequence_batching_);
      break;
    }
    // .inference.ModelEnsembling ensemble_scheduling = 15;
    case kEnsembleScheduling: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scheduling_choice_.ensemble_scheduling_);
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelConfig::GetClassData() const { return &_class_data_; }


void ModelConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelConfig*>(&to_msg);
  auto& from = static_cast<const ModelConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  _this->_impl_.output_.MergeFrom(from._impl_.output_);
  _this->_impl_.instance_group_.MergeFrom(from._impl_.instance_group_);
  _this->_impl_.cc_model_filenames_.MergeFrom(from._impl_.cc_model_filenames_);
  _this->_impl_.metric_tags_.MergeFrom(from._impl_.metric_tags_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _this->_impl_.model_warmup_.MergeFrom(from._impl_.model_warmup_);
  _this->_impl_.batch_input_.MergeFrom(from._impl_.batch_input_);
  _this->_impl_.batch_output_.MergeFrom(from._impl_.batch_output_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_platform().empty()) {
    _this->_internal_set_platform(from._internal_platform());
  }
  if (!from._internal_default_model_filename().empty()) {
    _this->_internal_set_default_model_filename(from._internal_default_model_filename());
  }
  if (!from._internal_backend().empty()) {
    _this->_internal_set_backend(from._internal_backend());
  }
  if (!from._internal_runtime().empty()) {
    _this->_internal_set_runtime(from._internal_runtime());
  }
  if (from._internal_has_version_policy()) {
    _this->_internal_mutable_version_policy()->::inference::ModelVersionPolicy::MergeFrom(
        from._internal_version_policy());
  }
  if (from._internal_has_optimization()) {
    _this->_internal_mutable_optimization()->::inference::ModelOptimizationPolicy::MergeFrom(
        from._internal_optimization());
  }
  if (from._internal_has_model_operations()) {
    _this->_internal_mutable_model_operations()->::inference::ModelOperations::MergeFrom(
        from._internal_model_operations());
  }
  if (from._internal_has_model_transaction_policy()) {
    _this->_internal_mutable_model_transaction_policy()->::inference::ModelTransactionPolicy::MergeFrom(
        from._internal_model_transaction_policy());
  }
  if (from._internal_has_model_repository_agents()) {
    _this->_internal_mutable_model_repository_agents()->::inference::ModelRepositoryAgents::MergeFrom(
        from._internal_model_repository_agents());
  }
  if (from._internal_has_response_cache()) {
    _this->_internal_mutable_response_cache()->::inference::ModelResponseCache::MergeFrom(
        from._internal_response_cache());
  }
  if (from._internal_max_batch_size() != 0) {
    _this->_internal_set_max_batch_size(from._internal_max_batch_size());
  }
  switch (from.scheduling_choice_case()) {
    case kDynamicBatching: {
      _this->_internal_mutable_dynamic_batching()->::inference::ModelDynamicBatching::MergeFrom(
          from._internal_dynamic_batching());
      break;
    }
    case kSequenceBatching: {
      _this->_internal_mutable_sequence_batching()->::inference::ModelSequenceBatching::MergeFrom(
          from._internal_sequence_batching());
      break;
    }
    case kEnsembleScheduling: {
      _this->_internal_mutable_ensemble_scheduling()->::inference::ModelEnsembling::MergeFrom(
          from._internal_ensemble_scheduling());
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelConfig::CopyFrom(const ModelConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelConfig::IsInitialized() const {
  return true;
}

void ModelConfig::InternalSwap(ModelConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_.InternalSwap(&other->_impl_.input_);
  _impl_.output_.InternalSwap(&other->_impl_.output_);
  _impl_.instance_group_.InternalSwap(&other->_impl_.instance_group_);
  _impl_.cc_model_filenames_.InternalSwap(&other->_impl_.cc_model_filenames_);
  _impl_.metric_tags_.InternalSwap(&other->_impl_.metric_tags_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  _impl_.model_warmup_.InternalSwap(&other->_impl_.model_warmup_);
  _impl_.batch_input_.InternalSwap(&other->_impl_.batch_input_);
  _impl_.batch_output_.InternalSwap(&other->_impl_.batch_output_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.platform_, lhs_arena,
      &other->_impl_.platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.default_model_filename_, lhs_arena,
      &other->_impl_.default_model_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.backend_, lhs_arena,
      &other->_impl_.backend_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.runtime_, lhs_arena,
      &other->_impl_.runtime_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelConfig, _impl_.max_batch_size_)
      + sizeof(ModelConfig::_impl_.max_batch_size_)
      - PROTOBUF_FIELD_OFFSET(ModelConfig, _impl_.version_policy_)>(
          reinterpret_cast<char*>(&_impl_.version_policy_),
          reinterpret_cast<char*>(&other->_impl_.version_policy_));
  swap(_impl_.scheduling_choice_, other->_impl_.scheduling_choice_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[52]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace inference
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::inference::ModelRateLimiter_Resource*
Arena::CreateMaybeMessage< ::inference::ModelRateLimiter_Resource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRateLimiter_Resource >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRateLimiter*
Arena::CreateMaybeMessage< ::inference::ModelRateLimiter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRateLimiter >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelInstanceGroup_SecondaryDevice*
Arena::CreateMaybeMessage< ::inference::ModelInstanceGroup_SecondaryDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelInstanceGroup_SecondaryDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelInstanceGroup*
Arena::CreateMaybeMessage< ::inference::ModelInstanceGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelInstanceGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelTensorReshape*
Arena::CreateMaybeMessage< ::inference::ModelTensorReshape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelTensorReshape >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelInput*
Arena::CreateMaybeMessage< ::inference::ModelInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelInput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOutput*
Arena::CreateMaybeMessage< ::inference::ModelOutput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOutput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::BatchInput*
Arena::CreateMaybeMessage< ::inference::BatchInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::BatchInput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::BatchOutput*
Arena::CreateMaybeMessage< ::inference::BatchOutput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::BatchOutput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy_Latest*
Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy_Latest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy_Latest >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy_All*
Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy_All >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy_All >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy_Specific*
Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy_Specific >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy_Specific >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy*
Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Graph*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Graph >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Graph >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_ExecutionAccelerators*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_ExecutionAccelerators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_ExecutionAccelerators >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy*
Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelQueuePolicy*
Arena::CreateMaybeMessage< ::inference::ModelQueuePolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelQueuePolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelDynamicBatching*
Arena::CreateMaybeMessage< ::inference::ModelDynamicBatching >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelDynamicBatching >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_Control*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_Control >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_Control >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_ControlInput*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_ControlInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_ControlInput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_InitialState*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_InitialState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_InitialState >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_State*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_State >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_StrategyDirect*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyDirect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_StrategyDirect >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_StrategyOldest*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyOldest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_StrategyOldest >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching*
Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling_Step*
Arena::CreateMaybeMessage< ::inference::ModelEnsembling_Step >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling_Step >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling*
Arena::CreateMaybeMessage< ::inference::ModelEnsembling >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelParameter*
Arena::CreateMaybeMessage< ::inference::ModelParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelWarmup_Input*
Arena::CreateMaybeMessage< ::inference::ModelWarmup_Input >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelWarmup_Input >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelWarmup_InputsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelWarmup_InputsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelWarmup_InputsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelWarmup*
Arena::CreateMaybeMessage< ::inference::ModelWarmup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelWarmup >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOperations*
Arena::CreateMaybeMessage< ::inference::ModelOperations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOperations >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelTransactionPolicy*
Arena::CreateMaybeMessage< ::inference::ModelTransactionPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelTransactionPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRepositoryAgents_Agent*
Arena::CreateMaybeMessage< ::inference::ModelRepositoryAgents_Agent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRepositoryAgents_Agent >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRepositoryAgents*
Arena::CreateMaybeMessage< ::inference::ModelRepositoryAgents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRepositoryAgents >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelResponseCache*
Arena::CreateMaybeMessage< ::inference::ModelResponseCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelResponseCache >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig_MetricTagsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelConfig_MetricTagsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig_MetricTagsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig_ParametersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::inference::ModelConfig_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig*
Arena::CreateMaybeMessage< ::inference::ModelConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
