// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_model_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_model_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_model_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_model_5fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_model_5fconfig_2eproto;
namespace inference {
class BatchInput;
struct BatchInputDefaultTypeInternal;
extern BatchInputDefaultTypeInternal _BatchInput_default_instance_;
class BatchOutput;
struct BatchOutputDefaultTypeInternal;
extern BatchOutputDefaultTypeInternal _BatchOutput_default_instance_;
class ModelConfig;
struct ModelConfigDefaultTypeInternal;
extern ModelConfigDefaultTypeInternal _ModelConfig_default_instance_;
class ModelConfig_CcModelFilenamesEntry_DoNotUse;
struct ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal _ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_;
class ModelConfig_MetricTagsEntry_DoNotUse;
struct ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal _ModelConfig_MetricTagsEntry_DoNotUse_default_instance_;
class ModelConfig_ParametersEntry_DoNotUse;
struct ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal _ModelConfig_ParametersEntry_DoNotUse_default_instance_;
class ModelDynamicBatching;
struct ModelDynamicBatchingDefaultTypeInternal;
extern ModelDynamicBatchingDefaultTypeInternal _ModelDynamicBatching_default_instance_;
class ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse;
struct ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal;
extern ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal _ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_;
class ModelEnsembling;
struct ModelEnsemblingDefaultTypeInternal;
extern ModelEnsemblingDefaultTypeInternal _ModelEnsembling_default_instance_;
class ModelEnsembling_Step;
struct ModelEnsembling_StepDefaultTypeInternal;
extern ModelEnsembling_StepDefaultTypeInternal _ModelEnsembling_Step_default_instance_;
class ModelEnsembling_Step_InputMapEntry_DoNotUse;
struct ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal;
extern ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_;
class ModelEnsembling_Step_OutputMapEntry_DoNotUse;
struct ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal;
extern ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_;
class ModelInput;
struct ModelInputDefaultTypeInternal;
extern ModelInputDefaultTypeInternal _ModelInput_default_instance_;
class ModelInstanceGroup;
struct ModelInstanceGroupDefaultTypeInternal;
extern ModelInstanceGroupDefaultTypeInternal _ModelInstanceGroup_default_instance_;
class ModelInstanceGroup_SecondaryDevice;
struct ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal;
extern ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal _ModelInstanceGroup_SecondaryDevice_default_instance_;
class ModelOperations;
struct ModelOperationsDefaultTypeInternal;
extern ModelOperationsDefaultTypeInternal _ModelOperations_default_instance_;
class ModelOptimizationPolicy;
struct ModelOptimizationPolicyDefaultTypeInternal;
extern ModelOptimizationPolicyDefaultTypeInternal _ModelOptimizationPolicy_default_instance_;
class ModelOptimizationPolicy_Cuda;
struct ModelOptimizationPolicy_CudaDefaultTypeInternal;
extern ModelOptimizationPolicy_CudaDefaultTypeInternal _ModelOptimizationPolicy_Cuda_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec;
struct ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse;
struct ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound;
struct ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse;
struct ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_Shape;
struct ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_;
class ModelOptimizationPolicy_ExecutionAccelerators;
struct ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal;
extern ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_default_instance_;
class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator;
struct ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal;
extern ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_;
class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse;
struct ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_;
class ModelOptimizationPolicy_Graph;
struct ModelOptimizationPolicy_GraphDefaultTypeInternal;
extern ModelOptimizationPolicy_GraphDefaultTypeInternal _ModelOptimizationPolicy_Graph_default_instance_;
class ModelOptimizationPolicy_PinnedMemoryBuffer;
struct ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal;
extern ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal _ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_;
class ModelOutput;
struct ModelOutputDefaultTypeInternal;
extern ModelOutputDefaultTypeInternal _ModelOutput_default_instance_;
class ModelParameter;
struct ModelParameterDefaultTypeInternal;
extern ModelParameterDefaultTypeInternal _ModelParameter_default_instance_;
class ModelQueuePolicy;
struct ModelQueuePolicyDefaultTypeInternal;
extern ModelQueuePolicyDefaultTypeInternal _ModelQueuePolicy_default_instance_;
class ModelRateLimiter;
struct ModelRateLimiterDefaultTypeInternal;
extern ModelRateLimiterDefaultTypeInternal _ModelRateLimiter_default_instance_;
class ModelRateLimiter_Resource;
struct ModelRateLimiter_ResourceDefaultTypeInternal;
extern ModelRateLimiter_ResourceDefaultTypeInternal _ModelRateLimiter_Resource_default_instance_;
class ModelRepositoryAgents;
struct ModelRepositoryAgentsDefaultTypeInternal;
extern ModelRepositoryAgentsDefaultTypeInternal _ModelRepositoryAgents_default_instance_;
class ModelRepositoryAgents_Agent;
struct ModelRepositoryAgents_AgentDefaultTypeInternal;
extern ModelRepositoryAgents_AgentDefaultTypeInternal _ModelRepositoryAgents_Agent_default_instance_;
class ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse;
struct ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal _ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse_default_instance_;
class ModelResponseCache;
struct ModelResponseCacheDefaultTypeInternal;
extern ModelResponseCacheDefaultTypeInternal _ModelResponseCache_default_instance_;
class ModelSequenceBatching;
struct ModelSequenceBatchingDefaultTypeInternal;
extern ModelSequenceBatchingDefaultTypeInternal _ModelSequenceBatching_default_instance_;
class ModelSequenceBatching_Control;
struct ModelSequenceBatching_ControlDefaultTypeInternal;
extern ModelSequenceBatching_ControlDefaultTypeInternal _ModelSequenceBatching_Control_default_instance_;
class ModelSequenceBatching_ControlInput;
struct ModelSequenceBatching_ControlInputDefaultTypeInternal;
extern ModelSequenceBatching_ControlInputDefaultTypeInternal _ModelSequenceBatching_ControlInput_default_instance_;
class ModelSequenceBatching_InitialState;
struct ModelSequenceBatching_InitialStateDefaultTypeInternal;
extern ModelSequenceBatching_InitialStateDefaultTypeInternal _ModelSequenceBatching_InitialState_default_instance_;
class ModelSequenceBatching_State;
struct ModelSequenceBatching_StateDefaultTypeInternal;
extern ModelSequenceBatching_StateDefaultTypeInternal _ModelSequenceBatching_State_default_instance_;
class ModelSequenceBatching_StrategyDirect;
struct ModelSequenceBatching_StrategyDirectDefaultTypeInternal;
extern ModelSequenceBatching_StrategyDirectDefaultTypeInternal _ModelSequenceBatching_StrategyDirect_default_instance_;
class ModelSequenceBatching_StrategyOldest;
struct ModelSequenceBatching_StrategyOldestDefaultTypeInternal;
extern ModelSequenceBatching_StrategyOldestDefaultTypeInternal _ModelSequenceBatching_StrategyOldest_default_instance_;
class ModelTensorReshape;
struct ModelTensorReshapeDefaultTypeInternal;
extern ModelTensorReshapeDefaultTypeInternal _ModelTensorReshape_default_instance_;
class ModelTransactionPolicy;
struct ModelTransactionPolicyDefaultTypeInternal;
extern ModelTransactionPolicyDefaultTypeInternal _ModelTransactionPolicy_default_instance_;
class ModelVersionPolicy;
struct ModelVersionPolicyDefaultTypeInternal;
extern ModelVersionPolicyDefaultTypeInternal _ModelVersionPolicy_default_instance_;
class ModelVersionPolicy_All;
struct ModelVersionPolicy_AllDefaultTypeInternal;
extern ModelVersionPolicy_AllDefaultTypeInternal _ModelVersionPolicy_All_default_instance_;
class ModelVersionPolicy_Latest;
struct ModelVersionPolicy_LatestDefaultTypeInternal;
extern ModelVersionPolicy_LatestDefaultTypeInternal _ModelVersionPolicy_Latest_default_instance_;
class ModelVersionPolicy_Specific;
struct ModelVersionPolicy_SpecificDefaultTypeInternal;
extern ModelVersionPolicy_SpecificDefaultTypeInternal _ModelVersionPolicy_Specific_default_instance_;
class ModelWarmup;
struct ModelWarmupDefaultTypeInternal;
extern ModelWarmupDefaultTypeInternal _ModelWarmup_default_instance_;
class ModelWarmup_Input;
struct ModelWarmup_InputDefaultTypeInternal;
extern ModelWarmup_InputDefaultTypeInternal _ModelWarmup_Input_default_instance_;
class ModelWarmup_InputsEntry_DoNotUse;
struct ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal;
extern ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal _ModelWarmup_InputsEntry_DoNotUse_default_instance_;
}  // namespace inference
PROTOBUF_NAMESPACE_OPEN
template<> ::inference::BatchInput* Arena::CreateMaybeMessage<::inference::BatchInput>(Arena*);
template<> ::inference::BatchOutput* Arena::CreateMaybeMessage<::inference::BatchOutput>(Arena*);
template<> ::inference::ModelConfig* Arena::CreateMaybeMessage<::inference::ModelConfig>(Arena*);
template<> ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse>(Arena*);
template<> ::inference::ModelConfig_MetricTagsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelConfig_MetricTagsEntry_DoNotUse>(Arena*);
template<> ::inference::ModelConfig_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelConfig_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelDynamicBatching* Arena::CreateMaybeMessage<::inference::ModelDynamicBatching>(Arena*);
template<> ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse>(Arena*);
template<> ::inference::ModelEnsembling* Arena::CreateMaybeMessage<::inference::ModelEnsembling>(Arena*);
template<> ::inference::ModelEnsembling_Step* Arena::CreateMaybeMessage<::inference::ModelEnsembling_Step>(Arena*);
template<> ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse>(Arena*);
template<> ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInput* Arena::CreateMaybeMessage<::inference::ModelInput>(Arena*);
template<> ::inference::ModelInstanceGroup* Arena::CreateMaybeMessage<::inference::ModelInstanceGroup>(Arena*);
template<> ::inference::ModelInstanceGroup_SecondaryDevice* Arena::CreateMaybeMessage<::inference::ModelInstanceGroup_SecondaryDevice>(Arena*);
template<> ::inference::ModelOperations* Arena::CreateMaybeMessage<::inference::ModelOperations>(Arena*);
template<> ::inference::ModelOptimizationPolicy* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape>(Arena*);
template<> ::inference::ModelOptimizationPolicy_ExecutionAccelerators* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators>(Arena*);
template<> ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator>(Arena*);
template<> ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Graph* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Graph>(Arena*);
template<> ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_PinnedMemoryBuffer>(Arena*);
template<> ::inference::ModelOutput* Arena::CreateMaybeMessage<::inference::ModelOutput>(Arena*);
template<> ::inference::ModelParameter* Arena::CreateMaybeMessage<::inference::ModelParameter>(Arena*);
template<> ::inference::ModelQueuePolicy* Arena::CreateMaybeMessage<::inference::ModelQueuePolicy>(Arena*);
template<> ::inference::ModelRateLimiter* Arena::CreateMaybeMessage<::inference::ModelRateLimiter>(Arena*);
template<> ::inference::ModelRateLimiter_Resource* Arena::CreateMaybeMessage<::inference::ModelRateLimiter_Resource>(Arena*);
template<> ::inference::ModelRepositoryAgents* Arena::CreateMaybeMessage<::inference::ModelRepositoryAgents>(Arena*);
template<> ::inference::ModelRepositoryAgents_Agent* Arena::CreateMaybeMessage<::inference::ModelRepositoryAgents_Agent>(Arena*);
template<> ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelResponseCache* Arena::CreateMaybeMessage<::inference::ModelResponseCache>(Arena*);
template<> ::inference::ModelSequenceBatching* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching>(Arena*);
template<> ::inference::ModelSequenceBatching_Control* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_Control>(Arena*);
template<> ::inference::ModelSequenceBatching_ControlInput* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_ControlInput>(Arena*);
template<> ::inference::ModelSequenceBatching_InitialState* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_InitialState>(Arena*);
template<> ::inference::ModelSequenceBatching_State* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_State>(Arena*);
template<> ::inference::ModelSequenceBatching_StrategyDirect* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_StrategyDirect>(Arena*);
template<> ::inference::ModelSequenceBatching_StrategyOldest* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_StrategyOldest>(Arena*);
template<> ::inference::ModelTensorReshape* Arena::CreateMaybeMessage<::inference::ModelTensorReshape>(Arena*);
template<> ::inference::ModelTransactionPolicy* Arena::CreateMaybeMessage<::inference::ModelTransactionPolicy>(Arena*);
template<> ::inference::ModelVersionPolicy* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy>(Arena*);
template<> ::inference::ModelVersionPolicy_All* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy_All>(Arena*);
template<> ::inference::ModelVersionPolicy_Latest* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy_Latest>(Arena*);
template<> ::inference::ModelVersionPolicy_Specific* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy_Specific>(Arena*);
template<> ::inference::ModelWarmup* Arena::CreateMaybeMessage<::inference::ModelWarmup>(Arena*);
template<> ::inference::ModelWarmup_Input* Arena::CreateMaybeMessage<::inference::ModelWarmup_Input>(Arena*);
template<> ::inference::ModelWarmup_InputsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelWarmup_InputsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace inference {

enum ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind : int {
  ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_KIND_NVDLA = 0,
  ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_IsValid(int value);
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_MIN = ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_KIND_NVDLA;
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_MAX = ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_KIND_NVDLA;
constexpr int ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_ARRAYSIZE = ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor();
template<typename T>
inline const std::string& ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor(), enum_t_value);
}
inline bool ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind>(
    ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor(), name, value);
}
enum ModelInstanceGroup_Kind : int {
  ModelInstanceGroup_Kind_KIND_AUTO = 0,
  ModelInstanceGroup_Kind_KIND_GPU = 1,
  ModelInstanceGroup_Kind_KIND_CPU = 2,
  ModelInstanceGroup_Kind_KIND_MODEL = 3,
  ModelInstanceGroup_Kind_ModelInstanceGroup_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelInstanceGroup_Kind_ModelInstanceGroup_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelInstanceGroup_Kind_IsValid(int value);
constexpr ModelInstanceGroup_Kind ModelInstanceGroup_Kind_Kind_MIN = ModelInstanceGroup_Kind_KIND_AUTO;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup_Kind_Kind_MAX = ModelInstanceGroup_Kind_KIND_MODEL;
constexpr int ModelInstanceGroup_Kind_Kind_ARRAYSIZE = ModelInstanceGroup_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_Kind_descriptor();
template<typename T>
inline const std::string& ModelInstanceGroup_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInstanceGroup_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInstanceGroup_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInstanceGroup_Kind_descriptor(), enum_t_value);
}
inline bool ModelInstanceGroup_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelInstanceGroup_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInstanceGroup_Kind>(
    ModelInstanceGroup_Kind_descriptor(), name, value);
}
enum ModelInput_Format : int {
  ModelInput_Format_FORMAT_NONE = 0,
  ModelInput_Format_FORMAT_NHWC = 1,
  ModelInput_Format_FORMAT_NCHW = 2,
  ModelInput_Format_ModelInput_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelInput_Format_ModelInput_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelInput_Format_IsValid(int value);
constexpr ModelInput_Format ModelInput_Format_Format_MIN = ModelInput_Format_FORMAT_NONE;
constexpr ModelInput_Format ModelInput_Format_Format_MAX = ModelInput_Format_FORMAT_NCHW;
constexpr int ModelInput_Format_Format_ARRAYSIZE = ModelInput_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInput_Format_descriptor();
template<typename T>
inline const std::string& ModelInput_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInput_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInput_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInput_Format_descriptor(), enum_t_value);
}
inline bool ModelInput_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelInput_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInput_Format>(
    ModelInput_Format_descriptor(), name, value);
}
enum BatchInput_Kind : int {
  BatchInput_Kind_BATCH_ELEMENT_COUNT = 0,
  BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT = 1,
  BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO = 2,
  BatchInput_Kind_BATCH_MAX_ELEMENT_COUNT_AS_SHAPE = 3,
  BatchInput_Kind_BATCH_ITEM_SHAPE = 4,
  BatchInput_Kind_BATCH_ITEM_SHAPE_FLATTEN = 5,
  BatchInput_Kind_BatchInput_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BatchInput_Kind_BatchInput_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BatchInput_Kind_IsValid(int value);
constexpr BatchInput_Kind BatchInput_Kind_Kind_MIN = BatchInput_Kind_BATCH_ELEMENT_COUNT;
constexpr BatchInput_Kind BatchInput_Kind_Kind_MAX = BatchInput_Kind_BATCH_ITEM_SHAPE_FLATTEN;
constexpr int BatchInput_Kind_Kind_ARRAYSIZE = BatchInput_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchInput_Kind_descriptor();
template<typename T>
inline const std::string& BatchInput_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatchInput_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatchInput_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatchInput_Kind_descriptor(), enum_t_value);
}
inline bool BatchInput_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatchInput_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatchInput_Kind>(
    BatchInput_Kind_descriptor(), name, value);
}
enum BatchOutput_Kind : int {
  BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE = 0,
  BatchOutput_Kind_BatchOutput_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BatchOutput_Kind_BatchOutput_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BatchOutput_Kind_IsValid(int value);
constexpr BatchOutput_Kind BatchOutput_Kind_Kind_MIN = BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE;
constexpr BatchOutput_Kind BatchOutput_Kind_Kind_MAX = BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE;
constexpr int BatchOutput_Kind_Kind_ARRAYSIZE = BatchOutput_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchOutput_Kind_descriptor();
template<typename T>
inline const std::string& BatchOutput_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatchOutput_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatchOutput_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatchOutput_Kind_descriptor(), enum_t_value);
}
inline bool BatchOutput_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatchOutput_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatchOutput_Kind>(
    BatchOutput_Kind_descriptor(), name, value);
}
enum ModelOptimizationPolicy_ModelPriority : int {
  ModelOptimizationPolicy_ModelPriority_PRIORITY_DEFAULT = 0,
  ModelOptimizationPolicy_ModelPriority_PRIORITY_MAX = 1,
  ModelOptimizationPolicy_ModelPriority_PRIORITY_MIN = 2,
  ModelOptimizationPolicy_ModelPriority_ModelOptimizationPolicy_ModelPriority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelOptimizationPolicy_ModelPriority_ModelOptimizationPolicy_ModelPriority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelOptimizationPolicy_ModelPriority_IsValid(int value);
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy_ModelPriority_ModelPriority_MIN = ModelOptimizationPolicy_ModelPriority_PRIORITY_DEFAULT;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy_ModelPriority_ModelPriority_MAX = ModelOptimizationPolicy_ModelPriority_PRIORITY_MIN;
constexpr int ModelOptimizationPolicy_ModelPriority_ModelPriority_ARRAYSIZE = ModelOptimizationPolicy_ModelPriority_ModelPriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelOptimizationPolicy_ModelPriority_descriptor();
template<typename T>
inline const std::string& ModelOptimizationPolicy_ModelPriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelOptimizationPolicy_ModelPriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelOptimizationPolicy_ModelPriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelOptimizationPolicy_ModelPriority_descriptor(), enum_t_value);
}
inline bool ModelOptimizationPolicy_ModelPriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelOptimizationPolicy_ModelPriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelOptimizationPolicy_ModelPriority>(
    ModelOptimizationPolicy_ModelPriority_descriptor(), name, value);
}
enum ModelQueuePolicy_TimeoutAction : int {
  ModelQueuePolicy_TimeoutAction_REJECT = 0,
  ModelQueuePolicy_TimeoutAction_DELAY = 1,
  ModelQueuePolicy_TimeoutAction_ModelQueuePolicy_TimeoutAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelQueuePolicy_TimeoutAction_ModelQueuePolicy_TimeoutAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelQueuePolicy_TimeoutAction_IsValid(int value);
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy_TimeoutAction_TimeoutAction_MIN = ModelQueuePolicy_TimeoutAction_REJECT;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy_TimeoutAction_TimeoutAction_MAX = ModelQueuePolicy_TimeoutAction_DELAY;
constexpr int ModelQueuePolicy_TimeoutAction_TimeoutAction_ARRAYSIZE = ModelQueuePolicy_TimeoutAction_TimeoutAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelQueuePolicy_TimeoutAction_descriptor();
template<typename T>
inline const std::string& ModelQueuePolicy_TimeoutAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelQueuePolicy_TimeoutAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelQueuePolicy_TimeoutAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelQueuePolicy_TimeoutAction_descriptor(), enum_t_value);
}
inline bool ModelQueuePolicy_TimeoutAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelQueuePolicy_TimeoutAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelQueuePolicy_TimeoutAction>(
    ModelQueuePolicy_TimeoutAction_descriptor(), name, value);
}
enum ModelSequenceBatching_Control_Kind : int {
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_START = 0,
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_READY = 1,
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_END = 2,
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_CORRID = 3,
  ModelSequenceBatching_Control_Kind_ModelSequenceBatching_Control_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelSequenceBatching_Control_Kind_ModelSequenceBatching_Control_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelSequenceBatching_Control_Kind_IsValid(int value);
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control_Kind_Kind_MIN = ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_START;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control_Kind_Kind_MAX = ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_CORRID;
constexpr int ModelSequenceBatching_Control_Kind_Kind_ARRAYSIZE = ModelSequenceBatching_Control_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelSequenceBatching_Control_Kind_descriptor();
template<typename T>
inline const std::string& ModelSequenceBatching_Control_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelSequenceBatching_Control_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelSequenceBatching_Control_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelSequenceBatching_Control_Kind_descriptor(), enum_t_value);
}
inline bool ModelSequenceBatching_Control_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelSequenceBatching_Control_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelSequenceBatching_Control_Kind>(
    ModelSequenceBatching_Control_Kind_descriptor(), name, value);
}
enum DataType : int {
  TYPE_INVALID = 0,
  TYPE_BOOL = 1,
  TYPE_UINT8 = 2,
  TYPE_UINT16 = 3,
  TYPE_UINT32 = 4,
  TYPE_UINT64 = 5,
  TYPE_INT8 = 6,
  TYPE_INT16 = 7,
  TYPE_INT32 = 8,
  TYPE_INT64 = 9,
  TYPE_FP16 = 10,
  TYPE_FP32 = 11,
  TYPE_FP64 = 12,
  TYPE_STRING = 13,
  TYPE_BF16 = 14,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = TYPE_INVALID;
constexpr DataType DataType_MAX = TYPE_BF16;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class ModelRateLimiter_Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRateLimiter.Resource) */ {
 public:
  inline ModelRateLimiter_Resource() : ModelRateLimiter_Resource(nullptr) {}
  ~ModelRateLimiter_Resource() override;
  explicit PROTOBUF_CONSTEXPR ModelRateLimiter_Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRateLimiter_Resource(const ModelRateLimiter_Resource& from);
  ModelRateLimiter_Resource(ModelRateLimiter_Resource&& from) noexcept
    : ModelRateLimiter_Resource() {
    *this = ::std::move(from);
  }

  inline ModelRateLimiter_Resource& operator=(const ModelRateLimiter_Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRateLimiter_Resource& operator=(ModelRateLimiter_Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRateLimiter_Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelRateLimiter_Resource* internal_default_instance() {
    return reinterpret_cast<const ModelRateLimiter_Resource*>(
               &_ModelRateLimiter_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModelRateLimiter_Resource& a, ModelRateLimiter_Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRateLimiter_Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRateLimiter_Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelRateLimiter_Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelRateLimiter_Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelRateLimiter_Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelRateLimiter_Resource& from) {
    ModelRateLimiter_Resource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRateLimiter_Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRateLimiter.Resource";
  }
  protected:
  explicit ModelRateLimiter_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGlobalFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool global = 2;
  void clear_global();
  bool global() const;
  void set_global(bool value);
  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelRateLimiter.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool global_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelRateLimiter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRateLimiter) */ {
 public:
  inline ModelRateLimiter() : ModelRateLimiter(nullptr) {}
  ~ModelRateLimiter() override;
  explicit PROTOBUF_CONSTEXPR ModelRateLimiter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRateLimiter(const ModelRateLimiter& from);
  ModelRateLimiter(ModelRateLimiter&& from) noexcept
    : ModelRateLimiter() {
    *this = ::std::move(from);
  }

  inline ModelRateLimiter& operator=(const ModelRateLimiter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRateLimiter& operator=(ModelRateLimiter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRateLimiter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelRateLimiter* internal_default_instance() {
    return reinterpret_cast<const ModelRateLimiter*>(
               &_ModelRateLimiter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModelRateLimiter& a, ModelRateLimiter& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRateLimiter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRateLimiter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelRateLimiter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelRateLimiter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelRateLimiter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelRateLimiter& from) {
    ModelRateLimiter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRateLimiter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRateLimiter";
  }
  protected:
  explicit ModelRateLimiter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelRateLimiter_Resource Resource;

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 1,
    kPriorityFieldNumber = 2,
  };
  // repeated .inference.ModelRateLimiter.Resource resources = 1;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::inference::ModelRateLimiter_Resource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >*
      mutable_resources();
  private:
  const ::inference::ModelRateLimiter_Resource& _internal_resources(int index) const;
  ::inference::ModelRateLimiter_Resource* _internal_add_resources();
  public:
  const ::inference::ModelRateLimiter_Resource& resources(int index) const;
  ::inference::ModelRateLimiter_Resource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >&
      resources() const;

  // uint32 priority = 2;
  void clear_priority();
  uint32_t priority() const;
  void set_priority(uint32_t value);
  private:
  uint32_t _internal_priority() const;
  void _internal_set_priority(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelRateLimiter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource > resources_;
    uint32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelInstanceGroup_SecondaryDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInstanceGroup.SecondaryDevice) */ {
 public:
  inline ModelInstanceGroup_SecondaryDevice() : ModelInstanceGroup_SecondaryDevice(nullptr) {}
  ~ModelInstanceGroup_SecondaryDevice() override;
  explicit PROTOBUF_CONSTEXPR ModelInstanceGroup_SecondaryDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInstanceGroup_SecondaryDevice(const ModelInstanceGroup_SecondaryDevice& from);
  ModelInstanceGroup_SecondaryDevice(ModelInstanceGroup_SecondaryDevice&& from) noexcept
    : ModelInstanceGroup_SecondaryDevice() {
    *this = ::std::move(from);
  }

  inline ModelInstanceGroup_SecondaryDevice& operator=(const ModelInstanceGroup_SecondaryDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInstanceGroup_SecondaryDevice& operator=(ModelInstanceGroup_SecondaryDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInstanceGroup_SecondaryDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInstanceGroup_SecondaryDevice* internal_default_instance() {
    return reinterpret_cast<const ModelInstanceGroup_SecondaryDevice*>(
               &_ModelInstanceGroup_SecondaryDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModelInstanceGroup_SecondaryDevice& a, ModelInstanceGroup_SecondaryDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInstanceGroup_SecondaryDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInstanceGroup_SecondaryDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInstanceGroup_SecondaryDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInstanceGroup_SecondaryDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInstanceGroup_SecondaryDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInstanceGroup_SecondaryDevice& from) {
    ModelInstanceGroup_SecondaryDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInstanceGroup_SecondaryDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInstanceGroup.SecondaryDevice";
  }
  protected:
  explicit ModelInstanceGroup_SecondaryDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind SecondaryDeviceKind;
  static constexpr SecondaryDeviceKind KIND_NVDLA =
    ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_KIND_NVDLA;
  static inline bool SecondaryDeviceKind_IsValid(int value) {
    return ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_IsValid(value);
  }
  static constexpr SecondaryDeviceKind SecondaryDeviceKind_MIN =
    ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_MIN;
  static constexpr SecondaryDeviceKind SecondaryDeviceKind_MAX =
    ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_MAX;
  static constexpr int SecondaryDeviceKind_ARRAYSIZE =
    ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_SecondaryDeviceKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SecondaryDeviceKind_descriptor() {
    return ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor();
  }
  template<typename T>
  static inline const std::string& SecondaryDeviceKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SecondaryDeviceKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SecondaryDeviceKind_Name.");
    return ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_Name(enum_t_value);
  }
  static inline bool SecondaryDeviceKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SecondaryDeviceKind* value) {
    return ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 2,
    kKindFieldNumber = 1,
  };
  // int64 device_id = 2;
  void clear_device_id();
  int64_t device_id() const;
  void set_device_id(int64_t value);
  private:
  int64_t _internal_device_id() const;
  void _internal_set_device_id(int64_t value);
  public:

  // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
  void clear_kind();
  ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind kind() const;
  void set_kind(::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind value);
  private:
  ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind _internal_kind() const;
  void _internal_set_kind(::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInstanceGroup.SecondaryDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t device_id_;
    int kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelInstanceGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInstanceGroup) */ {
 public:
  inline ModelInstanceGroup() : ModelInstanceGroup(nullptr) {}
  ~ModelInstanceGroup() override;
  explicit PROTOBUF_CONSTEXPR ModelInstanceGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInstanceGroup(const ModelInstanceGroup& from);
  ModelInstanceGroup(ModelInstanceGroup&& from) noexcept
    : ModelInstanceGroup() {
    *this = ::std::move(from);
  }

  inline ModelInstanceGroup& operator=(const ModelInstanceGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInstanceGroup& operator=(ModelInstanceGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInstanceGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInstanceGroup* internal_default_instance() {
    return reinterpret_cast<const ModelInstanceGroup*>(
               &_ModelInstanceGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModelInstanceGroup& a, ModelInstanceGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInstanceGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInstanceGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInstanceGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInstanceGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInstanceGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInstanceGroup& from) {
    ModelInstanceGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInstanceGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInstanceGroup";
  }
  protected:
  explicit ModelInstanceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelInstanceGroup_SecondaryDevice SecondaryDevice;

  typedef ModelInstanceGroup_Kind Kind;
  static constexpr Kind KIND_AUTO =
    ModelInstanceGroup_Kind_KIND_AUTO;
  static constexpr Kind KIND_GPU =
    ModelInstanceGroup_Kind_KIND_GPU;
  static constexpr Kind KIND_CPU =
    ModelInstanceGroup_Kind_KIND_CPU;
  static constexpr Kind KIND_MODEL =
    ModelInstanceGroup_Kind_KIND_MODEL;
  static inline bool Kind_IsValid(int value) {
    return ModelInstanceGroup_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ModelInstanceGroup_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ModelInstanceGroup_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ModelInstanceGroup_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ModelInstanceGroup_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ModelInstanceGroup_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return ModelInstanceGroup_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGpusFieldNumber = 3,
    kProfileFieldNumber = 5,
    kSecondaryDevicesFieldNumber = 8,
    kNameFieldNumber = 1,
    kHostPolicyFieldNumber = 9,
    kRateLimiterFieldNumber = 6,
    kCountFieldNumber = 2,
    kKindFieldNumber = 4,
    kPassiveFieldNumber = 7,
  };
  // repeated int32 gpus = 3;
  int gpus_size() const;
  private:
  int _internal_gpus_size() const;
  public:
  void clear_gpus();
  private:
  int32_t _internal_gpus(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_gpus() const;
  void _internal_add_gpus(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_gpus();
  public:
  int32_t gpus(int index) const;
  void set_gpus(int index, int32_t value);
  void add_gpus(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      gpus() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_gpus();

  // repeated string profile = 5;
  int profile_size() const;
  private:
  int _internal_profile_size() const;
  public:
  void clear_profile();
  const std::string& profile(int index) const;
  std::string* mutable_profile(int index);
  void set_profile(int index, const std::string& value);
  void set_profile(int index, std::string&& value);
  void set_profile(int index, const char* value);
  void set_profile(int index, const char* value, size_t size);
  std::string* add_profile();
  void add_profile(const std::string& value);
  void add_profile(std::string&& value);
  void add_profile(const char* value);
  void add_profile(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& profile() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_profile();
  private:
  const std::string& _internal_profile(int index) const;
  std::string* _internal_add_profile();
  public:

  // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
  int secondary_devices_size() const;
  private:
  int _internal_secondary_devices_size() const;
  public:
  void clear_secondary_devices();
  ::inference::ModelInstanceGroup_SecondaryDevice* mutable_secondary_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup_SecondaryDevice >*
      mutable_secondary_devices();
  private:
  const ::inference::ModelInstanceGroup_SecondaryDevice& _internal_secondary_devices(int index) const;
  ::inference::ModelInstanceGroup_SecondaryDevice* _internal_add_secondary_devices();
  public:
  const ::inference::ModelInstanceGroup_SecondaryDevice& secondary_devices(int index) const;
  ::inference::ModelInstanceGroup_SecondaryDevice* add_secondary_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup_SecondaryDevice >&
      secondary_devices() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string host_policy = 9;
  void clear_host_policy();
  const std::string& host_policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_policy();
  PROTOBUF_NODISCARD std::string* release_host_policy();
  void set_allocated_host_policy(std::string* host_policy);
  private:
  const std::string& _internal_host_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_policy(const std::string& value);
  std::string* _internal_mutable_host_policy();
  public:

  // .inference.ModelRateLimiter rate_limiter = 6;
  bool has_rate_limiter() const;
  private:
  bool _internal_has_rate_limiter() const;
  public:
  void clear_rate_limiter();
  const ::inference::ModelRateLimiter& rate_limiter() const;
  PROTOBUF_NODISCARD ::inference::ModelRateLimiter* release_rate_limiter();
  ::inference::ModelRateLimiter* mutable_rate_limiter();
  void set_allocated_rate_limiter(::inference::ModelRateLimiter* rate_limiter);
  private:
  const ::inference::ModelRateLimiter& _internal_rate_limiter() const;
  ::inference::ModelRateLimiter* _internal_mutable_rate_limiter();
  public:
  void unsafe_arena_set_allocated_rate_limiter(
      ::inference::ModelRateLimiter* rate_limiter);
  ::inference::ModelRateLimiter* unsafe_arena_release_rate_limiter();

  // int32 count = 2;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // .inference.ModelInstanceGroup.Kind kind = 4;
  void clear_kind();
  ::inference::ModelInstanceGroup_Kind kind() const;
  void set_kind(::inference::ModelInstanceGroup_Kind value);
  private:
  ::inference::ModelInstanceGroup_Kind _internal_kind() const;
  void _internal_set_kind(::inference::ModelInstanceGroup_Kind value);
  public:

  // bool passive = 7;
  void clear_passive();
  bool passive() const;
  void set_passive(bool value);
  private:
  bool _internal_passive() const;
  void _internal_set_passive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInstanceGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > gpus_;
    mutable std::atomic<int> _gpus_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> profile_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup_SecondaryDevice > secondary_devices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_policy_;
    ::inference::ModelRateLimiter* rate_limiter_;
    int32_t count_;
    int kind_;
    bool passive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelTensorReshape final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelTensorReshape) */ {
 public:
  inline ModelTensorReshape() : ModelTensorReshape(nullptr) {}
  ~ModelTensorReshape() override;
  explicit PROTOBUF_CONSTEXPR ModelTensorReshape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelTensorReshape(const ModelTensorReshape& from);
  ModelTensorReshape(ModelTensorReshape&& from) noexcept
    : ModelTensorReshape() {
    *this = ::std::move(from);
  }

  inline ModelTensorReshape& operator=(const ModelTensorReshape& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTensorReshape& operator=(ModelTensorReshape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelTensorReshape& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelTensorReshape* internal_default_instance() {
    return reinterpret_cast<const ModelTensorReshape*>(
               &_ModelTensorReshape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelTensorReshape& a, ModelTensorReshape& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTensorReshape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTensorReshape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelTensorReshape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelTensorReshape>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelTensorReshape& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelTensorReshape& from) {
    ModelTensorReshape::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTensorReshape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelTensorReshape";
  }
  protected:
  explicit ModelTensorReshape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
  };
  // repeated int64 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:inference.ModelTensorReshape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInput) */ {
 public:
  inline ModelInput() : ModelInput(nullptr) {}
  ~ModelInput() override;
  explicit PROTOBUF_CONSTEXPR ModelInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInput(const ModelInput& from);
  ModelInput(ModelInput&& from) noexcept
    : ModelInput() {
    *this = ::std::move(from);
  }

  inline ModelInput& operator=(const ModelInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInput& operator=(ModelInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInput* internal_default_instance() {
    return reinterpret_cast<const ModelInput*>(
               &_ModelInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModelInput& a, ModelInput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInput& from) {
    ModelInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInput";
  }
  protected:
  explicit ModelInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelInput_Format Format;
  static constexpr Format FORMAT_NONE =
    ModelInput_Format_FORMAT_NONE;
  static constexpr Format FORMAT_NHWC =
    ModelInput_Format_FORMAT_NHWC;
  static constexpr Format FORMAT_NCHW =
    ModelInput_Format_FORMAT_NCHW;
  static inline bool Format_IsValid(int value) {
    return ModelInput_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    ModelInput_Format_Format_MIN;
  static constexpr Format Format_MAX =
    ModelInput_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    ModelInput_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return ModelInput_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return ModelInput_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return ModelInput_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 4,
    kNameFieldNumber = 1,
    kReshapeFieldNumber = 5,
    kDataTypeFieldNumber = 2,
    kFormatFieldNumber = 3,
    kIsShapeTensorFieldNumber = 6,
    kAllowRaggedBatchFieldNumber = 7,
    kOptionalFieldNumber = 8,
  };
  // repeated int64 dims = 4;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int64_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dims() const;
  void _internal_add_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dims();
  public:
  int64_t dims(int index) const;
  void set_dims(int index, int64_t value);
  void add_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dims();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .inference.ModelTensorReshape reshape = 5;
  bool has_reshape() const;
  private:
  bool _internal_has_reshape() const;
  public:
  void clear_reshape();
  const ::inference::ModelTensorReshape& reshape() const;
  PROTOBUF_NODISCARD ::inference::ModelTensorReshape* release_reshape();
  ::inference::ModelTensorReshape* mutable_reshape();
  void set_allocated_reshape(::inference::ModelTensorReshape* reshape);
  private:
  const ::inference::ModelTensorReshape& _internal_reshape() const;
  ::inference::ModelTensorReshape* _internal_mutable_reshape();
  public:
  void unsafe_arena_set_allocated_reshape(
      ::inference::ModelTensorReshape* reshape);
  ::inference::ModelTensorReshape* unsafe_arena_release_reshape();

  // .inference.DataType data_type = 2;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // .inference.ModelInput.Format format = 3;
  void clear_format();
  ::inference::ModelInput_Format format() const;
  void set_format(::inference::ModelInput_Format value);
  private:
  ::inference::ModelInput_Format _internal_format() const;
  void _internal_set_format(::inference::ModelInput_Format value);
  public:

  // bool is_shape_tensor = 6;
  void clear_is_shape_tensor();
  bool is_shape_tensor() const;
  void set_is_shape_tensor(bool value);
  private:
  bool _internal_is_shape_tensor() const;
  void _internal_set_is_shape_tensor(bool value);
  public:

  // bool allow_ragged_batch = 7;
  void clear_allow_ragged_batch();
  bool allow_ragged_batch() const;
  void set_allow_ragged_batch(bool value);
  private:
  bool _internal_allow_ragged_batch() const;
  void _internal_set_allow_ragged_batch(bool value);
  public:

  // bool optional = 8;
  void clear_optional();
  bool optional() const;
  void set_optional(bool value);
  private:
  bool _internal_optional() const;
  void _internal_set_optional(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dims_;
    mutable std::atomic<int> _dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::inference::ModelTensorReshape* reshape_;
    int data_type_;
    int format_;
    bool is_shape_tensor_;
    bool allow_ragged_batch_;
    bool optional_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOutput) */ {
 public:
  inline ModelOutput() : ModelOutput(nullptr) {}
  ~ModelOutput() override;
  explicit PROTOBUF_CONSTEXPR ModelOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOutput(const ModelOutput& from);
  ModelOutput(ModelOutput&& from) noexcept
    : ModelOutput() {
    *this = ::std::move(from);
  }

  inline ModelOutput& operator=(const ModelOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOutput& operator=(ModelOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOutput* internal_default_instance() {
    return reinterpret_cast<const ModelOutput*>(
               &_ModelOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ModelOutput& a, ModelOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOutput& from) {
    ModelOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOutput";
  }
  protected:
  explicit ModelOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 3,
    kNameFieldNumber = 1,
    kLabelFilenameFieldNumber = 4,
    kReshapeFieldNumber = 5,
    kDataTypeFieldNumber = 2,
    kIsShapeTensorFieldNumber = 6,
  };
  // repeated int64 dims = 3;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int64_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dims() const;
  void _internal_add_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dims();
  public:
  int64_t dims(int index) const;
  void set_dims(int index, int64_t value);
  void add_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dims();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string label_filename = 4;
  void clear_label_filename();
  const std::string& label_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label_filename();
  PROTOBUF_NODISCARD std::string* release_label_filename();
  void set_allocated_label_filename(std::string* label_filename);
  private:
  const std::string& _internal_label_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label_filename(const std::string& value);
  std::string* _internal_mutable_label_filename();
  public:

  // .inference.ModelTensorReshape reshape = 5;
  bool has_reshape() const;
  private:
  bool _internal_has_reshape() const;
  public:
  void clear_reshape();
  const ::inference::ModelTensorReshape& reshape() const;
  PROTOBUF_NODISCARD ::inference::ModelTensorReshape* release_reshape();
  ::inference::ModelTensorReshape* mutable_reshape();
  void set_allocated_reshape(::inference::ModelTensorReshape* reshape);
  private:
  const ::inference::ModelTensorReshape& _internal_reshape() const;
  ::inference::ModelTensorReshape* _internal_mutable_reshape();
  public:
  void unsafe_arena_set_allocated_reshape(
      ::inference::ModelTensorReshape* reshape);
  ::inference::ModelTensorReshape* unsafe_arena_release_reshape();

  // .inference.DataType data_type = 2;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // bool is_shape_tensor = 6;
  void clear_is_shape_tensor();
  bool is_shape_tensor() const;
  void set_is_shape_tensor(bool value);
  private:
  bool _internal_is_shape_tensor() const;
  void _internal_set_is_shape_tensor(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dims_;
    mutable std::atomic<int> _dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_filename_;
    ::inference::ModelTensorReshape* reshape_;
    int data_type_;
    bool is_shape_tensor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BatchInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.BatchInput) */ {
 public:
  inline BatchInput() : BatchInput(nullptr) {}
  ~BatchInput() override;
  explicit PROTOBUF_CONSTEXPR BatchInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchInput(const BatchInput& from);
  BatchInput(BatchInput&& from) noexcept
    : BatchInput() {
    *this = ::std::move(from);
  }

  inline BatchInput& operator=(const BatchInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchInput& operator=(BatchInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchInput* internal_default_instance() {
    return reinterpret_cast<const BatchInput*>(
               &_BatchInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchInput& a, BatchInput& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchInput& from) {
    BatchInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.BatchInput";
  }
  protected:
  explicit BatchInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchInput_Kind Kind;
  static constexpr Kind BATCH_ELEMENT_COUNT =
    BatchInput_Kind_BATCH_ELEMENT_COUNT;
  static constexpr Kind BATCH_ACCUMULATED_ELEMENT_COUNT =
    BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT;
  static constexpr Kind BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO =
    BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO;
  static constexpr Kind BATCH_MAX_ELEMENT_COUNT_AS_SHAPE =
    BatchInput_Kind_BATCH_MAX_ELEMENT_COUNT_AS_SHAPE;
  static constexpr Kind BATCH_ITEM_SHAPE =
    BatchInput_Kind_BATCH_ITEM_SHAPE;
  static constexpr Kind BATCH_ITEM_SHAPE_FLATTEN =
    BatchInput_Kind_BATCH_ITEM_SHAPE_FLATTEN;
  static inline bool Kind_IsValid(int value) {
    return BatchInput_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    BatchInput_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    BatchInput_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    BatchInput_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return BatchInput_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return BatchInput_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return BatchInput_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetNameFieldNumber = 2,
    kSourceInputFieldNumber = 4,
    kKindFieldNumber = 1,
    kDataTypeFieldNumber = 3,
  };
  // repeated string target_name = 2;
  int target_name_size() const;
  private:
  int _internal_target_name_size() const;
  public:
  void clear_target_name();
  const std::string& target_name(int index) const;
  std::string* mutable_target_name(int index);
  void set_target_name(int index, const std::string& value);
  void set_target_name(int index, std::string&& value);
  void set_target_name(int index, const char* value);
  void set_target_name(int index, const char* value, size_t size);
  std::string* add_target_name();
  void add_target_name(const std::string& value);
  void add_target_name(std::string&& value);
  void add_target_name(const char* value);
  void add_target_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& target_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_target_name();
  private:
  const std::string& _internal_target_name(int index) const;
  std::string* _internal_add_target_name();
  public:

  // repeated string source_input = 4;
  int source_input_size() const;
  private:
  int _internal_source_input_size() const;
  public:
  void clear_source_input();
  const std::string& source_input(int index) const;
  std::string* mutable_source_input(int index);
  void set_source_input(int index, const std::string& value);
  void set_source_input(int index, std::string&& value);
  void set_source_input(int index, const char* value);
  void set_source_input(int index, const char* value, size_t size);
  std::string* add_source_input();
  void add_source_input(const std::string& value);
  void add_source_input(std::string&& value);
  void add_source_input(const char* value);
  void add_source_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& source_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_source_input();
  private:
  const std::string& _internal_source_input(int index) const;
  std::string* _internal_add_source_input();
  public:

  // .inference.BatchInput.Kind kind = 1;
  void clear_kind();
  ::inference::BatchInput_Kind kind() const;
  void set_kind(::inference::BatchInput_Kind value);
  private:
  ::inference::BatchInput_Kind _internal_kind() const;
  void _internal_set_kind(::inference::BatchInput_Kind value);
  public:

  // .inference.DataType data_type = 3;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:inference.BatchInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> target_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> source_input_;
    int kind_;
    int data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BatchOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.BatchOutput) */ {
 public:
  inline BatchOutput() : BatchOutput(nullptr) {}
  ~BatchOutput() override;
  explicit PROTOBUF_CONSTEXPR BatchOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchOutput(const BatchOutput& from);
  BatchOutput(BatchOutput&& from) noexcept
    : BatchOutput() {
    *this = ::std::move(from);
  }

  inline BatchOutput& operator=(const BatchOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchOutput& operator=(BatchOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchOutput* internal_default_instance() {
    return reinterpret_cast<const BatchOutput*>(
               &_BatchOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BatchOutput& a, BatchOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchOutput& from) {
    BatchOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.BatchOutput";
  }
  protected:
  explicit BatchOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchOutput_Kind Kind;
  static constexpr Kind BATCH_SCATTER_WITH_INPUT_SHAPE =
    BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE;
  static inline bool Kind_IsValid(int value) {
    return BatchOutput_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    BatchOutput_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    BatchOutput_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    BatchOutput_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return BatchOutput_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return BatchOutput_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return BatchOutput_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetNameFieldNumber = 1,
    kSourceInputFieldNumber = 3,
    kKindFieldNumber = 2,
  };
  // repeated string target_name = 1;
  int target_name_size() const;
  private:
  int _internal_target_name_size() const;
  public:
  void clear_target_name();
  const std::string& target_name(int index) const;
  std::string* mutable_target_name(int index);
  void set_target_name(int index, const std::string& value);
  void set_target_name(int index, std::string&& value);
  void set_target_name(int index, const char* value);
  void set_target_name(int index, const char* value, size_t size);
  std::string* add_target_name();
  void add_target_name(const std::string& value);
  void add_target_name(std::string&& value);
  void add_target_name(const char* value);
  void add_target_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& target_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_target_name();
  private:
  const std::string& _internal_target_name(int index) const;
  std::string* _internal_add_target_name();
  public:

  // repeated string source_input = 3;
  int source_input_size() const;
  private:
  int _internal_source_input_size() const;
  public:
  void clear_source_input();
  const std::string& source_input(int index) const;
  std::string* mutable_source_input(int index);
  void set_source_input(int index, const std::string& value);
  void set_source_input(int index, std::string&& value);
  void set_source_input(int index, const char* value);
  void set_source_input(int index, const char* value, size_t size);
  std::string* add_source_input();
  void add_source_input(const std::string& value);
  void add_source_input(std::string&& value);
  void add_source_input(const char* value);
  void add_source_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& source_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_source_input();
  private:
  const std::string& _internal_source_input(int index) const;
  std::string* _internal_add_source_input();
  public:

  // .inference.BatchOutput.Kind kind = 2;
  void clear_kind();
  ::inference::BatchOutput_Kind kind() const;
  void set_kind(::inference::BatchOutput_Kind value);
  private:
  ::inference::BatchOutput_Kind _internal_kind() const;
  void _internal_set_kind(::inference::BatchOutput_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:inference.BatchOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> target_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> source_input_;
    int kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy_Latest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy.Latest) */ {
 public:
  inline ModelVersionPolicy_Latest() : ModelVersionPolicy_Latest(nullptr) {}
  ~ModelVersionPolicy_Latest() override;
  explicit PROTOBUF_CONSTEXPR ModelVersionPolicy_Latest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelVersionPolicy_Latest(const ModelVersionPolicy_Latest& from);
  ModelVersionPolicy_Latest(ModelVersionPolicy_Latest&& from) noexcept
    : ModelVersionPolicy_Latest() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy_Latest& operator=(const ModelVersionPolicy_Latest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy_Latest& operator=(ModelVersionPolicy_Latest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelVersionPolicy_Latest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelVersionPolicy_Latest* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy_Latest*>(
               &_ModelVersionPolicy_Latest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelVersionPolicy_Latest& a, ModelVersionPolicy_Latest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy_Latest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy_Latest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelVersionPolicy_Latest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelVersionPolicy_Latest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelVersionPolicy_Latest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelVersionPolicy_Latest& from) {
    ModelVersionPolicy_Latest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy_Latest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy.Latest";
  }
  protected:
  explicit ModelVersionPolicy_Latest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumVersionsFieldNumber = 1,
  };
  // uint32 num_versions = 1;
  void clear_num_versions();
  uint32_t num_versions() const;
  void set_num_versions(uint32_t value);
  private:
  uint32_t _internal_num_versions() const;
  void _internal_set_num_versions(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy.Latest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t num_versions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy_All final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy.All) */ {
 public:
  inline ModelVersionPolicy_All() : ModelVersionPolicy_All(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ModelVersionPolicy_All(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelVersionPolicy_All(const ModelVersionPolicy_All& from);
  ModelVersionPolicy_All(ModelVersionPolicy_All&& from) noexcept
    : ModelVersionPolicy_All() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy_All& operator=(const ModelVersionPolicy_All& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy_All& operator=(ModelVersionPolicy_All&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelVersionPolicy_All& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelVersionPolicy_All* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy_All*>(
               &_ModelVersionPolicy_All_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModelVersionPolicy_All& a, ModelVersionPolicy_All& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy_All* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy_All* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelVersionPolicy_All* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelVersionPolicy_All>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ModelVersionPolicy_All& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ModelVersionPolicy_All& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy.All";
  }
  protected:
  explicit ModelVersionPolicy_All(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy.All)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy_Specific final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy.Specific) */ {
 public:
  inline ModelVersionPolicy_Specific() : ModelVersionPolicy_Specific(nullptr) {}
  ~ModelVersionPolicy_Specific() override;
  explicit PROTOBUF_CONSTEXPR ModelVersionPolicy_Specific(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelVersionPolicy_Specific(const ModelVersionPolicy_Specific& from);
  ModelVersionPolicy_Specific(ModelVersionPolicy_Specific&& from) noexcept
    : ModelVersionPolicy_Specific() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy_Specific& operator=(const ModelVersionPolicy_Specific& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy_Specific& operator=(ModelVersionPolicy_Specific&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelVersionPolicy_Specific& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelVersionPolicy_Specific* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy_Specific*>(
               &_ModelVersionPolicy_Specific_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ModelVersionPolicy_Specific& a, ModelVersionPolicy_Specific& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy_Specific* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy_Specific* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelVersionPolicy_Specific* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelVersionPolicy_Specific>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelVersionPolicy_Specific& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelVersionPolicy_Specific& from) {
    ModelVersionPolicy_Specific::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy_Specific* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy.Specific";
  }
  protected:
  explicit ModelVersionPolicy_Specific(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
  };
  // repeated int64 versions = 1;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  private:
  int64_t _internal_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_versions() const;
  void _internal_add_versions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_versions();
  public:
  int64_t versions(int index) const;
  void set_versions(int index, int64_t value);
  void add_versions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy.Specific)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > versions_;
    mutable std::atomic<int> _versions_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy) */ {
 public:
  inline ModelVersionPolicy() : ModelVersionPolicy(nullptr) {}
  ~ModelVersionPolicy() override;
  explicit PROTOBUF_CONSTEXPR ModelVersionPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelVersionPolicy(const ModelVersionPolicy& from);
  ModelVersionPolicy(ModelVersionPolicy&& from) noexcept
    : ModelVersionPolicy() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy& operator=(const ModelVersionPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy& operator=(ModelVersionPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelVersionPolicy& default_instance() {
    return *internal_default_instance();
  }
  enum PolicyChoiceCase {
    kLatest = 1,
    kAll = 2,
    kSpecific = 3,
    POLICY_CHOICE_NOT_SET = 0,
  };

  static inline const ModelVersionPolicy* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy*>(
               &_ModelVersionPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ModelVersionPolicy& a, ModelVersionPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelVersionPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelVersionPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelVersionPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelVersionPolicy& from) {
    ModelVersionPolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy";
  }
  protected:
  explicit ModelVersionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelVersionPolicy_Latest Latest;
  typedef ModelVersionPolicy_All All;
  typedef ModelVersionPolicy_Specific Specific;

  // accessors -------------------------------------------------------

  enum : int {
    kLatestFieldNumber = 1,
    kAllFieldNumber = 2,
    kSpecificFieldNumber = 3,
  };
  // .inference.ModelVersionPolicy.Latest latest = 1;
  bool has_latest() const;
  private:
  bool _internal_has_latest() const;
  public:
  void clear_latest();
  const ::inference::ModelVersionPolicy_Latest& latest() const;
  PROTOBUF_NODISCARD ::inference::ModelVersionPolicy_Latest* release_latest();
  ::inference::ModelVersionPolicy_Latest* mutable_latest();
  void set_allocated_latest(::inference::ModelVersionPolicy_Latest* latest);
  private:
  const ::inference::ModelVersionPolicy_Latest& _internal_latest() const;
  ::inference::ModelVersionPolicy_Latest* _internal_mutable_latest();
  public:
  void unsafe_arena_set_allocated_latest(
      ::inference::ModelVersionPolicy_Latest* latest);
  ::inference::ModelVersionPolicy_Latest* unsafe_arena_release_latest();

  // .inference.ModelVersionPolicy.All all = 2;
  bool has_all() const;
  private:
  bool _internal_has_all() const;
  public:
  void clear_all();
  const ::inference::ModelVersionPolicy_All& all() const;
  PROTOBUF_NODISCARD ::inference::ModelVersionPolicy_All* release_all();
  ::inference::ModelVersionPolicy_All* mutable_all();
  void set_allocated_all(::inference::ModelVersionPolicy_All* all);
  private:
  const ::inference::ModelVersionPolicy_All& _internal_all() const;
  ::inference::ModelVersionPolicy_All* _internal_mutable_all();
  public:
  void unsafe_arena_set_allocated_all(
      ::inference::ModelVersionPolicy_All* all);
  ::inference::ModelVersionPolicy_All* unsafe_arena_release_all();

  // .inference.ModelVersionPolicy.Specific specific = 3;
  bool has_specific() const;
  private:
  bool _internal_has_specific() const;
  public:
  void clear_specific();
  const ::inference::ModelVersionPolicy_Specific& specific() const;
  PROTOBUF_NODISCARD ::inference::ModelVersionPolicy_Specific* release_specific();
  ::inference::ModelVersionPolicy_Specific* mutable_specific();
  void set_allocated_specific(::inference::ModelVersionPolicy_Specific* specific);
  private:
  const ::inference::ModelVersionPolicy_Specific& _internal_specific() const;
  ::inference::ModelVersionPolicy_Specific* _internal_mutable_specific();
  public:
  void unsafe_arena_set_allocated_specific(
      ::inference::ModelVersionPolicy_Specific* specific);
  ::inference::ModelVersionPolicy_Specific* unsafe_arena_release_specific();

  void clear_policy_choice();
  PolicyChoiceCase policy_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy)
 private:
  class _Internal;
  void set_has_latest();
  void set_has_all();
  void set_has_specific();

  inline bool has_policy_choice() const;
  inline void clear_has_policy_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PolicyChoiceUnion {
      constexpr PolicyChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::inference::ModelVersionPolicy_Latest* latest_;
      ::inference::ModelVersionPolicy_All* all_;
      ::inference::ModelVersionPolicy_Specific* specific_;
    } policy_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Graph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Graph) */ {
 public:
  inline ModelOptimizationPolicy_Graph() : ModelOptimizationPolicy_Graph(nullptr) {}
  ~ModelOptimizationPolicy_Graph() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Graph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_Graph(const ModelOptimizationPolicy_Graph& from);
  ModelOptimizationPolicy_Graph(ModelOptimizationPolicy_Graph&& from) noexcept
    : ModelOptimizationPolicy_Graph() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Graph& operator=(const ModelOptimizationPolicy_Graph& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Graph& operator=(ModelOptimizationPolicy_Graph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_Graph& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_Graph* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Graph*>(
               &_ModelOptimizationPolicy_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ModelOptimizationPolicy_Graph& a, ModelOptimizationPolicy_Graph& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Graph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Graph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_Graph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Graph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_Graph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_Graph& from) {
    ModelOptimizationPolicy_Graph::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Graph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Graph";
  }
  protected:
  explicit ModelOptimizationPolicy_Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Graph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_Shape final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape) */ {
 public:
  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape() : ModelOptimizationPolicy_Cuda_GraphSpec_Shape(nullptr) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_Shape() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_Shape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_Cuda_GraphSpec_Shape(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from);
  ModelOptimizationPolicy_Cuda_GraphSpec_Shape(ModelOptimizationPolicy_Cuda_GraphSpec_Shape&& from) noexcept
    : ModelOptimizationPolicy_Cuda_GraphSpec_Shape() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape& operator=(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape& operator=(ModelOptimizationPolicy_Cuda_GraphSpec_Shape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_Cuda_GraphSpec_Shape* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_Shape*>(
               &_ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape& a, ModelOptimizationPolicy_Cuda_GraphSpec_Shape& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_Cuda_GraphSpec_Shape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec_Shape>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from) {
    ModelOptimizationPolicy_Cuda_GraphSpec_Shape::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 1,
  };
  // repeated int64 dim = 1;
  int dim_size() const;
  private:
  int _internal_dim_size() const;
  public:
  void clear_dim();
  private:
  int64_t _internal_dim(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dim() const;
  void _internal_add_dim(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dim();
  public:
  int64_t dim(int index) const;
  void set_dim(int index, int64_t value);
  void add_dim(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dim() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dim();

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dim_;
    mutable std::atomic<int> _dim_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse& other);
  static const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse*>(&_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.InputEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound) */ {
 public:
  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() : ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(nullptr) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from);
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&& from) noexcept
    : ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& operator=(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& operator=(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound*>(
               &_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& a, ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from) {
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 2,
    kBatchSizeFieldNumber = 1,
  };
  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      _internal_input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      _internal_mutable_input();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      mutable_input();

  // int32 batch_size = 1;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse,
        std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> input_;
    int32_t batch_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse& other);
  static const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse*>(&_ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.Cuda.GraphSpec.InputEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda.GraphSpec) */ {
 public:
  inline ModelOptimizationPolicy_Cuda_GraphSpec() : ModelOptimizationPolicy_Cuda_GraphSpec(nullptr) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda_GraphSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_Cuda_GraphSpec(const ModelOptimizationPolicy_Cuda_GraphSpec& from);
  ModelOptimizationPolicy_Cuda_GraphSpec(ModelOptimizationPolicy_Cuda_GraphSpec&& from) noexcept
    : ModelOptimizationPolicy_Cuda_GraphSpec() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda_GraphSpec& operator=(const ModelOptimizationPolicy_Cuda_GraphSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda_GraphSpec& operator=(ModelOptimizationPolicy_Cuda_GraphSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_Cuda_GraphSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_Cuda_GraphSpec* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec*>(
               &_ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ModelOptimizationPolicy_Cuda_GraphSpec& a, ModelOptimizationPolicy_Cuda_GraphSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda_GraphSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda_GraphSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_Cuda_GraphSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_Cuda_GraphSpec& from) {
    ModelOptimizationPolicy_Cuda_GraphSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda.GraphSpec";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda_GraphSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_Cuda_GraphSpec_Shape Shape;
  typedef ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound LowerBound;

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 2,
    kGraphLowerBoundFieldNumber = 3,
    kBatchSizeFieldNumber = 1,
  };
  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      _internal_input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      _internal_mutable_input();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      mutable_input();

  // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
  bool has_graph_lower_bound() const;
  private:
  bool _internal_has_graph_lower_bound() const;
  public:
  void clear_graph_lower_bound();
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& graph_lower_bound() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* release_graph_lower_bound();
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* mutable_graph_lower_bound();
  void set_allocated_graph_lower_bound(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound);
  private:
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& _internal_graph_lower_bound() const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* _internal_mutable_graph_lower_bound();
  public:
  void unsafe_arena_set_allocated_graph_lower_bound(
      ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound);
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* unsafe_arena_release_graph_lower_bound();

  // int32 batch_size = 1;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse,
        std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> input_;
    ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound_;
    int32_t batch_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda) */ {
 public:
  inline ModelOptimizationPolicy_Cuda() : ModelOptimizationPolicy_Cuda(nullptr) {}
  ~ModelOptimizationPolicy_Cuda() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_Cuda(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_Cuda(const ModelOptimizationPolicy_Cuda& from);
  ModelOptimizationPolicy_Cuda(ModelOptimizationPolicy_Cuda&& from) noexcept
    : ModelOptimizationPolicy_Cuda() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda& operator=(const ModelOptimizationPolicy_Cuda& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda& operator=(ModelOptimizationPolicy_Cuda&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_Cuda& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_Cuda* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda*>(
               &_ModelOptimizationPolicy_Cuda_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ModelOptimizationPolicy_Cuda& a, ModelOptimizationPolicy_Cuda& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_Cuda* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_Cuda& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_Cuda& from) {
    ModelOptimizationPolicy_Cuda::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_Cuda_GraphSpec GraphSpec;

  // accessors -------------------------------------------------------

  enum : int {
    kGraphSpecFieldNumber = 3,
    kGraphsFieldNumber = 1,
    kBusyWaitEventsFieldNumber = 2,
    kOutputCopyStreamFieldNumber = 4,
  };
  // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
  int graph_spec_size() const;
  private:
  int _internal_graph_spec_size() const;
  public:
  void clear_graph_spec();
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* mutable_graph_spec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >*
      mutable_graph_spec();
  private:
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& _internal_graph_spec(int index) const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* _internal_add_graph_spec();
  public:
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& graph_spec(int index) const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* add_graph_spec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >&
      graph_spec() const;

  // bool graphs = 1;
  void clear_graphs();
  bool graphs() const;
  void set_graphs(bool value);
  private:
  bool _internal_graphs() const;
  void _internal_set_graphs(bool value);
  public:

  // bool busy_wait_events = 2;
  void clear_busy_wait_events();
  bool busy_wait_events() const;
  void set_busy_wait_events(bool value);
  private:
  bool _internal_busy_wait_events() const;
  void _internal_set_busy_wait_events(bool value);
  public:

  // bool output_copy_stream = 4;
  void clear_output_copy_stream();
  bool output_copy_stream() const;
  void set_output_copy_stream(bool value);
  private:
  bool _internal_output_copy_stream() const;
  void _internal_set_output_copy_stream(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec > graph_spec_;
    bool graphs_;
    bool busy_wait_events_;
    bool output_copy_stream_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse& other);
  static const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse*>(&_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator) */ {
 public:
  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() : ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(nullptr) {}
  ~ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from);
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator&& from) noexcept
    : ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& operator=(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& operator=(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator*>(
               &_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& a, ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from) {
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator";
  }
  protected:
  explicit ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_ExecutionAccelerators final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.ExecutionAccelerators) */ {
 public:
  inline ModelOptimizationPolicy_ExecutionAccelerators() : ModelOptimizationPolicy_ExecutionAccelerators(nullptr) {}
  ~ModelOptimizationPolicy_ExecutionAccelerators() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_ExecutionAccelerators(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_ExecutionAccelerators(const ModelOptimizationPolicy_ExecutionAccelerators& from);
  ModelOptimizationPolicy_ExecutionAccelerators(ModelOptimizationPolicy_ExecutionAccelerators&& from) noexcept
    : ModelOptimizationPolicy_ExecutionAccelerators() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_ExecutionAccelerators& operator=(const ModelOptimizationPolicy_ExecutionAccelerators& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_ExecutionAccelerators& operator=(ModelOptimizationPolicy_ExecutionAccelerators&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_ExecutionAccelerators& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_ExecutionAccelerators* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_ExecutionAccelerators*>(
               &_ModelOptimizationPolicy_ExecutionAccelerators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ModelOptimizationPolicy_ExecutionAccelerators& a, ModelOptimizationPolicy_ExecutionAccelerators& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_ExecutionAccelerators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_ExecutionAccelerators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_ExecutionAccelerators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_ExecutionAccelerators>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_ExecutionAccelerators& from) {
    ModelOptimizationPolicy_ExecutionAccelerators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.ExecutionAccelerators";
  }
  protected:
  explicit ModelOptimizationPolicy_ExecutionAccelerators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_ExecutionAccelerators_Accelerator Accelerator;

  // accessors -------------------------------------------------------

  enum : int {
    kGpuExecutionAcceleratorFieldNumber = 1,
    kCpuExecutionAcceleratorFieldNumber = 2,
  };
  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
  int gpu_execution_accelerator_size() const;
  private:
  int _internal_gpu_execution_accelerator_size() const;
  public:
  void clear_gpu_execution_accelerator();
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* mutable_gpu_execution_accelerator(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
      mutable_gpu_execution_accelerator();
  private:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& _internal_gpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _internal_add_gpu_execution_accelerator();
  public:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& gpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* add_gpu_execution_accelerator();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
      gpu_execution_accelerator() const;

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
  int cpu_execution_accelerator_size() const;
  private:
  int _internal_cpu_execution_accelerator_size() const;
  public:
  void clear_cpu_execution_accelerator();
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* mutable_cpu_execution_accelerator(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
      mutable_cpu_execution_accelerator();
  private:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& _internal_cpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _internal_add_cpu_execution_accelerator();
  public:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& cpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* add_cpu_execution_accelerator();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
      cpu_execution_accelerator() const;

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.ExecutionAccelerators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator > gpu_execution_accelerator_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator > cpu_execution_accelerator_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_PinnedMemoryBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.PinnedMemoryBuffer) */ {
 public:
  inline ModelOptimizationPolicy_PinnedMemoryBuffer() : ModelOptimizationPolicy_PinnedMemoryBuffer(nullptr) {}
  ~ModelOptimizationPolicy_PinnedMemoryBuffer() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy_PinnedMemoryBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy_PinnedMemoryBuffer(const ModelOptimizationPolicy_PinnedMemoryBuffer& from);
  ModelOptimizationPolicy_PinnedMemoryBuffer(ModelOptimizationPolicy_PinnedMemoryBuffer&& from) noexcept
    : ModelOptimizationPolicy_PinnedMemoryBuffer() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_PinnedMemoryBuffer& operator=(const ModelOptimizationPolicy_PinnedMemoryBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_PinnedMemoryBuffer& operator=(ModelOptimizationPolicy_PinnedMemoryBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy_PinnedMemoryBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy_PinnedMemoryBuffer* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_PinnedMemoryBuffer*>(
               &_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ModelOptimizationPolicy_PinnedMemoryBuffer& a, ModelOptimizationPolicy_PinnedMemoryBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_PinnedMemoryBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_PinnedMemoryBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy_PinnedMemoryBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_PinnedMemoryBuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy_PinnedMemoryBuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy_PinnedMemoryBuffer& from) {
    ModelOptimizationPolicy_PinnedMemoryBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_PinnedMemoryBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.PinnedMemoryBuffer";
  }
  protected:
  explicit ModelOptimizationPolicy_PinnedMemoryBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy) */ {
 public:
  inline ModelOptimizationPolicy() : ModelOptimizationPolicy(nullptr) {}
  ~ModelOptimizationPolicy() override;
  explicit PROTOBUF_CONSTEXPR ModelOptimizationPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOptimizationPolicy(const ModelOptimizationPolicy& from);
  ModelOptimizationPolicy(ModelOptimizationPolicy&& from) noexcept
    : ModelOptimizationPolicy() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy& operator=(const ModelOptimizationPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy& operator=(ModelOptimizationPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOptimizationPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOptimizationPolicy* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy*>(
               &_ModelOptimizationPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ModelOptimizationPolicy& a, ModelOptimizationPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOptimizationPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOptimizationPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOptimizationPolicy& from) {
    ModelOptimizationPolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy";
  }
  protected:
  explicit ModelOptimizationPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_Graph Graph;
  typedef ModelOptimizationPolicy_Cuda Cuda;
  typedef ModelOptimizationPolicy_ExecutionAccelerators ExecutionAccelerators;
  typedef ModelOptimizationPolicy_PinnedMemoryBuffer PinnedMemoryBuffer;

  typedef ModelOptimizationPolicy_ModelPriority ModelPriority;
  static constexpr ModelPriority PRIORITY_DEFAULT =
    ModelOptimizationPolicy_ModelPriority_PRIORITY_DEFAULT;
  static constexpr ModelPriority PRIORITY_MAX =
    ModelOptimizationPolicy_ModelPriority_PRIORITY_MAX;
  static constexpr ModelPriority PRIORITY_MIN =
    ModelOptimizationPolicy_ModelPriority_PRIORITY_MIN;
  static inline bool ModelPriority_IsValid(int value) {
    return ModelOptimizationPolicy_ModelPriority_IsValid(value);
  }
  static constexpr ModelPriority ModelPriority_MIN =
    ModelOptimizationPolicy_ModelPriority_ModelPriority_MIN;
  static constexpr ModelPriority ModelPriority_MAX =
    ModelOptimizationPolicy_ModelPriority_ModelPriority_MAX;
  static constexpr int ModelPriority_ARRAYSIZE =
    ModelOptimizationPolicy_ModelPriority_ModelPriority_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModelPriority_descriptor() {
    return ModelOptimizationPolicy_ModelPriority_descriptor();
  }
  template<typename T>
  static inline const std::string& ModelPriority_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModelPriority>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModelPriority_Name.");
    return ModelOptimizationPolicy_ModelPriority_Name(enum_t_value);
  }
  static inline bool ModelPriority_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModelPriority* value) {
    return ModelOptimizationPolicy_ModelPriority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGraphFieldNumber = 1,
    kCudaFieldNumber = 3,
    kExecutionAcceleratorsFieldNumber = 4,
    kInputPinnedMemoryFieldNumber = 5,
    kOutputPinnedMemoryFieldNumber = 6,
    kPriorityFieldNumber = 2,
    kGatherKernelBufferThresholdFieldNumber = 7,
    kEagerBatchingFieldNumber = 8,
  };
  // .inference.ModelOptimizationPolicy.Graph graph = 1;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::inference::ModelOptimizationPolicy_Graph& graph() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy_Graph* release_graph();
  ::inference::ModelOptimizationPolicy_Graph* mutable_graph();
  void set_allocated_graph(::inference::ModelOptimizationPolicy_Graph* graph);
  private:
  const ::inference::ModelOptimizationPolicy_Graph& _internal_graph() const;
  ::inference::ModelOptimizationPolicy_Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::inference::ModelOptimizationPolicy_Graph* graph);
  ::inference::ModelOptimizationPolicy_Graph* unsafe_arena_release_graph();

  // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
  bool has_cuda() const;
  private:
  bool _internal_has_cuda() const;
  public:
  void clear_cuda();
  const ::inference::ModelOptimizationPolicy_Cuda& cuda() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy_Cuda* release_cuda();
  ::inference::ModelOptimizationPolicy_Cuda* mutable_cuda();
  void set_allocated_cuda(::inference::ModelOptimizationPolicy_Cuda* cuda);
  private:
  const ::inference::ModelOptimizationPolicy_Cuda& _internal_cuda() const;
  ::inference::ModelOptimizationPolicy_Cuda* _internal_mutable_cuda();
  public:
  void unsafe_arena_set_allocated_cuda(
      ::inference::ModelOptimizationPolicy_Cuda* cuda);
  ::inference::ModelOptimizationPolicy_Cuda* unsafe_arena_release_cuda();

  // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
  bool has_execution_accelerators() const;
  private:
  bool _internal_has_execution_accelerators() const;
  public:
  void clear_execution_accelerators();
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& execution_accelerators() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy_ExecutionAccelerators* release_execution_accelerators();
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* mutable_execution_accelerators();
  void set_allocated_execution_accelerators(::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators);
  private:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& _internal_execution_accelerators() const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* _internal_mutable_execution_accelerators();
  public:
  void unsafe_arena_set_allocated_execution_accelerators(
      ::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators);
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* unsafe_arena_release_execution_accelerators();

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
  bool has_input_pinned_memory() const;
  private:
  bool _internal_has_input_pinned_memory() const;
  public:
  void clear_input_pinned_memory();
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& input_pinned_memory() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* release_input_pinned_memory();
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* mutable_input_pinned_memory();
  void set_allocated_input_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory);
  private:
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& _internal_input_pinned_memory() const;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* _internal_mutable_input_pinned_memory();
  public:
  void unsafe_arena_set_allocated_input_pinned_memory(
      ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory);
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* unsafe_arena_release_input_pinned_memory();

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
  bool has_output_pinned_memory() const;
  private:
  bool _internal_has_output_pinned_memory() const;
  public:
  void clear_output_pinned_memory();
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& output_pinned_memory() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* release_output_pinned_memory();
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* mutable_output_pinned_memory();
  void set_allocated_output_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory);
  private:
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& _internal_output_pinned_memory() const;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* _internal_mutable_output_pinned_memory();
  public:
  void unsafe_arena_set_allocated_output_pinned_memory(
      ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory);
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* unsafe_arena_release_output_pinned_memory();

  // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
  void clear_priority();
  ::inference::ModelOptimizationPolicy_ModelPriority priority() const;
  void set_priority(::inference::ModelOptimizationPolicy_ModelPriority value);
  private:
  ::inference::ModelOptimizationPolicy_ModelPriority _internal_priority() const;
  void _internal_set_priority(::inference::ModelOptimizationPolicy_ModelPriority value);
  public:

  // uint32 gather_kernel_buffer_threshold = 7;
  void clear_gather_kernel_buffer_threshold();
  uint32_t gather_kernel_buffer_threshold() const;
  void set_gather_kernel_buffer_threshold(uint32_t value);
  private:
  uint32_t _internal_gather_kernel_buffer_threshold() const;
  void _internal_set_gather_kernel_buffer_threshold(uint32_t value);
  public:

  // bool eager_batching = 8;
  void clear_eager_batching();
  bool eager_batching() const;
  void set_eager_batching(bool value);
  private:
  bool _internal_eager_batching() const;
  void _internal_set_eager_batching(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::inference::ModelOptimizationPolicy_Graph* graph_;
    ::inference::ModelOptimizationPolicy_Cuda* cuda_;
    ::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators_;
    ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory_;
    ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory_;
    int priority_;
    uint32_t gather_kernel_buffer_threshold_;
    bool eager_batching_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelQueuePolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelQueuePolicy) */ {
 public:
  inline ModelQueuePolicy() : ModelQueuePolicy(nullptr) {}
  ~ModelQueuePolicy() override;
  explicit PROTOBUF_CONSTEXPR ModelQueuePolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelQueuePolicy(const ModelQueuePolicy& from);
  ModelQueuePolicy(ModelQueuePolicy&& from) noexcept
    : ModelQueuePolicy() {
    *this = ::std::move(from);
  }

  inline ModelQueuePolicy& operator=(const ModelQueuePolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelQueuePolicy& operator=(ModelQueuePolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelQueuePolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelQueuePolicy* internal_default_instance() {
    return reinterpret_cast<const ModelQueuePolicy*>(
               &_ModelQueuePolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ModelQueuePolicy& a, ModelQueuePolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelQueuePolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelQueuePolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelQueuePolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelQueuePolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelQueuePolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelQueuePolicy& from) {
    ModelQueuePolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelQueuePolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelQueuePolicy";
  }
  protected:
  explicit ModelQueuePolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelQueuePolicy_TimeoutAction TimeoutAction;
  static constexpr TimeoutAction REJECT =
    ModelQueuePolicy_TimeoutAction_REJECT;
  static constexpr TimeoutAction DELAY =
    ModelQueuePolicy_TimeoutAction_DELAY;
  static inline bool TimeoutAction_IsValid(int value) {
    return ModelQueuePolicy_TimeoutAction_IsValid(value);
  }
  static constexpr TimeoutAction TimeoutAction_MIN =
    ModelQueuePolicy_TimeoutAction_TimeoutAction_MIN;
  static constexpr TimeoutAction TimeoutAction_MAX =
    ModelQueuePolicy_TimeoutAction_TimeoutAction_MAX;
  static constexpr int TimeoutAction_ARRAYSIZE =
    ModelQueuePolicy_TimeoutAction_TimeoutAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TimeoutAction_descriptor() {
    return ModelQueuePolicy_TimeoutAction_descriptor();
  }
  template<typename T>
  static inline const std::string& TimeoutAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TimeoutAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TimeoutAction_Name.");
    return ModelQueuePolicy_TimeoutAction_Name(enum_t_value);
  }
  static inline bool TimeoutAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TimeoutAction* value) {
    return ModelQueuePolicy_TimeoutAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultTimeoutMicrosecondsFieldNumber = 2,
    kTimeoutActionFieldNumber = 1,
    kAllowTimeoutOverrideFieldNumber = 3,
    kMaxQueueSizeFieldNumber = 4,
  };
  // uint64 default_timeout_microseconds = 2;
  void clear_default_timeout_microseconds();
  uint64_t default_timeout_microseconds() const;
  void set_default_timeout_microseconds(uint64_t value);
  private:
  uint64_t _internal_default_timeout_microseconds() const;
  void _internal_set_default_timeout_microseconds(uint64_t value);
  public:

  // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
  void clear_timeout_action();
  ::inference::ModelQueuePolicy_TimeoutAction timeout_action() const;
  void set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value);
  private:
  ::inference::ModelQueuePolicy_TimeoutAction _internal_timeout_action() const;
  void _internal_set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value);
  public:

  // bool allow_timeout_override = 3;
  void clear_allow_timeout_override();
  bool allow_timeout_override() const;
  void set_allow_timeout_override(bool value);
  private:
  bool _internal_allow_timeout_override() const;
  void _internal_set_allow_timeout_override(bool value);
  public:

  // uint32 max_queue_size = 4;
  void clear_max_queue_size();
  uint32_t max_queue_size() const;
  void set_max_queue_size(uint32_t value);
  private:
  uint32_t _internal_max_queue_size() const;
  void _internal_set_max_queue_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelQueuePolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t default_timeout_microseconds_;
    int timeout_action_;
    bool allow_timeout_override_;
    uint32_t max_queue_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, 
    uint64_t, ::inference::ModelQueuePolicy,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, 
    uint64_t, ::inference::ModelQueuePolicy,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse& other);
  static const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse*>(&_ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelDynamicBatching final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelDynamicBatching) */ {
 public:
  inline ModelDynamicBatching() : ModelDynamicBatching(nullptr) {}
  ~ModelDynamicBatching() override;
  explicit PROTOBUF_CONSTEXPR ModelDynamicBatching(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelDynamicBatching(const ModelDynamicBatching& from);
  ModelDynamicBatching(ModelDynamicBatching&& from) noexcept
    : ModelDynamicBatching() {
    *this = ::std::move(from);
  }

  inline ModelDynamicBatching& operator=(const ModelDynamicBatching& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelDynamicBatching& operator=(ModelDynamicBatching&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelDynamicBatching& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelDynamicBatching* internal_default_instance() {
    return reinterpret_cast<const ModelDynamicBatching*>(
               &_ModelDynamicBatching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ModelDynamicBatching& a, ModelDynamicBatching& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelDynamicBatching* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelDynamicBatching* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelDynamicBatching* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelDynamicBatching>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelDynamicBatching& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelDynamicBatching& from) {
    ModelDynamicBatching::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelDynamicBatching* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelDynamicBatching";
  }
  protected:
  explicit ModelDynamicBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPreferredBatchSizeFieldNumber = 1,
    kPriorityQueuePolicyFieldNumber = 7,
    kDefaultQueuePolicyFieldNumber = 6,
    kMaxQueueDelayMicrosecondsFieldNumber = 2,
    kPriorityLevelsFieldNumber = 4,
    kDefaultPriorityLevelFieldNumber = 5,
    kPreserveOrderingFieldNumber = 3,
  };
  // repeated int32 preferred_batch_size = 1;
  int preferred_batch_size_size() const;
  private:
  int _internal_preferred_batch_size_size() const;
  public:
  void clear_preferred_batch_size();
  private:
  int32_t _internal_preferred_batch_size(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_preferred_batch_size() const;
  void _internal_add_preferred_batch_size(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_preferred_batch_size();
  public:
  int32_t preferred_batch_size(int index) const;
  void set_preferred_batch_size(int index, int32_t value);
  void add_preferred_batch_size(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      preferred_batch_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_preferred_batch_size();

  // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
  int priority_queue_policy_size() const;
  private:
  int _internal_priority_queue_policy_size() const;
  public:
  void clear_priority_queue_policy();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >&
      _internal_priority_queue_policy() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >*
      _internal_mutable_priority_queue_policy();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >&
      priority_queue_policy() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >*
      mutable_priority_queue_policy();

  // .inference.ModelQueuePolicy default_queue_policy = 6;
  bool has_default_queue_policy() const;
  private:
  bool _internal_has_default_queue_policy() const;
  public:
  void clear_default_queue_policy();
  const ::inference::ModelQueuePolicy& default_queue_policy() const;
  PROTOBUF_NODISCARD ::inference::ModelQueuePolicy* release_default_queue_policy();
  ::inference::ModelQueuePolicy* mutable_default_queue_policy();
  void set_allocated_default_queue_policy(::inference::ModelQueuePolicy* default_queue_policy);
  private:
  const ::inference::ModelQueuePolicy& _internal_default_queue_policy() const;
  ::inference::ModelQueuePolicy* _internal_mutable_default_queue_policy();
  public:
  void unsafe_arena_set_allocated_default_queue_policy(
      ::inference::ModelQueuePolicy* default_queue_policy);
  ::inference::ModelQueuePolicy* unsafe_arena_release_default_queue_policy();

  // uint64 max_queue_delay_microseconds = 2;
  void clear_max_queue_delay_microseconds();
  uint64_t max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(uint64_t value);
  private:
  uint64_t _internal_max_queue_delay_microseconds() const;
  void _internal_set_max_queue_delay_microseconds(uint64_t value);
  public:

  // uint64 priority_levels = 4;
  void clear_priority_levels();
  uint64_t priority_levels() const;
  void set_priority_levels(uint64_t value);
  private:
  uint64_t _internal_priority_levels() const;
  void _internal_set_priority_levels(uint64_t value);
  public:

  // uint64 default_priority_level = 5;
  void clear_default_priority_level();
  uint64_t default_priority_level() const;
  void set_default_priority_level(uint64_t value);
  private:
  uint64_t _internal_default_priority_level() const;
  void _internal_set_default_priority_level(uint64_t value);
  public:

  // bool preserve_ordering = 3;
  void clear_preserve_ordering();
  bool preserve_ordering() const;
  void set_preserve_ordering(bool value);
  private:
  bool _internal_preserve_ordering() const;
  void _internal_set_preserve_ordering(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelDynamicBatching)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > preferred_batch_size_;
    mutable std::atomic<int> _preferred_batch_size_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse,
        uint64_t, ::inference::ModelQueuePolicy,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> priority_queue_policy_;
    ::inference::ModelQueuePolicy* default_queue_policy_;
    uint64_t max_queue_delay_microseconds_;
    uint64_t priority_levels_;
    uint64_t default_priority_level_;
    bool preserve_ordering_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_Control final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.Control) */ {
 public:
  inline ModelSequenceBatching_Control() : ModelSequenceBatching_Control(nullptr) {}
  ~ModelSequenceBatching_Control() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching_Control(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching_Control(const ModelSequenceBatching_Control& from);
  ModelSequenceBatching_Control(ModelSequenceBatching_Control&& from) noexcept
    : ModelSequenceBatching_Control() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_Control& operator=(const ModelSequenceBatching_Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_Control& operator=(ModelSequenceBatching_Control&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching_Control& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelSequenceBatching_Control* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_Control*>(
               &_ModelSequenceBatching_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ModelSequenceBatching_Control& a, ModelSequenceBatching_Control& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_Control* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching_Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching_Control>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching_Control& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching_Control& from) {
    ModelSequenceBatching_Control::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_Control* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.Control";
  }
  protected:
  explicit ModelSequenceBatching_Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelSequenceBatching_Control_Kind Kind;
  static constexpr Kind CONTROL_SEQUENCE_START =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_START;
  static constexpr Kind CONTROL_SEQUENCE_READY =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_READY;
  static constexpr Kind CONTROL_SEQUENCE_END =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_END;
  static constexpr Kind CONTROL_SEQUENCE_CORRID =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_CORRID;
  static inline bool Kind_IsValid(int value) {
    return ModelSequenceBatching_Control_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ModelSequenceBatching_Control_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ModelSequenceBatching_Control_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ModelSequenceBatching_Control_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ModelSequenceBatching_Control_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ModelSequenceBatching_Control_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return ModelSequenceBatching_Control_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInt32FalseTrueFieldNumber = 2,
    kFp32FalseTrueFieldNumber = 3,
    kBoolFalseTrueFieldNumber = 5,
    kKindFieldNumber = 1,
    kDataTypeFieldNumber = 4,
  };
  // repeated int32 int32_false_true = 2;
  int int32_false_true_size() const;
  private:
  int _internal_int32_false_true_size() const;
  public:
  void clear_int32_false_true();
  private:
  int32_t _internal_int32_false_true(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_int32_false_true() const;
  void _internal_add_int32_false_true(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_int32_false_true();
  public:
  int32_t int32_false_true(int index) const;
  void set_int32_false_true(int index, int32_t value);
  void add_int32_false_true(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      int32_false_true() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_int32_false_true();

  // repeated float fp32_false_true = 3;
  int fp32_false_true_size() const;
  private:
  int _internal_fp32_false_true_size() const;
  public:
  void clear_fp32_false_true();
  private:
  float _internal_fp32_false_true(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fp32_false_true() const;
  void _internal_add_fp32_false_true(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fp32_false_true();
  public:
  float fp32_false_true(int index) const;
  void set_fp32_false_true(int index, float value);
  void add_fp32_false_true(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fp32_false_true() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fp32_false_true();

  // repeated bool bool_false_true = 5;
  int bool_false_true_size() const;
  private:
  int _internal_bool_false_true_size() const;
  public:
  void clear_bool_false_true();
  private:
  bool _internal_bool_false_true(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_bool_false_true() const;
  void _internal_add_bool_false_true(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_bool_false_true();
  public:
  bool bool_false_true(int index) const;
  void set_bool_false_true(int index, bool value);
  void add_bool_false_true(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      bool_false_true() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_bool_false_true();

  // .inference.ModelSequenceBatching.Control.Kind kind = 1;
  void clear_kind();
  ::inference::ModelSequenceBatching_Control_Kind kind() const;
  void set_kind(::inference::ModelSequenceBatching_Control_Kind value);
  private:
  ::inference::ModelSequenceBatching_Control_Kind _internal_kind() const;
  void _internal_set_kind(::inference::ModelSequenceBatching_Control_Kind value);
  public:

  // .inference.DataType data_type = 4;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.Control)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > int32_false_true_;
    mutable std::atomic<int> _int32_false_true_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fp32_false_true_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > bool_false_true_;
    int kind_;
    int data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_ControlInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.ControlInput) */ {
 public:
  inline ModelSequenceBatching_ControlInput() : ModelSequenceBatching_ControlInput(nullptr) {}
  ~ModelSequenceBatching_ControlInput() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching_ControlInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching_ControlInput(const ModelSequenceBatching_ControlInput& from);
  ModelSequenceBatching_ControlInput(ModelSequenceBatching_ControlInput&& from) noexcept
    : ModelSequenceBatching_ControlInput() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_ControlInput& operator=(const ModelSequenceBatching_ControlInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_ControlInput& operator=(ModelSequenceBatching_ControlInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching_ControlInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelSequenceBatching_ControlInput* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_ControlInput*>(
               &_ModelSequenceBatching_ControlInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ModelSequenceBatching_ControlInput& a, ModelSequenceBatching_ControlInput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_ControlInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_ControlInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching_ControlInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching_ControlInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching_ControlInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching_ControlInput& from) {
    ModelSequenceBatching_ControlInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_ControlInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.ControlInput";
  }
  protected:
  explicit ModelSequenceBatching_ControlInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .inference.ModelSequenceBatching.Control control = 2;
  int control_size() const;
  private:
  int _internal_control_size() const;
  public:
  void clear_control();
  ::inference::ModelSequenceBatching_Control* mutable_control(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >*
      mutable_control();
  private:
  const ::inference::ModelSequenceBatching_Control& _internal_control(int index) const;
  ::inference::ModelSequenceBatching_Control* _internal_add_control();
  public:
  const ::inference::ModelSequenceBatching_Control& control(int index) const;
  ::inference::ModelSequenceBatching_Control* add_control();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >&
      control() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.ControlInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control > control_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_InitialState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.InitialState) */ {
 public:
  inline ModelSequenceBatching_InitialState() : ModelSequenceBatching_InitialState(nullptr) {}
  ~ModelSequenceBatching_InitialState() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching_InitialState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching_InitialState(const ModelSequenceBatching_InitialState& from);
  ModelSequenceBatching_InitialState(ModelSequenceBatching_InitialState&& from) noexcept
    : ModelSequenceBatching_InitialState() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_InitialState& operator=(const ModelSequenceBatching_InitialState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_InitialState& operator=(ModelSequenceBatching_InitialState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching_InitialState& default_instance() {
    return *internal_default_instance();
  }
  enum StateDataCase {
    kZeroData = 3,
    kDataFile = 4,
    STATE_DATA_NOT_SET = 0,
  };

  static inline const ModelSequenceBatching_InitialState* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_InitialState*>(
               &_ModelSequenceBatching_InitialState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ModelSequenceBatching_InitialState& a, ModelSequenceBatching_InitialState& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_InitialState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_InitialState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching_InitialState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching_InitialState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching_InitialState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching_InitialState& from) {
    ModelSequenceBatching_InitialState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_InitialState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.InitialState";
  }
  protected:
  explicit ModelSequenceBatching_InitialState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 2,
    kNameFieldNumber = 5,
    kDataTypeFieldNumber = 1,
    kZeroDataFieldNumber = 3,
    kDataFileFieldNumber = 4,
  };
  // repeated int64 dims = 2;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int64_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dims() const;
  void _internal_add_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dims();
  public:
  int64_t dims(int index) const;
  void set_dims(int index, int64_t value);
  void add_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dims();

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .inference.DataType data_type = 1;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // bool zero_data = 3;
  bool has_zero_data() const;
  private:
  bool _internal_has_zero_data() const;
  public:
  void clear_zero_data();
  bool zero_data() const;
  void set_zero_data(bool value);
  private:
  bool _internal_zero_data() const;
  void _internal_set_zero_data(bool value);
  public:

  // string data_file = 4;
  bool has_data_file() const;
  private:
  bool _internal_has_data_file() const;
  public:
  void clear_data_file();
  const std::string& data_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_file();
  PROTOBUF_NODISCARD std::string* release_data_file();
  void set_allocated_data_file(std::string* data_file);
  private:
  const std::string& _internal_data_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_file(const std::string& value);
  std::string* _internal_mutable_data_file();
  public:

  void clear_state_data();
  StateDataCase state_data_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.InitialState)
 private:
  class _Internal;
  void set_has_zero_data();
  void set_has_data_file();

  inline bool has_state_data() const;
  inline void clear_has_state_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dims_;
    mutable std::atomic<int> _dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int data_type_;
    union StateDataUnion {
      constexpr StateDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool zero_data_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_file_;
    } state_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_State final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.State) */ {
 public:
  inline ModelSequenceBatching_State() : ModelSequenceBatching_State(nullptr) {}
  ~ModelSequenceBatching_State() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching_State(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching_State(const ModelSequenceBatching_State& from);
  ModelSequenceBatching_State(ModelSequenceBatching_State&& from) noexcept
    : ModelSequenceBatching_State() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_State& operator=(const ModelSequenceBatching_State& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_State& operator=(ModelSequenceBatching_State&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching_State& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelSequenceBatching_State* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_State*>(
               &_ModelSequenceBatching_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ModelSequenceBatching_State& a, ModelSequenceBatching_State& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_State* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching_State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching_State>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching_State& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching_State& from) {
    ModelSequenceBatching_State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_State* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.State";
  }
  protected:
  explicit ModelSequenceBatching_State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 4,
    kInitialStateFieldNumber = 5,
    kInputNameFieldNumber = 1,
    kOutputNameFieldNumber = 2,
    kDataTypeFieldNumber = 3,
    kUseSameBufferForInputOutputFieldNumber = 6,
    kUseGrowableMemoryFieldNumber = 7,
  };
  // repeated int64 dims = 4;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int64_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dims() const;
  void _internal_add_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dims();
  public:
  int64_t dims(int index) const;
  void set_dims(int index, int64_t value);
  void add_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dims();

  // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
  int initial_state_size() const;
  private:
  int _internal_initial_state_size() const;
  public:
  void clear_initial_state();
  ::inference::ModelSequenceBatching_InitialState* mutable_initial_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_InitialState >*
      mutable_initial_state();
  private:
  const ::inference::ModelSequenceBatching_InitialState& _internal_initial_state(int index) const;
  ::inference::ModelSequenceBatching_InitialState* _internal_add_initial_state();
  public:
  const ::inference::ModelSequenceBatching_InitialState& initial_state(int index) const;
  ::inference::ModelSequenceBatching_InitialState* add_initial_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_InitialState >&
      initial_state() const;

  // string input_name = 1;
  void clear_input_name();
  const std::string& input_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input_name();
  PROTOBUF_NODISCARD std::string* release_input_name();
  void set_allocated_input_name(std::string* input_name);
  private:
  const std::string& _internal_input_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_name(const std::string& value);
  std::string* _internal_mutable_input_name();
  public:

  // string output_name = 2;
  void clear_output_name();
  const std::string& output_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_name();
  PROTOBUF_NODISCARD std::string* release_output_name();
  void set_allocated_output_name(std::string* output_name);
  private:
  const std::string& _internal_output_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_name(const std::string& value);
  std::string* _internal_mutable_output_name();
  public:

  // .inference.DataType data_type = 3;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // bool use_same_buffer_for_input_output = 6;
  void clear_use_same_buffer_for_input_output();
  bool use_same_buffer_for_input_output() const;
  void set_use_same_buffer_for_input_output(bool value);
  private:
  bool _internal_use_same_buffer_for_input_output() const;
  void _internal_set_use_same_buffer_for_input_output(bool value);
  public:

  // bool use_growable_memory = 7;
  void clear_use_growable_memory();
  bool use_growable_memory() const;
  void set_use_growable_memory(bool value);
  private:
  bool _internal_use_growable_memory() const;
  void _internal_set_use_growable_memory(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dims_;
    mutable std::atomic<int> _dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_InitialState > initial_state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_name_;
    int data_type_;
    bool use_same_buffer_for_input_output_;
    bool use_growable_memory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_StrategyDirect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.StrategyDirect) */ {
 public:
  inline ModelSequenceBatching_StrategyDirect() : ModelSequenceBatching_StrategyDirect(nullptr) {}
  ~ModelSequenceBatching_StrategyDirect() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching_StrategyDirect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching_StrategyDirect(const ModelSequenceBatching_StrategyDirect& from);
  ModelSequenceBatching_StrategyDirect(ModelSequenceBatching_StrategyDirect&& from) noexcept
    : ModelSequenceBatching_StrategyDirect() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_StrategyDirect& operator=(const ModelSequenceBatching_StrategyDirect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_StrategyDirect& operator=(ModelSequenceBatching_StrategyDirect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching_StrategyDirect& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelSequenceBatching_StrategyDirect* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_StrategyDirect*>(
               &_ModelSequenceBatching_StrategyDirect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ModelSequenceBatching_StrategyDirect& a, ModelSequenceBatching_StrategyDirect& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_StrategyDirect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_StrategyDirect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching_StrategyDirect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching_StrategyDirect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching_StrategyDirect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching_StrategyDirect& from) {
    ModelSequenceBatching_StrategyDirect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_StrategyDirect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.StrategyDirect";
  }
  protected:
  explicit ModelSequenceBatching_StrategyDirect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxQueueDelayMicrosecondsFieldNumber = 1,
    kMinimumSlotUtilizationFieldNumber = 2,
  };
  // uint64 max_queue_delay_microseconds = 1;
  void clear_max_queue_delay_microseconds();
  uint64_t max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(uint64_t value);
  private:
  uint64_t _internal_max_queue_delay_microseconds() const;
  void _internal_set_max_queue_delay_microseconds(uint64_t value);
  public:

  // float minimum_slot_utilization = 2;
  void clear_minimum_slot_utilization();
  float minimum_slot_utilization() const;
  void set_minimum_slot_utilization(float value);
  private:
  float _internal_minimum_slot_utilization() const;
  void _internal_set_minimum_slot_utilization(float value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.StrategyDirect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t max_queue_delay_microseconds_;
    float minimum_slot_utilization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_StrategyOldest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.StrategyOldest) */ {
 public:
  inline ModelSequenceBatching_StrategyOldest() : ModelSequenceBatching_StrategyOldest(nullptr) {}
  ~ModelSequenceBatching_StrategyOldest() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching_StrategyOldest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching_StrategyOldest(const ModelSequenceBatching_StrategyOldest& from);
  ModelSequenceBatching_StrategyOldest(ModelSequenceBatching_StrategyOldest&& from) noexcept
    : ModelSequenceBatching_StrategyOldest() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_StrategyOldest& operator=(const ModelSequenceBatching_StrategyOldest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_StrategyOldest& operator=(ModelSequenceBatching_StrategyOldest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching_StrategyOldest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelSequenceBatching_StrategyOldest* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_StrategyOldest*>(
               &_ModelSequenceBatching_StrategyOldest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ModelSequenceBatching_StrategyOldest& a, ModelSequenceBatching_StrategyOldest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_StrategyOldest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_StrategyOldest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching_StrategyOldest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching_StrategyOldest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching_StrategyOldest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching_StrategyOldest& from) {
    ModelSequenceBatching_StrategyOldest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_StrategyOldest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.StrategyOldest";
  }
  protected:
  explicit ModelSequenceBatching_StrategyOldest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreferredBatchSizeFieldNumber = 2,
    kMaxCandidateSequencesFieldNumber = 1,
    kPreserveOrderingFieldNumber = 4,
    kMaxQueueDelayMicrosecondsFieldNumber = 3,
  };
  // repeated int32 preferred_batch_size = 2;
  int preferred_batch_size_size() const;
  private:
  int _internal_preferred_batch_size_size() const;
  public:
  void clear_preferred_batch_size();
  private:
  int32_t _internal_preferred_batch_size(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_preferred_batch_size() const;
  void _internal_add_preferred_batch_size(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_preferred_batch_size();
  public:
  int32_t preferred_batch_size(int index) const;
  void set_preferred_batch_size(int index, int32_t value);
  void add_preferred_batch_size(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      preferred_batch_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_preferred_batch_size();

  // int32 max_candidate_sequences = 1;
  void clear_max_candidate_sequences();
  int32_t max_candidate_sequences() const;
  void set_max_candidate_sequences(int32_t value);
  private:
  int32_t _internal_max_candidate_sequences() const;
  void _internal_set_max_candidate_sequences(int32_t value);
  public:

  // bool preserve_ordering = 4;
  void clear_preserve_ordering();
  bool preserve_ordering() const;
  void set_preserve_ordering(bool value);
  private:
  bool _internal_preserve_ordering() const;
  void _internal_set_preserve_ordering(bool value);
  public:

  // uint64 max_queue_delay_microseconds = 3;
  void clear_max_queue_delay_microseconds();
  uint64_t max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(uint64_t value);
  private:
  uint64_t _internal_max_queue_delay_microseconds() const;
  void _internal_set_max_queue_delay_microseconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.StrategyOldest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > preferred_batch_size_;
    mutable std::atomic<int> _preferred_batch_size_cached_byte_size_;
    int32_t max_candidate_sequences_;
    bool preserve_ordering_;
    uint64_t max_queue_delay_microseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching) */ {
 public:
  inline ModelSequenceBatching() : ModelSequenceBatching(nullptr) {}
  ~ModelSequenceBatching() override;
  explicit PROTOBUF_CONSTEXPR ModelSequenceBatching(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelSequenceBatching(const ModelSequenceBatching& from);
  ModelSequenceBatching(ModelSequenceBatching&& from) noexcept
    : ModelSequenceBatching() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching& operator=(const ModelSequenceBatching& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching& operator=(ModelSequenceBatching&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelSequenceBatching& default_instance() {
    return *internal_default_instance();
  }
  enum StrategyChoiceCase {
    kDirect = 3,
    kOldest = 4,
    STRATEGY_CHOICE_NOT_SET = 0,
  };

  static inline const ModelSequenceBatching* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching*>(
               &_ModelSequenceBatching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ModelSequenceBatching& a, ModelSequenceBatching& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelSequenceBatching* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelSequenceBatching>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelSequenceBatching& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelSequenceBatching& from) {
    ModelSequenceBatching::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching";
  }
  protected:
  explicit ModelSequenceBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelSequenceBatching_Control Control;
  typedef ModelSequenceBatching_ControlInput ControlInput;
  typedef ModelSequenceBatching_InitialState InitialState;
  typedef ModelSequenceBatching_State State;
  typedef ModelSequenceBatching_StrategyDirect StrategyDirect;
  typedef ModelSequenceBatching_StrategyOldest StrategyOldest;

  // accessors -------------------------------------------------------

  enum : int {
    kControlInputFieldNumber = 2,
    kStateFieldNumber = 5,
    kMaxSequenceIdleMicrosecondsFieldNumber = 1,
    kIterativeSequenceFieldNumber = 6,
    kDirectFieldNumber = 3,
    kOldestFieldNumber = 4,
  };
  // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
  int control_input_size() const;
  private:
  int _internal_control_input_size() const;
  public:
  void clear_control_input();
  ::inference::ModelSequenceBatching_ControlInput* mutable_control_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >*
      mutable_control_input();
  private:
  const ::inference::ModelSequenceBatching_ControlInput& _internal_control_input(int index) const;
  ::inference::ModelSequenceBatching_ControlInput* _internal_add_control_input();
  public:
  const ::inference::ModelSequenceBatching_ControlInput& control_input(int index) const;
  ::inference::ModelSequenceBatching_ControlInput* add_control_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >&
      control_input() const;

  // repeated .inference.ModelSequenceBatching.State state = 5;
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  ::inference::ModelSequenceBatching_State* mutable_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_State >*
      mutable_state();
  private:
  const ::inference::ModelSequenceBatching_State& _internal_state(int index) const;
  ::inference::ModelSequenceBatching_State* _internal_add_state();
  public:
  const ::inference::ModelSequenceBatching_State& state(int index) const;
  ::inference::ModelSequenceBatching_State* add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_State >&
      state() const;

  // uint64 max_sequence_idle_microseconds = 1;
  void clear_max_sequence_idle_microseconds();
  uint64_t max_sequence_idle_microseconds() const;
  void set_max_sequence_idle_microseconds(uint64_t value);
  private:
  uint64_t _internal_max_sequence_idle_microseconds() const;
  void _internal_set_max_sequence_idle_microseconds(uint64_t value);
  public:

  // bool iterative_sequence = 6;
  void clear_iterative_sequence();
  bool iterative_sequence() const;
  void set_iterative_sequence(bool value);
  private:
  bool _internal_iterative_sequence() const;
  void _internal_set_iterative_sequence(bool value);
  public:

  // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
  bool has_direct() const;
  private:
  bool _internal_has_direct() const;
  public:
  void clear_direct();
  const ::inference::ModelSequenceBatching_StrategyDirect& direct() const;
  PROTOBUF_NODISCARD ::inference::ModelSequenceBatching_StrategyDirect* release_direct();
  ::inference::ModelSequenceBatching_StrategyDirect* mutable_direct();
  void set_allocated_direct(::inference::ModelSequenceBatching_StrategyDirect* direct);
  private:
  const ::inference::ModelSequenceBatching_StrategyDirect& _internal_direct() const;
  ::inference::ModelSequenceBatching_StrategyDirect* _internal_mutable_direct();
  public:
  void unsafe_arena_set_allocated_direct(
      ::inference::ModelSequenceBatching_StrategyDirect* direct);
  ::inference::ModelSequenceBatching_StrategyDirect* unsafe_arena_release_direct();

  // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
  bool has_oldest() const;
  private:
  bool _internal_has_oldest() const;
  public:
  void clear_oldest();
  const ::inference::ModelSequenceBatching_StrategyOldest& oldest() const;
  PROTOBUF_NODISCARD ::inference::ModelSequenceBatching_StrategyOldest* release_oldest();
  ::inference::ModelSequenceBatching_StrategyOldest* mutable_oldest();
  void set_allocated_oldest(::inference::ModelSequenceBatching_StrategyOldest* oldest);
  private:
  const ::inference::ModelSequenceBatching_StrategyOldest& _internal_oldest() const;
  ::inference::ModelSequenceBatching_StrategyOldest* _internal_mutable_oldest();
  public:
  void unsafe_arena_set_allocated_oldest(
      ::inference::ModelSequenceBatching_StrategyOldest* oldest);
  ::inference::ModelSequenceBatching_StrategyOldest* unsafe_arena_release_oldest();

  void clear_strategy_choice();
  StrategyChoiceCase strategy_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching)
 private:
  class _Internal;
  void set_has_direct();
  void set_has_oldest();

  inline bool has_strategy_choice() const;
  inline void clear_has_strategy_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput > control_input_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_State > state_;
    uint64_t max_sequence_idle_microseconds_;
    bool iterative_sequence_;
    union StrategyChoiceUnion {
      constexpr StrategyChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::inference::ModelSequenceBatching_StrategyDirect* direct_;
      ::inference::ModelSequenceBatching_StrategyOldest* oldest_;
    } strategy_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelEnsembling_Step_InputMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_InputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_InputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelEnsembling_Step_InputMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelEnsembling_Step_InputMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelEnsembling_Step_InputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelEnsembling_Step_InputMapEntry_DoNotUse& other);
  static const ModelEnsembling_Step_InputMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelEnsembling_Step_InputMapEntry_DoNotUse*>(&_ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.InputMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.InputMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelEnsembling_Step_OutputMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_OutputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_OutputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelEnsembling_Step_OutputMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelEnsembling_Step_OutputMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelEnsembling_Step_OutputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelEnsembling_Step_OutputMapEntry_DoNotUse& other);
  static const ModelEnsembling_Step_OutputMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelEnsembling_Step_OutputMapEntry_DoNotUse*>(&_ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.OutputMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.OutputMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelEnsembling_Step final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelEnsembling.Step) */ {
 public:
  inline ModelEnsembling_Step() : ModelEnsembling_Step(nullptr) {}
  ~ModelEnsembling_Step() override;
  explicit PROTOBUF_CONSTEXPR ModelEnsembling_Step(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelEnsembling_Step(const ModelEnsembling_Step& from);
  ModelEnsembling_Step(ModelEnsembling_Step&& from) noexcept
    : ModelEnsembling_Step() {
    *this = ::std::move(from);
  }

  inline ModelEnsembling_Step& operator=(const ModelEnsembling_Step& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelEnsembling_Step& operator=(ModelEnsembling_Step&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelEnsembling_Step& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelEnsembling_Step* internal_default_instance() {
    return reinterpret_cast<const ModelEnsembling_Step*>(
               &_ModelEnsembling_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ModelEnsembling_Step& a, ModelEnsembling_Step& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelEnsembling_Step* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelEnsembling_Step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelEnsembling_Step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelEnsembling_Step>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelEnsembling_Step& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelEnsembling_Step& from) {
    ModelEnsembling_Step::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelEnsembling_Step* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelEnsembling.Step";
  }
  protected:
  explicit ModelEnsembling_Step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputMapFieldNumber = 3,
    kOutputMapFieldNumber = 4,
    kModelNameFieldNumber = 1,
    kModelNamespaceFieldNumber = 5,
    kModelVersionFieldNumber = 2,
  };
  // map<string, string> input_map = 3;
  int input_map_size() const;
  private:
  int _internal_input_map_size() const;
  public:
  void clear_input_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_input_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_input_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      input_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_input_map();

  // map<string, string> output_map = 4;
  int output_map_size() const;
  private:
  int _internal_output_map_size() const;
  public:
  void clear_output_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_output_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_output_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      output_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_output_map();

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_namespace = 5;
  void clear_model_namespace();
  const std::string& model_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_namespace();
  PROTOBUF_NODISCARD std::string* release_model_namespace();
  void set_allocated_model_namespace(std::string* model_namespace);
  private:
  const std::string& _internal_model_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_namespace(const std::string& value);
  std::string* _internal_mutable_model_namespace();
  public:

  // int64 model_version = 2;
  void clear_model_version();
  int64_t model_version() const;
  void set_model_version(int64_t value);
  private:
  int64_t _internal_model_version() const;
  void _internal_set_model_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelEnsembling.Step)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelEnsembling_Step_InputMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> input_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelEnsembling_Step_OutputMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> output_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_namespace_;
    int64_t model_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelEnsembling final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelEnsembling) */ {
 public:
  inline ModelEnsembling() : ModelEnsembling(nullptr) {}
  ~ModelEnsembling() override;
  explicit PROTOBUF_CONSTEXPR ModelEnsembling(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelEnsembling(const ModelEnsembling& from);
  ModelEnsembling(ModelEnsembling&& from) noexcept
    : ModelEnsembling() {
    *this = ::std::move(from);
  }

  inline ModelEnsembling& operator=(const ModelEnsembling& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelEnsembling& operator=(ModelEnsembling&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelEnsembling& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelEnsembling* internal_default_instance() {
    return reinterpret_cast<const ModelEnsembling*>(
               &_ModelEnsembling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ModelEnsembling& a, ModelEnsembling& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelEnsembling* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelEnsembling* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelEnsembling* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelEnsembling>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelEnsembling& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelEnsembling& from) {
    ModelEnsembling::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelEnsembling* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelEnsembling";
  }
  protected:
  explicit ModelEnsembling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelEnsembling_Step Step;

  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
  };
  // repeated .inference.ModelEnsembling.Step step = 1;
  int step_size() const;
  private:
  int _internal_step_size() const;
  public:
  void clear_step();
  ::inference::ModelEnsembling_Step* mutable_step(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >*
      mutable_step();
  private:
  const ::inference::ModelEnsembling_Step& _internal_step(int index) const;
  ::inference::ModelEnsembling_Step* _internal_add_step();
  public:
  const ::inference::ModelEnsembling_Step& step(int index) const;
  ::inference::ModelEnsembling_Step* add_step();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >&
      step() const;

  // @@protoc_insertion_point(class_scope:inference.ModelEnsembling)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step > step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelParameter) */ {
 public:
  inline ModelParameter() : ModelParameter(nullptr) {}
  ~ModelParameter() override;
  explicit PROTOBUF_CONSTEXPR ModelParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelParameter(const ModelParameter& from);
  ModelParameter(ModelParameter&& from) noexcept
    : ModelParameter() {
    *this = ::std::move(from);
  }

  inline ModelParameter& operator=(const ModelParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelParameter& operator=(ModelParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelParameter* internal_default_instance() {
    return reinterpret_cast<const ModelParameter*>(
               &_ModelParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ModelParameter& a, ModelParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelParameter& from) {
    ModelParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelParameter";
  }
  protected:
  explicit ModelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 1,
  };
  // string string_value = 1;
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelWarmup_Input final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelWarmup.Input) */ {
 public:
  inline ModelWarmup_Input() : ModelWarmup_Input(nullptr) {}
  ~ModelWarmup_Input() override;
  explicit PROTOBUF_CONSTEXPR ModelWarmup_Input(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelWarmup_Input(const ModelWarmup_Input& from);
  ModelWarmup_Input(ModelWarmup_Input&& from) noexcept
    : ModelWarmup_Input() {
    *this = ::std::move(from);
  }

  inline ModelWarmup_Input& operator=(const ModelWarmup_Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelWarmup_Input& operator=(ModelWarmup_Input&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelWarmup_Input& default_instance() {
    return *internal_default_instance();
  }
  enum InputDataTypeCase {
    kZeroData = 3,
    kRandomData = 4,
    kInputDataFile = 5,
    INPUT_DATA_TYPE_NOT_SET = 0,
  };

  static inline const ModelWarmup_Input* internal_default_instance() {
    return reinterpret_cast<const ModelWarmup_Input*>(
               &_ModelWarmup_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ModelWarmup_Input& a, ModelWarmup_Input& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelWarmup_Input* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelWarmup_Input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelWarmup_Input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelWarmup_Input>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelWarmup_Input& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelWarmup_Input& from) {
    ModelWarmup_Input::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelWarmup_Input* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelWarmup.Input";
  }
  protected:
  explicit ModelWarmup_Input(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 2,
    kDataTypeFieldNumber = 1,
    kZeroDataFieldNumber = 3,
    kRandomDataFieldNumber = 4,
    kInputDataFileFieldNumber = 5,
  };
  // repeated int64 dims = 2;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int64_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dims() const;
  void _internal_add_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dims();
  public:
  int64_t dims(int index) const;
  void set_dims(int index, int64_t value);
  void add_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dims();

  // .inference.DataType data_type = 1;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // bool zero_data = 3;
  bool has_zero_data() const;
  private:
  bool _internal_has_zero_data() const;
  public:
  void clear_zero_data();
  bool zero_data() const;
  void set_zero_data(bool value);
  private:
  bool _internal_zero_data() const;
  void _internal_set_zero_data(bool value);
  public:

  // bool random_data = 4;
  bool has_random_data() const;
  private:
  bool _internal_has_random_data() const;
  public:
  void clear_random_data();
  bool random_data() const;
  void set_random_data(bool value);
  private:
  bool _internal_random_data() const;
  void _internal_set_random_data(bool value);
  public:

  // string input_data_file = 5;
  bool has_input_data_file() const;
  private:
  bool _internal_has_input_data_file() const;
  public:
  void clear_input_data_file();
  const std::string& input_data_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input_data_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input_data_file();
  PROTOBUF_NODISCARD std::string* release_input_data_file();
  void set_allocated_input_data_file(std::string* input_data_file);
  private:
  const std::string& _internal_input_data_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_data_file(const std::string& value);
  std::string* _internal_mutable_input_data_file();
  public:

  void clear_input_data_type();
  InputDataTypeCase input_data_type_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelWarmup.Input)
 private:
  class _Internal;
  void set_has_zero_data();
  void set_has_random_data();
  void set_has_input_data_file();

  inline bool has_input_data_type() const;
  inline void clear_has_input_data_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dims_;
    mutable std::atomic<int> _dims_cached_byte_size_;
    int data_type_;
    union InputDataTypeUnion {
      constexpr InputDataTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool zero_data_;
      bool random_data_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_data_file_;
    } input_data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelWarmup_InputsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelWarmup_InputsEntry_DoNotUse, 
    std::string, ::inference::ModelWarmup_Input,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelWarmup_InputsEntry_DoNotUse, 
    std::string, ::inference::ModelWarmup_Input,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelWarmup_InputsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelWarmup_InputsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelWarmup_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelWarmup_InputsEntry_DoNotUse& other);
  static const ModelWarmup_InputsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelWarmup_InputsEntry_DoNotUse*>(&_ModelWarmup_InputsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelWarmup.InputsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelWarmup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelWarmup) */ {
 public:
  inline ModelWarmup() : ModelWarmup(nullptr) {}
  ~ModelWarmup() override;
  explicit PROTOBUF_CONSTEXPR ModelWarmup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelWarmup(const ModelWarmup& from);
  ModelWarmup(ModelWarmup&& from) noexcept
    : ModelWarmup() {
    *this = ::std::move(from);
  }

  inline ModelWarmup& operator=(const ModelWarmup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelWarmup& operator=(ModelWarmup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelWarmup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelWarmup* internal_default_instance() {
    return reinterpret_cast<const ModelWarmup*>(
               &_ModelWarmup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ModelWarmup& a, ModelWarmup& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelWarmup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelWarmup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelWarmup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelWarmup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelWarmup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelWarmup& from) {
    ModelWarmup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelWarmup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelWarmup";
  }
  protected:
  explicit ModelWarmup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelWarmup_Input Input;

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 3,
    kNameFieldNumber = 1,
    kBatchSizeFieldNumber = 2,
    kCountFieldNumber = 4,
  };
  // map<string, .inference.ModelWarmup.Input> inputs = 3;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
      _internal_inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
      _internal_mutable_inputs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
      inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
      mutable_inputs();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 batch_size = 2;
  void clear_batch_size();
  uint32_t batch_size() const;
  void set_batch_size(uint32_t value);
  private:
  uint32_t _internal_batch_size() const;
  void _internal_set_batch_size(uint32_t value);
  public:

  // uint32 count = 4;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelWarmup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelWarmup_InputsEntry_DoNotUse,
        std::string, ::inference::ModelWarmup_Input,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t batch_size_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOperations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOperations) */ {
 public:
  inline ModelOperations() : ModelOperations(nullptr) {}
  ~ModelOperations() override;
  explicit PROTOBUF_CONSTEXPR ModelOperations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelOperations(const ModelOperations& from);
  ModelOperations(ModelOperations&& from) noexcept
    : ModelOperations() {
    *this = ::std::move(from);
  }

  inline ModelOperations& operator=(const ModelOperations& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOperations& operator=(ModelOperations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelOperations& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelOperations* internal_default_instance() {
    return reinterpret_cast<const ModelOperations*>(
               &_ModelOperations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ModelOperations& a, ModelOperations& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOperations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOperations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelOperations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelOperations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelOperations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelOperations& from) {
    ModelOperations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOperations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOperations";
  }
  protected:
  explicit ModelOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpLibraryFilenameFieldNumber = 1,
  };
  // repeated string op_library_filename = 1;
  int op_library_filename_size() const;
  private:
  int _internal_op_library_filename_size() const;
  public:
  void clear_op_library_filename();
  const std::string& op_library_filename(int index) const;
  std::string* mutable_op_library_filename(int index);
  void set_op_library_filename(int index, const std::string& value);
  void set_op_library_filename(int index, std::string&& value);
  void set_op_library_filename(int index, const char* value);
  void set_op_library_filename(int index, const char* value, size_t size);
  std::string* add_op_library_filename();
  void add_op_library_filename(const std::string& value);
  void add_op_library_filename(std::string&& value);
  void add_op_library_filename(const char* value);
  void add_op_library_filename(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& op_library_filename() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_op_library_filename();
  private:
  const std::string& _internal_op_library_filename(int index) const;
  std::string* _internal_add_op_library_filename();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOperations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> op_library_filename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelTransactionPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelTransactionPolicy) */ {
 public:
  inline ModelTransactionPolicy() : ModelTransactionPolicy(nullptr) {}
  ~ModelTransactionPolicy() override;
  explicit PROTOBUF_CONSTEXPR ModelTransactionPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelTransactionPolicy(const ModelTransactionPolicy& from);
  ModelTransactionPolicy(ModelTransactionPolicy&& from) noexcept
    : ModelTransactionPolicy() {
    *this = ::std::move(from);
  }

  inline ModelTransactionPolicy& operator=(const ModelTransactionPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTransactionPolicy& operator=(ModelTransactionPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelTransactionPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelTransactionPolicy* internal_default_instance() {
    return reinterpret_cast<const ModelTransactionPolicy*>(
               &_ModelTransactionPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ModelTransactionPolicy& a, ModelTransactionPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTransactionPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTransactionPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelTransactionPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelTransactionPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelTransactionPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelTransactionPolicy& from) {
    ModelTransactionPolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTransactionPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelTransactionPolicy";
  }
  protected:
  explicit ModelTransactionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoupledFieldNumber = 1,
  };
  // bool decoupled = 1;
  void clear_decoupled();
  bool decoupled() const;
  void set_decoupled(bool value);
  private:
  bool _internal_decoupled() const;
  void _internal_set_decoupled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelTransactionPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool decoupled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse& other);
  static const ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse*>(&_ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelRepositoryAgents.Agent.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelRepositoryAgents.Agent.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelRepositoryAgents_Agent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRepositoryAgents.Agent) */ {
 public:
  inline ModelRepositoryAgents_Agent() : ModelRepositoryAgents_Agent(nullptr) {}
  ~ModelRepositoryAgents_Agent() override;
  explicit PROTOBUF_CONSTEXPR ModelRepositoryAgents_Agent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRepositoryAgents_Agent(const ModelRepositoryAgents_Agent& from);
  ModelRepositoryAgents_Agent(ModelRepositoryAgents_Agent&& from) noexcept
    : ModelRepositoryAgents_Agent() {
    *this = ::std::move(from);
  }

  inline ModelRepositoryAgents_Agent& operator=(const ModelRepositoryAgents_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRepositoryAgents_Agent& operator=(ModelRepositoryAgents_Agent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRepositoryAgents_Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelRepositoryAgents_Agent* internal_default_instance() {
    return reinterpret_cast<const ModelRepositoryAgents_Agent*>(
               &_ModelRepositoryAgents_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ModelRepositoryAgents_Agent& a, ModelRepositoryAgents_Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRepositoryAgents_Agent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRepositoryAgents_Agent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelRepositoryAgents_Agent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelRepositoryAgents_Agent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelRepositoryAgents_Agent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelRepositoryAgents_Agent& from) {
    ModelRepositoryAgents_Agent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRepositoryAgents_Agent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRepositoryAgents.Agent";
  }
  protected:
  explicit ModelRepositoryAgents_Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelRepositoryAgents.Agent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelRepositoryAgents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRepositoryAgents) */ {
 public:
  inline ModelRepositoryAgents() : ModelRepositoryAgents(nullptr) {}
  ~ModelRepositoryAgents() override;
  explicit PROTOBUF_CONSTEXPR ModelRepositoryAgents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRepositoryAgents(const ModelRepositoryAgents& from);
  ModelRepositoryAgents(ModelRepositoryAgents&& from) noexcept
    : ModelRepositoryAgents() {
    *this = ::std::move(from);
  }

  inline ModelRepositoryAgents& operator=(const ModelRepositoryAgents& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRepositoryAgents& operator=(ModelRepositoryAgents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRepositoryAgents& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelRepositoryAgents* internal_default_instance() {
    return reinterpret_cast<const ModelRepositoryAgents*>(
               &_ModelRepositoryAgents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ModelRepositoryAgents& a, ModelRepositoryAgents& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRepositoryAgents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRepositoryAgents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelRepositoryAgents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelRepositoryAgents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelRepositoryAgents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelRepositoryAgents& from) {
    ModelRepositoryAgents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRepositoryAgents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRepositoryAgents";
  }
  protected:
  explicit ModelRepositoryAgents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelRepositoryAgents_Agent Agent;

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::inference::ModelRepositoryAgents_Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRepositoryAgents_Agent >*
      mutable_agents();
  private:
  const ::inference::ModelRepositoryAgents_Agent& _internal_agents(int index) const;
  ::inference::ModelRepositoryAgents_Agent* _internal_add_agents();
  public:
  const ::inference::ModelRepositoryAgents_Agent& agents(int index) const;
  ::inference::ModelRepositoryAgents_Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRepositoryAgents_Agent >&
      agents() const;

  // @@protoc_insertion_point(class_scope:inference.ModelRepositoryAgents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRepositoryAgents_Agent > agents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelResponseCache final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelResponseCache) */ {
 public:
  inline ModelResponseCache() : ModelResponseCache(nullptr) {}
  ~ModelResponseCache() override;
  explicit PROTOBUF_CONSTEXPR ModelResponseCache(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelResponseCache(const ModelResponseCache& from);
  ModelResponseCache(ModelResponseCache&& from) noexcept
    : ModelResponseCache() {
    *this = ::std::move(from);
  }

  inline ModelResponseCache& operator=(const ModelResponseCache& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelResponseCache& operator=(ModelResponseCache&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelResponseCache& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelResponseCache* internal_default_instance() {
    return reinterpret_cast<const ModelResponseCache*>(
               &_ModelResponseCache_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ModelResponseCache& a, ModelResponseCache& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelResponseCache* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelResponseCache* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelResponseCache* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelResponseCache>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelResponseCache& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelResponseCache& from) {
    ModelResponseCache::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelResponseCache* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelResponseCache";
  }
  protected:
  explicit ModelResponseCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelResponseCache)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelConfig_CcModelFilenamesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_CcModelFilenamesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_CcModelFilenamesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelConfig_CcModelFilenamesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelConfig_CcModelFilenamesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelConfig_CcModelFilenamesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelConfig_CcModelFilenamesEntry_DoNotUse& other);
  static const ModelConfig_CcModelFilenamesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelConfig_CcModelFilenamesEntry_DoNotUse*>(&_ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.CcModelFilenamesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.CcModelFilenamesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelConfig_MetricTagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_MetricTagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_MetricTagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelConfig_MetricTagsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelConfig_MetricTagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelConfig_MetricTagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelConfig_MetricTagsEntry_DoNotUse& other);
  static const ModelConfig_MetricTagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelConfig_MetricTagsEntry_DoNotUse*>(&_ModelConfig_MetricTagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.MetricTagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.MetricTagsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelConfig_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelConfig_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelConfig_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelConfig_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelConfig_ParametersEntry_DoNotUse& other);
  static const ModelConfig_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelConfig_ParametersEntry_DoNotUse*>(&_ModelConfig_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};

// -------------------------------------------------------------------

class ModelConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelConfig) */ {
 public:
  inline ModelConfig() : ModelConfig(nullptr) {}
  ~ModelConfig() override;
  explicit PROTOBUF_CONSTEXPR ModelConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelConfig(const ModelConfig& from);
  ModelConfig(ModelConfig&& from) noexcept
    : ModelConfig() {
    *this = ::std::move(from);
  }

  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfig& operator=(ModelConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelConfig& default_instance() {
    return *internal_default_instance();
  }
  enum SchedulingChoiceCase {
    kDynamicBatching = 11,
    kSequenceBatching = 13,
    kEnsembleScheduling = 15,
    SCHEDULING_CHOICE_NOT_SET = 0,
  };

  static inline const ModelConfig* internal_default_instance() {
    return reinterpret_cast<const ModelConfig*>(
               &_ModelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ModelConfig& a, ModelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelConfig& from) {
    ModelConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelConfig";
  }
  protected:
  explicit ModelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 5,
    kOutputFieldNumber = 6,
    kInstanceGroupFieldNumber = 7,
    kCcModelFilenamesFieldNumber = 9,
    kMetricTagsFieldNumber = 10,
    kParametersFieldNumber = 14,
    kModelWarmupFieldNumber = 16,
    kBatchInputFieldNumber = 20,
    kBatchOutputFieldNumber = 21,
    kNameFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kDefaultModelFilenameFieldNumber = 8,
    kBackendFieldNumber = 17,
    kRuntimeFieldNumber = 25,
    kVersionPolicyFieldNumber = 3,
    kOptimizationFieldNumber = 12,
    kModelOperationsFieldNumber = 18,
    kModelTransactionPolicyFieldNumber = 19,
    kModelRepositoryAgentsFieldNumber = 23,
    kResponseCacheFieldNumber = 24,
    kMaxBatchSizeFieldNumber = 4,
    kDynamicBatchingFieldNumber = 11,
    kSequenceBatchingFieldNumber = 13,
    kEnsembleSchedulingFieldNumber = 15,
  };
  // repeated .inference.ModelInput input = 5;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  ::inference::ModelInput* mutable_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >*
      mutable_input();
  private:
  const ::inference::ModelInput& _internal_input(int index) const;
  ::inference::ModelInput* _internal_add_input();
  public:
  const ::inference::ModelInput& input(int index) const;
  ::inference::ModelInput* add_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >&
      input() const;

  // repeated .inference.ModelOutput output = 6;
  int output_size() const;
  private:
  int _internal_output_size() const;
  public:
  void clear_output();
  ::inference::ModelOutput* mutable_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >*
      mutable_output();
  private:
  const ::inference::ModelOutput& _internal_output(int index) const;
  ::inference::ModelOutput* _internal_add_output();
  public:
  const ::inference::ModelOutput& output(int index) const;
  ::inference::ModelOutput* add_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >&
      output() const;

  // repeated .inference.ModelInstanceGroup instance_group = 7;
  int instance_group_size() const;
  private:
  int _internal_instance_group_size() const;
  public:
  void clear_instance_group();
  ::inference::ModelInstanceGroup* mutable_instance_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >*
      mutable_instance_group();
  private:
  const ::inference::ModelInstanceGroup& _internal_instance_group(int index) const;
  ::inference::ModelInstanceGroup* _internal_add_instance_group();
  public:
  const ::inference::ModelInstanceGroup& instance_group(int index) const;
  ::inference::ModelInstanceGroup* add_instance_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >&
      instance_group() const;

  // map<string, string> cc_model_filenames = 9;
  int cc_model_filenames_size() const;
  private:
  int _internal_cc_model_filenames_size() const;
  public:
  void clear_cc_model_filenames();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_cc_model_filenames() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_cc_model_filenames();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      cc_model_filenames() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_cc_model_filenames();

  // map<string, string> metric_tags = 10;
  int metric_tags_size() const;
  private:
  int _internal_metric_tags_size() const;
  public:
  void clear_metric_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metric_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metric_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metric_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metric_tags();

  // map<string, .inference.ModelParameter> parameters = 14;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
      mutable_parameters();

  // repeated .inference.ModelWarmup model_warmup = 16;
  int model_warmup_size() const;
  private:
  int _internal_model_warmup_size() const;
  public:
  void clear_model_warmup();
  ::inference::ModelWarmup* mutable_model_warmup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >*
      mutable_model_warmup();
  private:
  const ::inference::ModelWarmup& _internal_model_warmup(int index) const;
  ::inference::ModelWarmup* _internal_add_model_warmup();
  public:
  const ::inference::ModelWarmup& model_warmup(int index) const;
  ::inference::ModelWarmup* add_model_warmup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >&
      model_warmup() const;

  // repeated .inference.BatchInput batch_input = 20;
  int batch_input_size() const;
  private:
  int _internal_batch_input_size() const;
  public:
  void clear_batch_input();
  ::inference::BatchInput* mutable_batch_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >*
      mutable_batch_input();
  private:
  const ::inference::BatchInput& _internal_batch_input(int index) const;
  ::inference::BatchInput* _internal_add_batch_input();
  public:
  const ::inference::BatchInput& batch_input(int index) const;
  ::inference::BatchInput* add_batch_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >&
      batch_input() const;

  // repeated .inference.BatchOutput batch_output = 21;
  int batch_output_size() const;
  private:
  int _internal_batch_output_size() const;
  public:
  void clear_batch_output();
  ::inference::BatchOutput* mutable_batch_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >*
      mutable_batch_output();
  private:
  const ::inference::BatchOutput& _internal_batch_output(int index) const;
  ::inference::BatchOutput* _internal_add_batch_output();
  public:
  const ::inference::BatchOutput& batch_output(int index) const;
  ::inference::BatchOutput* add_batch_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >&
      batch_output() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string platform = 2;
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // string default_model_filename = 8;
  void clear_default_model_filename();
  const std::string& default_model_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_model_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_model_filename();
  PROTOBUF_NODISCARD std::string* release_default_model_filename();
  void set_allocated_default_model_filename(std::string* default_model_filename);
  private:
  const std::string& _internal_default_model_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_model_filename(const std::string& value);
  std::string* _internal_mutable_default_model_filename();
  public:

  // string backend = 17;
  void clear_backend();
  const std::string& backend() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backend(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backend();
  PROTOBUF_NODISCARD std::string* release_backend();
  void set_allocated_backend(std::string* backend);
  private:
  const std::string& _internal_backend() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backend(const std::string& value);
  std::string* _internal_mutable_backend();
  public:

  // string runtime = 25;
  void clear_runtime();
  const std::string& runtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime();
  PROTOBUF_NODISCARD std::string* release_runtime();
  void set_allocated_runtime(std::string* runtime);
  private:
  const std::string& _internal_runtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime(const std::string& value);
  std::string* _internal_mutable_runtime();
  public:

  // .inference.ModelVersionPolicy version_policy = 3;
  bool has_version_policy() const;
  private:
  bool _internal_has_version_policy() const;
  public:
  void clear_version_policy();
  const ::inference::ModelVersionPolicy& version_policy() const;
  PROTOBUF_NODISCARD ::inference::ModelVersionPolicy* release_version_policy();
  ::inference::ModelVersionPolicy* mutable_version_policy();
  void set_allocated_version_policy(::inference::ModelVersionPolicy* version_policy);
  private:
  const ::inference::ModelVersionPolicy& _internal_version_policy() const;
  ::inference::ModelVersionPolicy* _internal_mutable_version_policy();
  public:
  void unsafe_arena_set_allocated_version_policy(
      ::inference::ModelVersionPolicy* version_policy);
  ::inference::ModelVersionPolicy* unsafe_arena_release_version_policy();

  // .inference.ModelOptimizationPolicy optimization = 12;
  bool has_optimization() const;
  private:
  bool _internal_has_optimization() const;
  public:
  void clear_optimization();
  const ::inference::ModelOptimizationPolicy& optimization() const;
  PROTOBUF_NODISCARD ::inference::ModelOptimizationPolicy* release_optimization();
  ::inference::ModelOptimizationPolicy* mutable_optimization();
  void set_allocated_optimization(::inference::ModelOptimizationPolicy* optimization);
  private:
  const ::inference::ModelOptimizationPolicy& _internal_optimization() const;
  ::inference::ModelOptimizationPolicy* _internal_mutable_optimization();
  public:
  void unsafe_arena_set_allocated_optimization(
      ::inference::ModelOptimizationPolicy* optimization);
  ::inference::ModelOptimizationPolicy* unsafe_arena_release_optimization();

  // .inference.ModelOperations model_operations = 18;
  bool has_model_operations() const;
  private:
  bool _internal_has_model_operations() const;
  public:
  void clear_model_operations();
  const ::inference::ModelOperations& model_operations() const;
  PROTOBUF_NODISCARD ::inference::ModelOperations* release_model_operations();
  ::inference::ModelOperations* mutable_model_operations();
  void set_allocated_model_operations(::inference::ModelOperations* model_operations);
  private:
  const ::inference::ModelOperations& _internal_model_operations() const;
  ::inference::ModelOperations* _internal_mutable_model_operations();
  public:
  void unsafe_arena_set_allocated_model_operations(
      ::inference::ModelOperations* model_operations);
  ::inference::ModelOperations* unsafe_arena_release_model_operations();

  // .inference.ModelTransactionPolicy model_transaction_policy = 19;
  bool has_model_transaction_policy() const;
  private:
  bool _internal_has_model_transaction_policy() const;
  public:
  void clear_model_transaction_policy();
  const ::inference::ModelTransactionPolicy& model_transaction_policy() const;
  PROTOBUF_NODISCARD ::inference::ModelTransactionPolicy* release_model_transaction_policy();
  ::inference::ModelTransactionPolicy* mutable_model_transaction_policy();
  void set_allocated_model_transaction_policy(::inference::ModelTransactionPolicy* model_transaction_policy);
  private:
  const ::inference::ModelTransactionPolicy& _internal_model_transaction_policy() const;
  ::inference::ModelTransactionPolicy* _internal_mutable_model_transaction_policy();
  public:
  void unsafe_arena_set_allocated_model_transaction_policy(
      ::inference::ModelTransactionPolicy* model_transaction_policy);
  ::inference::ModelTransactionPolicy* unsafe_arena_release_model_transaction_policy();

  // .inference.ModelRepositoryAgents model_repository_agents = 23;
  bool has_model_repository_agents() const;
  private:
  bool _internal_has_model_repository_agents() const;
  public:
  void clear_model_repository_agents();
  const ::inference::ModelRepositoryAgents& model_repository_agents() const;
  PROTOBUF_NODISCARD ::inference::ModelRepositoryAgents* release_model_repository_agents();
  ::inference::ModelRepositoryAgents* mutable_model_repository_agents();
  void set_allocated_model_repository_agents(::inference::ModelRepositoryAgents* model_repository_agents);
  private:
  const ::inference::ModelRepositoryAgents& _internal_model_repository_agents() const;
  ::inference::ModelRepositoryAgents* _internal_mutable_model_repository_agents();
  public:
  void unsafe_arena_set_allocated_model_repository_agents(
      ::inference::ModelRepositoryAgents* model_repository_agents);
  ::inference::ModelRepositoryAgents* unsafe_arena_release_model_repository_agents();

  // .inference.ModelResponseCache response_cache = 24;
  bool has_response_cache() const;
  private:
  bool _internal_has_response_cache() const;
  public:
  void clear_response_cache();
  const ::inference::ModelResponseCache& response_cache() const;
  PROTOBUF_NODISCARD ::inference::ModelResponseCache* release_response_cache();
  ::inference::ModelResponseCache* mutable_response_cache();
  void set_allocated_response_cache(::inference::ModelResponseCache* response_cache);
  private:
  const ::inference::ModelResponseCache& _internal_response_cache() const;
  ::inference::ModelResponseCache* _internal_mutable_response_cache();
  public:
  void unsafe_arena_set_allocated_response_cache(
      ::inference::ModelResponseCache* response_cache);
  ::inference::ModelResponseCache* unsafe_arena_release_response_cache();

  // int32 max_batch_size = 4;
  void clear_max_batch_size();
  int32_t max_batch_size() const;
  void set_max_batch_size(int32_t value);
  private:
  int32_t _internal_max_batch_size() const;
  void _internal_set_max_batch_size(int32_t value);
  public:

  // .inference.ModelDynamicBatching dynamic_batching = 11;
  bool has_dynamic_batching() const;
  private:
  bool _internal_has_dynamic_batching() const;
  public:
  void clear_dynamic_batching();
  const ::inference::ModelDynamicBatching& dynamic_batching() const;
  PROTOBUF_NODISCARD ::inference::ModelDynamicBatching* release_dynamic_batching();
  ::inference::ModelDynamicBatching* mutable_dynamic_batching();
  void set_allocated_dynamic_batching(::inference::ModelDynamicBatching* dynamic_batching);
  private:
  const ::inference::ModelDynamicBatching& _internal_dynamic_batching() const;
  ::inference::ModelDynamicBatching* _internal_mutable_dynamic_batching();
  public:
  void unsafe_arena_set_allocated_dynamic_batching(
      ::inference::ModelDynamicBatching* dynamic_batching);
  ::inference::ModelDynamicBatching* unsafe_arena_release_dynamic_batching();

  // .inference.ModelSequenceBatching sequence_batching = 13;
  bool has_sequence_batching() const;
  private:
  bool _internal_has_sequence_batching() const;
  public:
  void clear_sequence_batching();
  const ::inference::ModelSequenceBatching& sequence_batching() const;
  PROTOBUF_NODISCARD ::inference::ModelSequenceBatching* release_sequence_batching();
  ::inference::ModelSequenceBatching* mutable_sequence_batching();
  void set_allocated_sequence_batching(::inference::ModelSequenceBatching* sequence_batching);
  private:
  const ::inference::ModelSequenceBatching& _internal_sequence_batching() const;
  ::inference::ModelSequenceBatching* _internal_mutable_sequence_batching();
  public:
  void unsafe_arena_set_allocated_sequence_batching(
      ::inference::ModelSequenceBatching* sequence_batching);
  ::inference::ModelSequenceBatching* unsafe_arena_release_sequence_batching();

  // .inference.ModelEnsembling ensemble_scheduling = 15;
  bool has_ensemble_scheduling() const;
  private:
  bool _internal_has_ensemble_scheduling() const;
  public:
  void clear_ensemble_scheduling();
  const ::inference::ModelEnsembling& ensemble_scheduling() const;
  PROTOBUF_NODISCARD ::inference::ModelEnsembling* release_ensemble_scheduling();
  ::inference::ModelEnsembling* mutable_ensemble_scheduling();
  void set_allocated_ensemble_scheduling(::inference::ModelEnsembling* ensemble_scheduling);
  private:
  const ::inference::ModelEnsembling& _internal_ensemble_scheduling() const;
  ::inference::ModelEnsembling* _internal_mutable_ensemble_scheduling();
  public:
  void unsafe_arena_set_allocated_ensemble_scheduling(
      ::inference::ModelEnsembling* ensemble_scheduling);
  ::inference::ModelEnsembling* unsafe_arena_release_ensemble_scheduling();

  void clear_scheduling_choice();
  SchedulingChoiceCase scheduling_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelConfig)
 private:
  class _Internal;
  void set_has_dynamic_batching();
  void set_has_sequence_batching();
  void set_has_ensemble_scheduling();

  inline bool has_scheduling_choice() const;
  inline void clear_has_scheduling_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput > input_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput > output_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup > instance_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelConfig_CcModelFilenamesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> cc_model_filenames_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelConfig_MetricTagsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metric_tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelConfig_ParametersEntry_DoNotUse,
        std::string, ::inference::ModelParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup > model_warmup_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput > batch_input_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput > batch_output_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_model_filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backend_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_;
    ::inference::ModelVersionPolicy* version_policy_;
    ::inference::ModelOptimizationPolicy* optimization_;
    ::inference::ModelOperations* model_operations_;
    ::inference::ModelTransactionPolicy* model_transaction_policy_;
    ::inference::ModelRepositoryAgents* model_repository_agents_;
    ::inference::ModelResponseCache* response_cache_;
    int32_t max_batch_size_;
    union SchedulingChoiceUnion {
      constexpr SchedulingChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::inference::ModelDynamicBatching* dynamic_batching_;
      ::inference::ModelSequenceBatching* sequence_batching_;
      ::inference::ModelEnsembling* ensemble_scheduling_;
    } scheduling_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelRateLimiter_Resource

// string name = 1;
inline void ModelRateLimiter_Resource::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelRateLimiter_Resource::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.Resource.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelRateLimiter_Resource::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.Resource.name)
}
inline std::string* ModelRateLimiter_Resource::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelRateLimiter.Resource.name)
  return _s;
}
inline const std::string& ModelRateLimiter_Resource::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelRateLimiter_Resource::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelRateLimiter_Resource::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelRateLimiter_Resource::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelRateLimiter.Resource.name)
  return _impl_.name_.Release();
}
inline void ModelRateLimiter_Resource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelRateLimiter.Resource.name)
}

// bool global = 2;
inline void ModelRateLimiter_Resource::clear_global() {
  _impl_.global_ = false;
}
inline bool ModelRateLimiter_Resource::_internal_global() const {
  return _impl_.global_;
}
inline bool ModelRateLimiter_Resource::global() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.Resource.global)
  return _internal_global();
}
inline void ModelRateLimiter_Resource::_internal_set_global(bool value) {
  
  _impl_.global_ = value;
}
inline void ModelRateLimiter_Resource::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.Resource.global)
}

// uint32 count = 3;
inline void ModelRateLimiter_Resource::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t ModelRateLimiter_Resource::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t ModelRateLimiter_Resource::count() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.Resource.count)
  return _internal_count();
}
inline void ModelRateLimiter_Resource::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void ModelRateLimiter_Resource::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.Resource.count)
}

// -------------------------------------------------------------------

// ModelRateLimiter

// repeated .inference.ModelRateLimiter.Resource resources = 1;
inline int ModelRateLimiter::_internal_resources_size() const {
  return _impl_.resources_.size();
}
inline int ModelRateLimiter::resources_size() const {
  return _internal_resources_size();
}
inline void ModelRateLimiter::clear_resources() {
  _impl_.resources_.Clear();
}
inline ::inference::ModelRateLimiter_Resource* ModelRateLimiter::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelRateLimiter.resources)
  return _impl_.resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >*
ModelRateLimiter::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelRateLimiter.resources)
  return &_impl_.resources_;
}
inline const ::inference::ModelRateLimiter_Resource& ModelRateLimiter::_internal_resources(int index) const {
  return _impl_.resources_.Get(index);
}
inline const ::inference::ModelRateLimiter_Resource& ModelRateLimiter::resources(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.resources)
  return _internal_resources(index);
}
inline ::inference::ModelRateLimiter_Resource* ModelRateLimiter::_internal_add_resources() {
  return _impl_.resources_.Add();
}
inline ::inference::ModelRateLimiter_Resource* ModelRateLimiter::add_resources() {
  ::inference::ModelRateLimiter_Resource* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:inference.ModelRateLimiter.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >&
ModelRateLimiter::resources() const {
  // @@protoc_insertion_point(field_list:inference.ModelRateLimiter.resources)
  return _impl_.resources_;
}

// uint32 priority = 2;
inline void ModelRateLimiter::clear_priority() {
  _impl_.priority_ = 0u;
}
inline uint32_t ModelRateLimiter::_internal_priority() const {
  return _impl_.priority_;
}
inline uint32_t ModelRateLimiter::priority() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.priority)
  return _internal_priority();
}
inline void ModelRateLimiter::_internal_set_priority(uint32_t value) {
  
  _impl_.priority_ = value;
}
inline void ModelRateLimiter::set_priority(uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.priority)
}

// -------------------------------------------------------------------

// ModelInstanceGroup_SecondaryDevice

// .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
inline void ModelInstanceGroup_SecondaryDevice::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::_internal_kind() const {
  return static_cast< ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind >(_impl_.kind_);
}
inline ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::kind() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.SecondaryDevice.kind)
  return _internal_kind();
}
inline void ModelInstanceGroup_SecondaryDevice::_internal_set_kind(::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind value) {
  
  _impl_.kind_ = value;
}
inline void ModelInstanceGroup_SecondaryDevice::set_kind(::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.SecondaryDevice.kind)
}

// int64 device_id = 2;
inline void ModelInstanceGroup_SecondaryDevice::clear_device_id() {
  _impl_.device_id_ = int64_t{0};
}
inline int64_t ModelInstanceGroup_SecondaryDevice::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int64_t ModelInstanceGroup_SecondaryDevice::device_id() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.SecondaryDevice.device_id)
  return _internal_device_id();
}
inline void ModelInstanceGroup_SecondaryDevice::_internal_set_device_id(int64_t value) {
  
  _impl_.device_id_ = value;
}
inline void ModelInstanceGroup_SecondaryDevice::set_device_id(int64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.SecondaryDevice.device_id)
}

// -------------------------------------------------------------------

// ModelInstanceGroup

// string name = 1;
inline void ModelInstanceGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelInstanceGroup::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInstanceGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.name)
}
inline std::string* ModelInstanceGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.name)
  return _s;
}
inline const std::string& ModelInstanceGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelInstanceGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInstanceGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInstanceGroup::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInstanceGroup.name)
  return _impl_.name_.Release();
}
inline void ModelInstanceGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInstanceGroup.name)
}

// .inference.ModelInstanceGroup.Kind kind = 4;
inline void ModelInstanceGroup::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::inference::ModelInstanceGroup_Kind ModelInstanceGroup::_internal_kind() const {
  return static_cast< ::inference::ModelInstanceGroup_Kind >(_impl_.kind_);
}
inline ::inference::ModelInstanceGroup_Kind ModelInstanceGroup::kind() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.kind)
  return _internal_kind();
}
inline void ModelInstanceGroup::_internal_set_kind(::inference::ModelInstanceGroup_Kind value) {
  
  _impl_.kind_ = value;
}
inline void ModelInstanceGroup::set_kind(::inference::ModelInstanceGroup_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.kind)
}

// int32 count = 2;
inline void ModelInstanceGroup::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t ModelInstanceGroup::_internal_count() const {
  return _impl_.count_;
}
inline int32_t ModelInstanceGroup::count() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.count)
  return _internal_count();
}
inline void ModelInstanceGroup::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void ModelInstanceGroup::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.count)
}

// .inference.ModelRateLimiter rate_limiter = 6;
inline bool ModelInstanceGroup::_internal_has_rate_limiter() const {
  return this != internal_default_instance() && _impl_.rate_limiter_ != nullptr;
}
inline bool ModelInstanceGroup::has_rate_limiter() const {
  return _internal_has_rate_limiter();
}
inline void ModelInstanceGroup::clear_rate_limiter() {
  if (GetArenaForAllocation() == nullptr && _impl_.rate_limiter_ != nullptr) {
    delete _impl_.rate_limiter_;
  }
  _impl_.rate_limiter_ = nullptr;
}
inline const ::inference::ModelRateLimiter& ModelInstanceGroup::_internal_rate_limiter() const {
  const ::inference::ModelRateLimiter* p = _impl_.rate_limiter_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelRateLimiter&>(
      ::inference::_ModelRateLimiter_default_instance_);
}
inline const ::inference::ModelRateLimiter& ModelInstanceGroup::rate_limiter() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.rate_limiter)
  return _internal_rate_limiter();
}
inline void ModelInstanceGroup::unsafe_arena_set_allocated_rate_limiter(
    ::inference::ModelRateLimiter* rate_limiter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rate_limiter_);
  }
  _impl_.rate_limiter_ = rate_limiter;
  if (rate_limiter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelInstanceGroup.rate_limiter)
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::release_rate_limiter() {
  
  ::inference::ModelRateLimiter* temp = _impl_.rate_limiter_;
  _impl_.rate_limiter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::unsafe_arena_release_rate_limiter() {
  // @@protoc_insertion_point(field_release:inference.ModelInstanceGroup.rate_limiter)
  
  ::inference::ModelRateLimiter* temp = _impl_.rate_limiter_;
  _impl_.rate_limiter_ = nullptr;
  return temp;
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::_internal_mutable_rate_limiter() {
  
  if (_impl_.rate_limiter_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelRateLimiter>(GetArenaForAllocation());
    _impl_.rate_limiter_ = p;
  }
  return _impl_.rate_limiter_;
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::mutable_rate_limiter() {
  ::inference::ModelRateLimiter* _msg = _internal_mutable_rate_limiter();
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.rate_limiter)
  return _msg;
}
inline void ModelInstanceGroup::set_allocated_rate_limiter(::inference::ModelRateLimiter* rate_limiter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rate_limiter_;
  }
  if (rate_limiter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rate_limiter);
    if (message_arena != submessage_arena) {
      rate_limiter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rate_limiter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rate_limiter_ = rate_limiter;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInstanceGroup.rate_limiter)
}

// repeated int32 gpus = 3;
inline int ModelInstanceGroup::_internal_gpus_size() const {
  return _impl_.gpus_.size();
}
inline int ModelInstanceGroup::gpus_size() const {
  return _internal_gpus_size();
}
inline void ModelInstanceGroup::clear_gpus() {
  _impl_.gpus_.Clear();
}
inline int32_t ModelInstanceGroup::_internal_gpus(int index) const {
  return _impl_.gpus_.Get(index);
}
inline int32_t ModelInstanceGroup::gpus(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.gpus)
  return _internal_gpus(index);
}
inline void ModelInstanceGroup::set_gpus(int index, int32_t value) {
  _impl_.gpus_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.gpus)
}
inline void ModelInstanceGroup::_internal_add_gpus(int32_t value) {
  _impl_.gpus_.Add(value);
}
inline void ModelInstanceGroup::add_gpus(int32_t value) {
  _internal_add_gpus(value);
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.gpus)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelInstanceGroup::_internal_gpus() const {
  return _impl_.gpus_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelInstanceGroup::gpus() const {
  // @@protoc_insertion_point(field_list:inference.ModelInstanceGroup.gpus)
  return _internal_gpus();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelInstanceGroup::_internal_mutable_gpus() {
  return &_impl_.gpus_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelInstanceGroup::mutable_gpus() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInstanceGroup.gpus)
  return _internal_mutable_gpus();
}

// repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
inline int ModelInstanceGroup::_internal_secondary_devices_size() const {
  return _impl_.secondary_devices_.size();
}
inline int ModelInstanceGroup::secondary_devices_size() const {
  return _internal_secondary_devices_size();
}
inline void ModelInstanceGroup::clear_secondary_devices() {
  _impl_.secondary_devices_.Clear();
}
inline ::inference::ModelInstanceGroup_SecondaryDevice* ModelInstanceGroup::mutable_secondary_devices(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.secondary_devices)
  return _impl_.secondary_devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup_SecondaryDevice >*
ModelInstanceGroup::mutable_secondary_devices() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInstanceGroup.secondary_devices)
  return &_impl_.secondary_devices_;
}
inline const ::inference::ModelInstanceGroup_SecondaryDevice& ModelInstanceGroup::_internal_secondary_devices(int index) const {
  return _impl_.secondary_devices_.Get(index);
}
inline const ::inference::ModelInstanceGroup_SecondaryDevice& ModelInstanceGroup::secondary_devices(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.secondary_devices)
  return _internal_secondary_devices(index);
}
inline ::inference::ModelInstanceGroup_SecondaryDevice* ModelInstanceGroup::_internal_add_secondary_devices() {
  return _impl_.secondary_devices_.Add();
}
inline ::inference::ModelInstanceGroup_SecondaryDevice* ModelInstanceGroup::add_secondary_devices() {
  ::inference::ModelInstanceGroup_SecondaryDevice* _add = _internal_add_secondary_devices();
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.secondary_devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup_SecondaryDevice >&
ModelInstanceGroup::secondary_devices() const {
  // @@protoc_insertion_point(field_list:inference.ModelInstanceGroup.secondary_devices)
  return _impl_.secondary_devices_;
}

// repeated string profile = 5;
inline int ModelInstanceGroup::_internal_profile_size() const {
  return _impl_.profile_.size();
}
inline int ModelInstanceGroup::profile_size() const {
  return _internal_profile_size();
}
inline void ModelInstanceGroup::clear_profile() {
  _impl_.profile_.Clear();
}
inline std::string* ModelInstanceGroup::add_profile() {
  std::string* _s = _internal_add_profile();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelInstanceGroup.profile)
  return _s;
}
inline const std::string& ModelInstanceGroup::_internal_profile(int index) const {
  return _impl_.profile_.Get(index);
}
inline const std::string& ModelInstanceGroup::profile(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.profile)
  return _internal_profile(index);
}
inline std::string* ModelInstanceGroup::mutable_profile(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.profile)
  return _impl_.profile_.Mutable(index);
}
inline void ModelInstanceGroup::set_profile(int index, const std::string& value) {
  _impl_.profile_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::set_profile(int index, std::string&& value) {
  _impl_.profile_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::set_profile(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.profile_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::set_profile(int index, const char* value, size_t size) {
  _impl_.profile_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInstanceGroup.profile)
}
inline std::string* ModelInstanceGroup::_internal_add_profile() {
  return _impl_.profile_.Add();
}
inline void ModelInstanceGroup::add_profile(const std::string& value) {
  _impl_.profile_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::add_profile(std::string&& value) {
  _impl_.profile_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::add_profile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.profile_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::add_profile(const char* value, size_t size) {
  _impl_.profile_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelInstanceGroup.profile)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInstanceGroup::profile() const {
  // @@protoc_insertion_point(field_list:inference.ModelInstanceGroup.profile)
  return _impl_.profile_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInstanceGroup::mutable_profile() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInstanceGroup.profile)
  return &_impl_.profile_;
}

// bool passive = 7;
inline void ModelInstanceGroup::clear_passive() {
  _impl_.passive_ = false;
}
inline bool ModelInstanceGroup::_internal_passive() const {
  return _impl_.passive_;
}
inline bool ModelInstanceGroup::passive() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.passive)
  return _internal_passive();
}
inline void ModelInstanceGroup::_internal_set_passive(bool value) {
  
  _impl_.passive_ = value;
}
inline void ModelInstanceGroup::set_passive(bool value) {
  _internal_set_passive(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.passive)
}

// string host_policy = 9;
inline void ModelInstanceGroup::clear_host_policy() {
  _impl_.host_policy_.ClearToEmpty();
}
inline const std::string& ModelInstanceGroup::host_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.host_policy)
  return _internal_host_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInstanceGroup::set_host_policy(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.host_policy)
}
inline std::string* ModelInstanceGroup::mutable_host_policy() {
  std::string* _s = _internal_mutable_host_policy();
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.host_policy)
  return _s;
}
inline const std::string& ModelInstanceGroup::_internal_host_policy() const {
  return _impl_.host_policy_.Get();
}
inline void ModelInstanceGroup::_internal_set_host_policy(const std::string& value) {
  
  _impl_.host_policy_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInstanceGroup::_internal_mutable_host_policy() {
  
  return _impl_.host_policy_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInstanceGroup::release_host_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelInstanceGroup.host_policy)
  return _impl_.host_policy_.Release();
}
inline void ModelInstanceGroup::set_allocated_host_policy(std::string* host_policy) {
  if (host_policy != nullptr) {
    
  } else {
    
  }
  _impl_.host_policy_.SetAllocated(host_policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_policy_.IsDefault()) {
    _impl_.host_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInstanceGroup.host_policy)
}

// -------------------------------------------------------------------

// ModelTensorReshape

// repeated int64 shape = 1;
inline int ModelTensorReshape::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int ModelTensorReshape::shape_size() const {
  return _internal_shape_size();
}
inline void ModelTensorReshape::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t ModelTensorReshape::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t ModelTensorReshape::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelTensorReshape.shape)
  return _internal_shape(index);
}
inline void ModelTensorReshape::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelTensorReshape.shape)
}
inline void ModelTensorReshape::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void ModelTensorReshape::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.ModelTensorReshape.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelTensorReshape::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelTensorReshape::shape() const {
  // @@protoc_insertion_point(field_list:inference.ModelTensorReshape.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelTensorReshape::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelTensorReshape::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelTensorReshape.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// ModelInput

// string name = 1;
inline void ModelInput::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelInput::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInput::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInput.name)
}
inline std::string* ModelInput::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInput.name)
  return _s;
}
inline const std::string& ModelInput::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelInput::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInput::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInput::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInput.name)
  return _impl_.name_.Release();
}
inline void ModelInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInput.name)
}

// .inference.DataType data_type = 2;
inline void ModelInput::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType ModelInput::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType ModelInput::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.data_type)
  return _internal_data_type();
}
inline void ModelInput::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void ModelInput::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.data_type)
}

// .inference.ModelInput.Format format = 3;
inline void ModelInput::clear_format() {
  _impl_.format_ = 0;
}
inline ::inference::ModelInput_Format ModelInput::_internal_format() const {
  return static_cast< ::inference::ModelInput_Format >(_impl_.format_);
}
inline ::inference::ModelInput_Format ModelInput::format() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.format)
  return _internal_format();
}
inline void ModelInput::_internal_set_format(::inference::ModelInput_Format value) {
  
  _impl_.format_ = value;
}
inline void ModelInput::set_format(::inference::ModelInput_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.format)
}

// repeated int64 dims = 4;
inline int ModelInput::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int ModelInput::dims_size() const {
  return _internal_dims_size();
}
inline void ModelInput::clear_dims() {
  _impl_.dims_.Clear();
}
inline int64_t ModelInput::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int64_t ModelInput::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.dims)
  return _internal_dims(index);
}
inline void ModelInput::set_dims(int index, int64_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.dims)
}
inline void ModelInput::_internal_add_dims(int64_t value) {
  _impl_.dims_.Add(value);
}
inline void ModelInput::add_dims(int64_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelInput.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelInput::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelInput::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelInput.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelInput::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelInput::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInput.dims)
  return _internal_mutable_dims();
}

// .inference.ModelTensorReshape reshape = 5;
inline bool ModelInput::_internal_has_reshape() const {
  return this != internal_default_instance() && _impl_.reshape_ != nullptr;
}
inline bool ModelInput::has_reshape() const {
  return _internal_has_reshape();
}
inline void ModelInput::clear_reshape() {
  if (GetArenaForAllocation() == nullptr && _impl_.reshape_ != nullptr) {
    delete _impl_.reshape_;
  }
  _impl_.reshape_ = nullptr;
}
inline const ::inference::ModelTensorReshape& ModelInput::_internal_reshape() const {
  const ::inference::ModelTensorReshape* p = _impl_.reshape_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelTensorReshape&>(
      ::inference::_ModelTensorReshape_default_instance_);
}
inline const ::inference::ModelTensorReshape& ModelInput::reshape() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.reshape)
  return _internal_reshape();
}
inline void ModelInput::unsafe_arena_set_allocated_reshape(
    ::inference::ModelTensorReshape* reshape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reshape_);
  }
  _impl_.reshape_ = reshape;
  if (reshape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelInput.reshape)
}
inline ::inference::ModelTensorReshape* ModelInput::release_reshape() {
  
  ::inference::ModelTensorReshape* temp = _impl_.reshape_;
  _impl_.reshape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelTensorReshape* ModelInput::unsafe_arena_release_reshape() {
  // @@protoc_insertion_point(field_release:inference.ModelInput.reshape)
  
  ::inference::ModelTensorReshape* temp = _impl_.reshape_;
  _impl_.reshape_ = nullptr;
  return temp;
}
inline ::inference::ModelTensorReshape* ModelInput::_internal_mutable_reshape() {
  
  if (_impl_.reshape_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelTensorReshape>(GetArenaForAllocation());
    _impl_.reshape_ = p;
  }
  return _impl_.reshape_;
}
inline ::inference::ModelTensorReshape* ModelInput::mutable_reshape() {
  ::inference::ModelTensorReshape* _msg = _internal_mutable_reshape();
  // @@protoc_insertion_point(field_mutable:inference.ModelInput.reshape)
  return _msg;
}
inline void ModelInput::set_allocated_reshape(::inference::ModelTensorReshape* reshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reshape_;
  }
  if (reshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reshape);
    if (message_arena != submessage_arena) {
      reshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshape, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reshape_ = reshape;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInput.reshape)
}

// bool is_shape_tensor = 6;
inline void ModelInput::clear_is_shape_tensor() {
  _impl_.is_shape_tensor_ = false;
}
inline bool ModelInput::_internal_is_shape_tensor() const {
  return _impl_.is_shape_tensor_;
}
inline bool ModelInput::is_shape_tensor() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.is_shape_tensor)
  return _internal_is_shape_tensor();
}
inline void ModelInput::_internal_set_is_shape_tensor(bool value) {
  
  _impl_.is_shape_tensor_ = value;
}
inline void ModelInput::set_is_shape_tensor(bool value) {
  _internal_set_is_shape_tensor(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.is_shape_tensor)
}

// bool allow_ragged_batch = 7;
inline void ModelInput::clear_allow_ragged_batch() {
  _impl_.allow_ragged_batch_ = false;
}
inline bool ModelInput::_internal_allow_ragged_batch() const {
  return _impl_.allow_ragged_batch_;
}
inline bool ModelInput::allow_ragged_batch() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.allow_ragged_batch)
  return _internal_allow_ragged_batch();
}
inline void ModelInput::_internal_set_allow_ragged_batch(bool value) {
  
  _impl_.allow_ragged_batch_ = value;
}
inline void ModelInput::set_allow_ragged_batch(bool value) {
  _internal_set_allow_ragged_batch(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.allow_ragged_batch)
}

// bool optional = 8;
inline void ModelInput::clear_optional() {
  _impl_.optional_ = false;
}
inline bool ModelInput::_internal_optional() const {
  return _impl_.optional_;
}
inline bool ModelInput::optional() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.optional)
  return _internal_optional();
}
inline void ModelInput::_internal_set_optional(bool value) {
  
  _impl_.optional_ = value;
}
inline void ModelInput::set_optional(bool value) {
  _internal_set_optional(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.optional)
}

// -------------------------------------------------------------------

// ModelOutput

// string name = 1;
inline void ModelOutput::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelOutput::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelOutput::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelOutput.name)
}
inline std::string* ModelOutput::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelOutput.name)
  return _s;
}
inline const std::string& ModelOutput::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelOutput::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelOutput::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelOutput::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelOutput.name)
  return _impl_.name_.Release();
}
inline void ModelOutput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOutput.name)
}

// .inference.DataType data_type = 2;
inline void ModelOutput::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType ModelOutput::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType ModelOutput::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.data_type)
  return _internal_data_type();
}
inline void ModelOutput::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void ModelOutput::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.data_type)
}

// repeated int64 dims = 3;
inline int ModelOutput::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int ModelOutput::dims_size() const {
  return _internal_dims_size();
}
inline void ModelOutput::clear_dims() {
  _impl_.dims_.Clear();
}
inline int64_t ModelOutput::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int64_t ModelOutput::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.dims)
  return _internal_dims(index);
}
inline void ModelOutput::set_dims(int index, int64_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.dims)
}
inline void ModelOutput::_internal_add_dims(int64_t value) {
  _impl_.dims_.Add(value);
}
inline void ModelOutput::add_dims(int64_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelOutput.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelOutput::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelOutput::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelOutput.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelOutput::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelOutput::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOutput.dims)
  return _internal_mutable_dims();
}

// .inference.ModelTensorReshape reshape = 5;
inline bool ModelOutput::_internal_has_reshape() const {
  return this != internal_default_instance() && _impl_.reshape_ != nullptr;
}
inline bool ModelOutput::has_reshape() const {
  return _internal_has_reshape();
}
inline void ModelOutput::clear_reshape() {
  if (GetArenaForAllocation() == nullptr && _impl_.reshape_ != nullptr) {
    delete _impl_.reshape_;
  }
  _impl_.reshape_ = nullptr;
}
inline const ::inference::ModelTensorReshape& ModelOutput::_internal_reshape() const {
  const ::inference::ModelTensorReshape* p = _impl_.reshape_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelTensorReshape&>(
      ::inference::_ModelTensorReshape_default_instance_);
}
inline const ::inference::ModelTensorReshape& ModelOutput::reshape() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.reshape)
  return _internal_reshape();
}
inline void ModelOutput::unsafe_arena_set_allocated_reshape(
    ::inference::ModelTensorReshape* reshape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reshape_);
  }
  _impl_.reshape_ = reshape;
  if (reshape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOutput.reshape)
}
inline ::inference::ModelTensorReshape* ModelOutput::release_reshape() {
  
  ::inference::ModelTensorReshape* temp = _impl_.reshape_;
  _impl_.reshape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelTensorReshape* ModelOutput::unsafe_arena_release_reshape() {
  // @@protoc_insertion_point(field_release:inference.ModelOutput.reshape)
  
  ::inference::ModelTensorReshape* temp = _impl_.reshape_;
  _impl_.reshape_ = nullptr;
  return temp;
}
inline ::inference::ModelTensorReshape* ModelOutput::_internal_mutable_reshape() {
  
  if (_impl_.reshape_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelTensorReshape>(GetArenaForAllocation());
    _impl_.reshape_ = p;
  }
  return _impl_.reshape_;
}
inline ::inference::ModelTensorReshape* ModelOutput::mutable_reshape() {
  ::inference::ModelTensorReshape* _msg = _internal_mutable_reshape();
  // @@protoc_insertion_point(field_mutable:inference.ModelOutput.reshape)
  return _msg;
}
inline void ModelOutput::set_allocated_reshape(::inference::ModelTensorReshape* reshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reshape_;
  }
  if (reshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reshape);
    if (message_arena != submessage_arena) {
      reshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshape, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reshape_ = reshape;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOutput.reshape)
}

// string label_filename = 4;
inline void ModelOutput::clear_label_filename() {
  _impl_.label_filename_.ClearToEmpty();
}
inline const std::string& ModelOutput::label_filename() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.label_filename)
  return _internal_label_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelOutput::set_label_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelOutput.label_filename)
}
inline std::string* ModelOutput::mutable_label_filename() {
  std::string* _s = _internal_mutable_label_filename();
  // @@protoc_insertion_point(field_mutable:inference.ModelOutput.label_filename)
  return _s;
}
inline const std::string& ModelOutput::_internal_label_filename() const {
  return _impl_.label_filename_.Get();
}
inline void ModelOutput::_internal_set_label_filename(const std::string& value) {
  
  _impl_.label_filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelOutput::_internal_mutable_label_filename() {
  
  return _impl_.label_filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelOutput::release_label_filename() {
  // @@protoc_insertion_point(field_release:inference.ModelOutput.label_filename)
  return _impl_.label_filename_.Release();
}
inline void ModelOutput::set_allocated_label_filename(std::string* label_filename) {
  if (label_filename != nullptr) {
    
  } else {
    
  }
  _impl_.label_filename_.SetAllocated(label_filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_filename_.IsDefault()) {
    _impl_.label_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOutput.label_filename)
}

// bool is_shape_tensor = 6;
inline void ModelOutput::clear_is_shape_tensor() {
  _impl_.is_shape_tensor_ = false;
}
inline bool ModelOutput::_internal_is_shape_tensor() const {
  return _impl_.is_shape_tensor_;
}
inline bool ModelOutput::is_shape_tensor() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.is_shape_tensor)
  return _internal_is_shape_tensor();
}
inline void ModelOutput::_internal_set_is_shape_tensor(bool value) {
  
  _impl_.is_shape_tensor_ = value;
}
inline void ModelOutput::set_is_shape_tensor(bool value) {
  _internal_set_is_shape_tensor(value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.is_shape_tensor)
}

// -------------------------------------------------------------------

// BatchInput

// .inference.BatchInput.Kind kind = 1;
inline void BatchInput::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::inference::BatchInput_Kind BatchInput::_internal_kind() const {
  return static_cast< ::inference::BatchInput_Kind >(_impl_.kind_);
}
inline ::inference::BatchInput_Kind BatchInput::kind() const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.kind)
  return _internal_kind();
}
inline void BatchInput::_internal_set_kind(::inference::BatchInput_Kind value) {
  
  _impl_.kind_ = value;
}
inline void BatchInput::set_kind(::inference::BatchInput_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.BatchInput.kind)
}

// repeated string target_name = 2;
inline int BatchInput::_internal_target_name_size() const {
  return _impl_.target_name_.size();
}
inline int BatchInput::target_name_size() const {
  return _internal_target_name_size();
}
inline void BatchInput::clear_target_name() {
  _impl_.target_name_.Clear();
}
inline std::string* BatchInput::add_target_name() {
  std::string* _s = _internal_add_target_name();
  // @@protoc_insertion_point(field_add_mutable:inference.BatchInput.target_name)
  return _s;
}
inline const std::string& BatchInput::_internal_target_name(int index) const {
  return _impl_.target_name_.Get(index);
}
inline const std::string& BatchInput::target_name(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.target_name)
  return _internal_target_name(index);
}
inline std::string* BatchInput::mutable_target_name(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchInput.target_name)
  return _impl_.target_name_.Mutable(index);
}
inline void BatchInput::set_target_name(int index, const std::string& value) {
  _impl_.target_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.BatchInput.target_name)
}
inline void BatchInput::set_target_name(int index, std::string&& value) {
  _impl_.target_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.BatchInput.target_name)
}
inline void BatchInput::set_target_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.target_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchInput.target_name)
}
inline void BatchInput::set_target_name(int index, const char* value, size_t size) {
  _impl_.target_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchInput.target_name)
}
inline std::string* BatchInput::_internal_add_target_name() {
  return _impl_.target_name_.Add();
}
inline void BatchInput::add_target_name(const std::string& value) {
  _impl_.target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchInput.target_name)
}
inline void BatchInput::add_target_name(std::string&& value) {
  _impl_.target_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchInput.target_name)
}
inline void BatchInput::add_target_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchInput.target_name)
}
inline void BatchInput::add_target_name(const char* value, size_t size) {
  _impl_.target_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchInput.target_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchInput::target_name() const {
  // @@protoc_insertion_point(field_list:inference.BatchInput.target_name)
  return _impl_.target_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchInput::mutable_target_name() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchInput.target_name)
  return &_impl_.target_name_;
}

// .inference.DataType data_type = 3;
inline void BatchInput::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType BatchInput::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType BatchInput::data_type() const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.data_type)
  return _internal_data_type();
}
inline void BatchInput::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void BatchInput::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.BatchInput.data_type)
}

// repeated string source_input = 4;
inline int BatchInput::_internal_source_input_size() const {
  return _impl_.source_input_.size();
}
inline int BatchInput::source_input_size() const {
  return _internal_source_input_size();
}
inline void BatchInput::clear_source_input() {
  _impl_.source_input_.Clear();
}
inline std::string* BatchInput::add_source_input() {
  std::string* _s = _internal_add_source_input();
  // @@protoc_insertion_point(field_add_mutable:inference.BatchInput.source_input)
  return _s;
}
inline const std::string& BatchInput::_internal_source_input(int index) const {
  return _impl_.source_input_.Get(index);
}
inline const std::string& BatchInput::source_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.source_input)
  return _internal_source_input(index);
}
inline std::string* BatchInput::mutable_source_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchInput.source_input)
  return _impl_.source_input_.Mutable(index);
}
inline void BatchInput::set_source_input(int index, const std::string& value) {
  _impl_.source_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.BatchInput.source_input)
}
inline void BatchInput::set_source_input(int index, std::string&& value) {
  _impl_.source_input_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.BatchInput.source_input)
}
inline void BatchInput::set_source_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchInput.source_input)
}
inline void BatchInput::set_source_input(int index, const char* value, size_t size) {
  _impl_.source_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchInput.source_input)
}
inline std::string* BatchInput::_internal_add_source_input() {
  return _impl_.source_input_.Add();
}
inline void BatchInput::add_source_input(const std::string& value) {
  _impl_.source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchInput.source_input)
}
inline void BatchInput::add_source_input(std::string&& value) {
  _impl_.source_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchInput.source_input)
}
inline void BatchInput::add_source_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchInput.source_input)
}
inline void BatchInput::add_source_input(const char* value, size_t size) {
  _impl_.source_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchInput.source_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchInput::source_input() const {
  // @@protoc_insertion_point(field_list:inference.BatchInput.source_input)
  return _impl_.source_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchInput::mutable_source_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchInput.source_input)
  return &_impl_.source_input_;
}

// -------------------------------------------------------------------

// BatchOutput

// repeated string target_name = 1;
inline int BatchOutput::_internal_target_name_size() const {
  return _impl_.target_name_.size();
}
inline int BatchOutput::target_name_size() const {
  return _internal_target_name_size();
}
inline void BatchOutput::clear_target_name() {
  _impl_.target_name_.Clear();
}
inline std::string* BatchOutput::add_target_name() {
  std::string* _s = _internal_add_target_name();
  // @@protoc_insertion_point(field_add_mutable:inference.BatchOutput.target_name)
  return _s;
}
inline const std::string& BatchOutput::_internal_target_name(int index) const {
  return _impl_.target_name_.Get(index);
}
inline const std::string& BatchOutput::target_name(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchOutput.target_name)
  return _internal_target_name(index);
}
inline std::string* BatchOutput::mutable_target_name(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchOutput.target_name)
  return _impl_.target_name_.Mutable(index);
}
inline void BatchOutput::set_target_name(int index, const std::string& value) {
  _impl_.target_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.BatchOutput.target_name)
}
inline void BatchOutput::set_target_name(int index, std::string&& value) {
  _impl_.target_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.BatchOutput.target_name)
}
inline void BatchOutput::set_target_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.target_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchOutput.target_name)
}
inline void BatchOutput::set_target_name(int index, const char* value, size_t size) {
  _impl_.target_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchOutput.target_name)
}
inline std::string* BatchOutput::_internal_add_target_name() {
  return _impl_.target_name_.Add();
}
inline void BatchOutput::add_target_name(const std::string& value) {
  _impl_.target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchOutput.target_name)
}
inline void BatchOutput::add_target_name(std::string&& value) {
  _impl_.target_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchOutput.target_name)
}
inline void BatchOutput::add_target_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchOutput.target_name)
}
inline void BatchOutput::add_target_name(const char* value, size_t size) {
  _impl_.target_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchOutput.target_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchOutput::target_name() const {
  // @@protoc_insertion_point(field_list:inference.BatchOutput.target_name)
  return _impl_.target_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchOutput::mutable_target_name() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchOutput.target_name)
  return &_impl_.target_name_;
}

// .inference.BatchOutput.Kind kind = 2;
inline void BatchOutput::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::inference::BatchOutput_Kind BatchOutput::_internal_kind() const {
  return static_cast< ::inference::BatchOutput_Kind >(_impl_.kind_);
}
inline ::inference::BatchOutput_Kind BatchOutput::kind() const {
  // @@protoc_insertion_point(field_get:inference.BatchOutput.kind)
  return _internal_kind();
}
inline void BatchOutput::_internal_set_kind(::inference::BatchOutput_Kind value) {
  
  _impl_.kind_ = value;
}
inline void BatchOutput::set_kind(::inference::BatchOutput_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.BatchOutput.kind)
}

// repeated string source_input = 3;
inline int BatchOutput::_internal_source_input_size() const {
  return _impl_.source_input_.size();
}
inline int BatchOutput::source_input_size() const {
  return _internal_source_input_size();
}
inline void BatchOutput::clear_source_input() {
  _impl_.source_input_.Clear();
}
inline std::string* BatchOutput::add_source_input() {
  std::string* _s = _internal_add_source_input();
  // @@protoc_insertion_point(field_add_mutable:inference.BatchOutput.source_input)
  return _s;
}
inline const std::string& BatchOutput::_internal_source_input(int index) const {
  return _impl_.source_input_.Get(index);
}
inline const std::string& BatchOutput::source_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchOutput.source_input)
  return _internal_source_input(index);
}
inline std::string* BatchOutput::mutable_source_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchOutput.source_input)
  return _impl_.source_input_.Mutable(index);
}
inline void BatchOutput::set_source_input(int index, const std::string& value) {
  _impl_.source_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.BatchOutput.source_input)
}
inline void BatchOutput::set_source_input(int index, std::string&& value) {
  _impl_.source_input_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.BatchOutput.source_input)
}
inline void BatchOutput::set_source_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchOutput.source_input)
}
inline void BatchOutput::set_source_input(int index, const char* value, size_t size) {
  _impl_.source_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchOutput.source_input)
}
inline std::string* BatchOutput::_internal_add_source_input() {
  return _impl_.source_input_.Add();
}
inline void BatchOutput::add_source_input(const std::string& value) {
  _impl_.source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchOutput.source_input)
}
inline void BatchOutput::add_source_input(std::string&& value) {
  _impl_.source_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchOutput.source_input)
}
inline void BatchOutput::add_source_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchOutput.source_input)
}
inline void BatchOutput::add_source_input(const char* value, size_t size) {
  _impl_.source_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchOutput.source_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchOutput::source_input() const {
  // @@protoc_insertion_point(field_list:inference.BatchOutput.source_input)
  return _impl_.source_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchOutput::mutable_source_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchOutput.source_input)
  return &_impl_.source_input_;
}

// -------------------------------------------------------------------

// ModelVersionPolicy_Latest

// uint32 num_versions = 1;
inline void ModelVersionPolicy_Latest::clear_num_versions() {
  _impl_.num_versions_ = 0u;
}
inline uint32_t ModelVersionPolicy_Latest::_internal_num_versions() const {
  return _impl_.num_versions_;
}
inline uint32_t ModelVersionPolicy_Latest::num_versions() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.Latest.num_versions)
  return _internal_num_versions();
}
inline void ModelVersionPolicy_Latest::_internal_set_num_versions(uint32_t value) {
  
  _impl_.num_versions_ = value;
}
inline void ModelVersionPolicy_Latest::set_num_versions(uint32_t value) {
  _internal_set_num_versions(value);
  // @@protoc_insertion_point(field_set:inference.ModelVersionPolicy.Latest.num_versions)
}

// -------------------------------------------------------------------

// ModelVersionPolicy_All

// -------------------------------------------------------------------

// ModelVersionPolicy_Specific

// repeated int64 versions = 1;
inline int ModelVersionPolicy_Specific::_internal_versions_size() const {
  return _impl_.versions_.size();
}
inline int ModelVersionPolicy_Specific::versions_size() const {
  return _internal_versions_size();
}
inline void ModelVersionPolicy_Specific::clear_versions() {
  _impl_.versions_.Clear();
}
inline int64_t ModelVersionPolicy_Specific::_internal_versions(int index) const {
  return _impl_.versions_.Get(index);
}
inline int64_t ModelVersionPolicy_Specific::versions(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.Specific.versions)
  return _internal_versions(index);
}
inline void ModelVersionPolicy_Specific::set_versions(int index, int64_t value) {
  _impl_.versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelVersionPolicy.Specific.versions)
}
inline void ModelVersionPolicy_Specific::_internal_add_versions(int64_t value) {
  _impl_.versions_.Add(value);
}
inline void ModelVersionPolicy_Specific::add_versions(int64_t value) {
  _internal_add_versions(value);
  // @@protoc_insertion_point(field_add:inference.ModelVersionPolicy.Specific.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelVersionPolicy_Specific::_internal_versions() const {
  return _impl_.versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelVersionPolicy_Specific::versions() const {
  // @@protoc_insertion_point(field_list:inference.ModelVersionPolicy.Specific.versions)
  return _internal_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelVersionPolicy_Specific::_internal_mutable_versions() {
  return &_impl_.versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelVersionPolicy_Specific::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelVersionPolicy.Specific.versions)
  return _internal_mutable_versions();
}

// -------------------------------------------------------------------

// ModelVersionPolicy

// .inference.ModelVersionPolicy.Latest latest = 1;
inline bool ModelVersionPolicy::_internal_has_latest() const {
  return policy_choice_case() == kLatest;
}
inline bool ModelVersionPolicy::has_latest() const {
  return _internal_has_latest();
}
inline void ModelVersionPolicy::set_has_latest() {
  _impl_._oneof_case_[0] = kLatest;
}
inline void ModelVersionPolicy::clear_latest() {
  if (_internal_has_latest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.policy_choice_.latest_;
    }
    clear_has_policy_choice();
  }
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::release_latest() {
  // @@protoc_insertion_point(field_release:inference.ModelVersionPolicy.latest)
  if (_internal_has_latest()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_Latest* temp = _impl_.policy_choice_.latest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.policy_choice_.latest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelVersionPolicy_Latest& ModelVersionPolicy::_internal_latest() const {
  return _internal_has_latest()
      ? *_impl_.policy_choice_.latest_
      : reinterpret_cast< ::inference::ModelVersionPolicy_Latest&>(::inference::_ModelVersionPolicy_Latest_default_instance_);
}
inline const ::inference::ModelVersionPolicy_Latest& ModelVersionPolicy::latest() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.latest)
  return _internal_latest();
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::unsafe_arena_release_latest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelVersionPolicy.latest)
  if (_internal_has_latest()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_Latest* temp = _impl_.policy_choice_.latest_;
    _impl_.policy_choice_.latest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelVersionPolicy::unsafe_arena_set_allocated_latest(::inference::ModelVersionPolicy_Latest* latest) {
  clear_policy_choice();
  if (latest) {
    set_has_latest();
    _impl_.policy_choice_.latest_ = latest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelVersionPolicy.latest)
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::_internal_mutable_latest() {
  if (!_internal_has_latest()) {
    clear_policy_choice();
    set_has_latest();
    _impl_.policy_choice_.latest_ = CreateMaybeMessage< ::inference::ModelVersionPolicy_Latest >(GetArenaForAllocation());
  }
  return _impl_.policy_choice_.latest_;
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::mutable_latest() {
  ::inference::ModelVersionPolicy_Latest* _msg = _internal_mutable_latest();
  // @@protoc_insertion_point(field_mutable:inference.ModelVersionPolicy.latest)
  return _msg;
}

// .inference.ModelVersionPolicy.All all = 2;
inline bool ModelVersionPolicy::_internal_has_all() const {
  return policy_choice_case() == kAll;
}
inline bool ModelVersionPolicy::has_all() const {
  return _internal_has_all();
}
inline void ModelVersionPolicy::set_has_all() {
  _impl_._oneof_case_[0] = kAll;
}
inline void ModelVersionPolicy::clear_all() {
  if (_internal_has_all()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.policy_choice_.all_;
    }
    clear_has_policy_choice();
  }
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::release_all() {
  // @@protoc_insertion_point(field_release:inference.ModelVersionPolicy.all)
  if (_internal_has_all()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_All* temp = _impl_.policy_choice_.all_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.policy_choice_.all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelVersionPolicy_All& ModelVersionPolicy::_internal_all() const {
  return _internal_has_all()
      ? *_impl_.policy_choice_.all_
      : reinterpret_cast< ::inference::ModelVersionPolicy_All&>(::inference::_ModelVersionPolicy_All_default_instance_);
}
inline const ::inference::ModelVersionPolicy_All& ModelVersionPolicy::all() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.all)
  return _internal_all();
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::unsafe_arena_release_all() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelVersionPolicy.all)
  if (_internal_has_all()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_All* temp = _impl_.policy_choice_.all_;
    _impl_.policy_choice_.all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelVersionPolicy::unsafe_arena_set_allocated_all(::inference::ModelVersionPolicy_All* all) {
  clear_policy_choice();
  if (all) {
    set_has_all();
    _impl_.policy_choice_.all_ = all;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelVersionPolicy.all)
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::_internal_mutable_all() {
  if (!_internal_has_all()) {
    clear_policy_choice();
    set_has_all();
    _impl_.policy_choice_.all_ = CreateMaybeMessage< ::inference::ModelVersionPolicy_All >(GetArenaForAllocation());
  }
  return _impl_.policy_choice_.all_;
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::mutable_all() {
  ::inference::ModelVersionPolicy_All* _msg = _internal_mutable_all();
  // @@protoc_insertion_point(field_mutable:inference.ModelVersionPolicy.all)
  return _msg;
}

// .inference.ModelVersionPolicy.Specific specific = 3;
inline bool ModelVersionPolicy::_internal_has_specific() const {
  return policy_choice_case() == kSpecific;
}
inline bool ModelVersionPolicy::has_specific() const {
  return _internal_has_specific();
}
inline void ModelVersionPolicy::set_has_specific() {
  _impl_._oneof_case_[0] = kSpecific;
}
inline void ModelVersionPolicy::clear_specific() {
  if (_internal_has_specific()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.policy_choice_.specific_;
    }
    clear_has_policy_choice();
  }
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::release_specific() {
  // @@protoc_insertion_point(field_release:inference.ModelVersionPolicy.specific)
  if (_internal_has_specific()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_Specific* temp = _impl_.policy_choice_.specific_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.policy_choice_.specific_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelVersionPolicy_Specific& ModelVersionPolicy::_internal_specific() const {
  return _internal_has_specific()
      ? *_impl_.policy_choice_.specific_
      : reinterpret_cast< ::inference::ModelVersionPolicy_Specific&>(::inference::_ModelVersionPolicy_Specific_default_instance_);
}
inline const ::inference::ModelVersionPolicy_Specific& ModelVersionPolicy::specific() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.specific)
  return _internal_specific();
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::unsafe_arena_release_specific() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelVersionPolicy.specific)
  if (_internal_has_specific()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_Specific* temp = _impl_.policy_choice_.specific_;
    _impl_.policy_choice_.specific_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelVersionPolicy::unsafe_arena_set_allocated_specific(::inference::ModelVersionPolicy_Specific* specific) {
  clear_policy_choice();
  if (specific) {
    set_has_specific();
    _impl_.policy_choice_.specific_ = specific;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelVersionPolicy.specific)
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::_internal_mutable_specific() {
  if (!_internal_has_specific()) {
    clear_policy_choice();
    set_has_specific();
    _impl_.policy_choice_.specific_ = CreateMaybeMessage< ::inference::ModelVersionPolicy_Specific >(GetArenaForAllocation());
  }
  return _impl_.policy_choice_.specific_;
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::mutable_specific() {
  ::inference::ModelVersionPolicy_Specific* _msg = _internal_mutable_specific();
  // @@protoc_insertion_point(field_mutable:inference.ModelVersionPolicy.specific)
  return _msg;
}

inline bool ModelVersionPolicy::has_policy_choice() const {
  return policy_choice_case() != POLICY_CHOICE_NOT_SET;
}
inline void ModelVersionPolicy::clear_has_policy_choice() {
  _impl_._oneof_case_[0] = POLICY_CHOICE_NOT_SET;
}
inline ModelVersionPolicy::PolicyChoiceCase ModelVersionPolicy::policy_choice_case() const {
  return ModelVersionPolicy::PolicyChoiceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ModelOptimizationPolicy_Graph

// int32 level = 1;
inline void ModelOptimizationPolicy_Graph::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t ModelOptimizationPolicy_Graph::_internal_level() const {
  return _impl_.level_;
}
inline int32_t ModelOptimizationPolicy_Graph::level() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Graph.level)
  return _internal_level();
}
inline void ModelOptimizationPolicy_Graph::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void ModelOptimizationPolicy_Graph::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Graph.level)
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda_GraphSpec_Shape

// repeated int64 dim = 1;
inline int ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_dim_size() const {
  return _impl_.dim_.size();
}
inline int ModelOptimizationPolicy_Cuda_GraphSpec_Shape::dim_size() const {
  return _internal_dim_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::clear_dim() {
  _impl_.dim_.Clear();
}
inline int64_t ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_dim(int index) const {
  return _impl_.dim_.Get(index);
}
inline int64_t ModelOptimizationPolicy_Cuda_GraphSpec_Shape::dim(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
  return _internal_dim(index);
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::set_dim(int index, int64_t value) {
  _impl_.dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_add_dim(int64_t value) {
  _impl_.dim_.Add(value);
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::add_dim(int64_t value) {
  _internal_add_dim(value);
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_dim() const {
  return _impl_.dim_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::dim() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
  return _internal_dim();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_mutable_dim() {
  return &_impl_.dim_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
  return _internal_mutable_dim();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound

// int32 batch_size = 1;
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.batch_size)
  return _internal_batch_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.batch_size)
}

// map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
inline int ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_input_size() const {
  return _impl_.input_.size();
}
inline int ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::input_size() const {
  return _internal_input_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::clear_input() {
  _impl_.input_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_input() const {
  return _impl_.input_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::input() const {
  // @@protoc_insertion_point(field_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.input)
  return _internal_input();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_mutable_input() {
  return _impl_.input_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::mutable_input() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.input)
  return _internal_mutable_input();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda_GraphSpec

// int32 batch_size = 1;
inline void ModelOptimizationPolicy_Cuda_GraphSpec::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t ModelOptimizationPolicy_Cuda_GraphSpec::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t ModelOptimizationPolicy_Cuda_GraphSpec::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.batch_size)
  return _internal_batch_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.GraphSpec.batch_size)
}

// map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
inline int ModelOptimizationPolicy_Cuda_GraphSpec::_internal_input_size() const {
  return _impl_.input_.size();
}
inline int ModelOptimizationPolicy_Cuda_GraphSpec::input_size() const {
  return _internal_input_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::clear_input() {
  _impl_.input_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec::_internal_input() const {
  return _impl_.input_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec::input() const {
  // @@protoc_insertion_point(field_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.input)
  return _internal_input();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec::_internal_mutable_input() {
  return _impl_.input_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec::mutable_input() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.input)
  return _internal_mutable_input();
}

// .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
inline bool ModelOptimizationPolicy_Cuda_GraphSpec::_internal_has_graph_lower_bound() const {
  return this != internal_default_instance() && _impl_.graph_lower_bound_ != nullptr;
}
inline bool ModelOptimizationPolicy_Cuda_GraphSpec::has_graph_lower_bound() const {
  return _internal_has_graph_lower_bound();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::clear_graph_lower_bound() {
  if (GetArenaForAllocation() == nullptr && _impl_.graph_lower_bound_ != nullptr) {
    delete _impl_.graph_lower_bound_;
  }
  _impl_.graph_lower_bound_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& ModelOptimizationPolicy_Cuda_GraphSpec::_internal_graph_lower_bound() const {
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* p = _impl_.graph_lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&>(
      ::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& ModelOptimizationPolicy_Cuda_GraphSpec::graph_lower_bound() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
  return _internal_graph_lower_bound();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::unsafe_arena_set_allocated_graph_lower_bound(
    ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_lower_bound_);
  }
  _impl_.graph_lower_bound_ = graph_lower_bound;
  if (graph_lower_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::release_graph_lower_bound() {
  
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* temp = _impl_.graph_lower_bound_;
  _impl_.graph_lower_bound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::unsafe_arena_release_graph_lower_bound() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
  
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* temp = _impl_.graph_lower_bound_;
  _impl_.graph_lower_bound_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::_internal_mutable_graph_lower_bound() {
  
  if (_impl_.graph_lower_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(GetArenaForAllocation());
    _impl_.graph_lower_bound_ = p;
  }
  return _impl_.graph_lower_bound_;
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::mutable_graph_lower_bound() {
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* _msg = _internal_mutable_graph_lower_bound();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
  return _msg;
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::set_allocated_graph_lower_bound(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.graph_lower_bound_;
  }
  if (graph_lower_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(graph_lower_bound);
    if (message_arena != submessage_arena) {
      graph_lower_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph_lower_bound, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.graph_lower_bound_ = graph_lower_bound;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda

// bool graphs = 1;
inline void ModelOptimizationPolicy_Cuda::clear_graphs() {
  _impl_.graphs_ = false;
}
inline bool ModelOptimizationPolicy_Cuda::_internal_graphs() const {
  return _impl_.graphs_;
}
inline bool ModelOptimizationPolicy_Cuda::graphs() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.graphs)
  return _internal_graphs();
}
inline void ModelOptimizationPolicy_Cuda::_internal_set_graphs(bool value) {
  
  _impl_.graphs_ = value;
}
inline void ModelOptimizationPolicy_Cuda::set_graphs(bool value) {
  _internal_set_graphs(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.graphs)
}

// bool busy_wait_events = 2;
inline void ModelOptimizationPolicy_Cuda::clear_busy_wait_events() {
  _impl_.busy_wait_events_ = false;
}
inline bool ModelOptimizationPolicy_Cuda::_internal_busy_wait_events() const {
  return _impl_.busy_wait_events_;
}
inline bool ModelOptimizationPolicy_Cuda::busy_wait_events() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.busy_wait_events)
  return _internal_busy_wait_events();
}
inline void ModelOptimizationPolicy_Cuda::_internal_set_busy_wait_events(bool value) {
  
  _impl_.busy_wait_events_ = value;
}
inline void ModelOptimizationPolicy_Cuda::set_busy_wait_events(bool value) {
  _internal_set_busy_wait_events(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.busy_wait_events)
}

// repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
inline int ModelOptimizationPolicy_Cuda::_internal_graph_spec_size() const {
  return _impl_.graph_spec_.size();
}
inline int ModelOptimizationPolicy_Cuda::graph_spec_size() const {
  return _internal_graph_spec_size();
}
inline void ModelOptimizationPolicy_Cuda::clear_graph_spec() {
  _impl_.graph_spec_.Clear();
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* ModelOptimizationPolicy_Cuda::mutable_graph_spec(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return _impl_.graph_spec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >*
ModelOptimizationPolicy_Cuda::mutable_graph_spec() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return &_impl_.graph_spec_;
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& ModelOptimizationPolicy_Cuda::_internal_graph_spec(int index) const {
  return _impl_.graph_spec_.Get(index);
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& ModelOptimizationPolicy_Cuda::graph_spec(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return _internal_graph_spec(index);
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* ModelOptimizationPolicy_Cuda::_internal_add_graph_spec() {
  return _impl_.graph_spec_.Add();
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* ModelOptimizationPolicy_Cuda::add_graph_spec() {
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* _add = _internal_add_graph_spec();
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >&
ModelOptimizationPolicy_Cuda::graph_spec() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return _impl_.graph_spec_;
}

// bool output_copy_stream = 4;
inline void ModelOptimizationPolicy_Cuda::clear_output_copy_stream() {
  _impl_.output_copy_stream_ = false;
}
inline bool ModelOptimizationPolicy_Cuda::_internal_output_copy_stream() const {
  return _impl_.output_copy_stream_;
}
inline bool ModelOptimizationPolicy_Cuda::output_copy_stream() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.output_copy_stream)
  return _internal_output_copy_stream();
}
inline void ModelOptimizationPolicy_Cuda::_internal_set_output_copy_stream(bool value) {
  
  _impl_.output_copy_stream_ = value;
}
inline void ModelOptimizationPolicy_Cuda::set_output_copy_stream(bool value) {
  _internal_set_output_copy_stream(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.output_copy_stream)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelOptimizationPolicy_ExecutionAccelerators_Accelerator

// string name = 1;
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}
inline std::string* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
  return _s;
}
inline const std::string& ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
  return _impl_.name_.Release();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}

// map<string, string> parameters = 2;
inline int ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_ExecutionAccelerators

// repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
inline int ModelOptimizationPolicy_ExecutionAccelerators::_internal_gpu_execution_accelerator_size() const {
  return _impl_.gpu_execution_accelerator_.size();
}
inline int ModelOptimizationPolicy_ExecutionAccelerators::gpu_execution_accelerator_size() const {
  return _internal_gpu_execution_accelerator_size();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators::clear_gpu_execution_accelerator() {
  _impl_.gpu_execution_accelerator_.Clear();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::mutable_gpu_execution_accelerator(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return _impl_.gpu_execution_accelerator_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
ModelOptimizationPolicy_ExecutionAccelerators::mutable_gpu_execution_accelerator() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return &_impl_.gpu_execution_accelerator_;
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::_internal_gpu_execution_accelerator(int index) const {
  return _impl_.gpu_execution_accelerator_.Get(index);
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::gpu_execution_accelerator(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return _internal_gpu_execution_accelerator(index);
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::_internal_add_gpu_execution_accelerator() {
  return _impl_.gpu_execution_accelerator_.Add();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::add_gpu_execution_accelerator() {
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _add = _internal_add_gpu_execution_accelerator();
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
ModelOptimizationPolicy_ExecutionAccelerators::gpu_execution_accelerator() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return _impl_.gpu_execution_accelerator_;
}

// repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
inline int ModelOptimizationPolicy_ExecutionAccelerators::_internal_cpu_execution_accelerator_size() const {
  return _impl_.cpu_execution_accelerator_.size();
}
inline int ModelOptimizationPolicy_ExecutionAccelerators::cpu_execution_accelerator_size() const {
  return _internal_cpu_execution_accelerator_size();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators::clear_cpu_execution_accelerator() {
  _impl_.cpu_execution_accelerator_.Clear();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::mutable_cpu_execution_accelerator(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return _impl_.cpu_execution_accelerator_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
ModelOptimizationPolicy_ExecutionAccelerators::mutable_cpu_execution_accelerator() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return &_impl_.cpu_execution_accelerator_;
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::_internal_cpu_execution_accelerator(int index) const {
  return _impl_.cpu_execution_accelerator_.Get(index);
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::cpu_execution_accelerator(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return _internal_cpu_execution_accelerator(index);
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::_internal_add_cpu_execution_accelerator() {
  return _impl_.cpu_execution_accelerator_.Add();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::add_cpu_execution_accelerator() {
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _add = _internal_add_cpu_execution_accelerator();
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
ModelOptimizationPolicy_ExecutionAccelerators::cpu_execution_accelerator() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return _impl_.cpu_execution_accelerator_;
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_PinnedMemoryBuffer

// bool enable = 1;
inline void ModelOptimizationPolicy_PinnedMemoryBuffer::clear_enable() {
  _impl_.enable_ = false;
}
inline bool ModelOptimizationPolicy_PinnedMemoryBuffer::_internal_enable() const {
  return _impl_.enable_;
}
inline bool ModelOptimizationPolicy_PinnedMemoryBuffer::enable() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.PinnedMemoryBuffer.enable)
  return _internal_enable();
}
inline void ModelOptimizationPolicy_PinnedMemoryBuffer::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void ModelOptimizationPolicy_PinnedMemoryBuffer::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.PinnedMemoryBuffer.enable)
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy

// .inference.ModelOptimizationPolicy.Graph graph = 1;
inline bool ModelOptimizationPolicy::_internal_has_graph() const {
  return this != internal_default_instance() && _impl_.graph_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_graph() const {
  return _internal_has_graph();
}
inline void ModelOptimizationPolicy::clear_graph() {
  if (GetArenaForAllocation() == nullptr && _impl_.graph_ != nullptr) {
    delete _impl_.graph_;
  }
  _impl_.graph_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_Graph& ModelOptimizationPolicy::_internal_graph() const {
  const ::inference::ModelOptimizationPolicy_Graph* p = _impl_.graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_Graph&>(
      ::inference::_ModelOptimizationPolicy_Graph_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_Graph& ModelOptimizationPolicy::graph() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.graph)
  return _internal_graph();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_graph(
    ::inference::ModelOptimizationPolicy_Graph* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  _impl_.graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.graph)
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::release_graph() {
  
  ::inference::ModelOptimizationPolicy_Graph* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.graph)
  
  ::inference::ModelOptimizationPolicy_Graph* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::_internal_mutable_graph() {
  
  if (_impl_.graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_Graph>(GetArenaForAllocation());
    _impl_.graph_ = p;
  }
  return _impl_.graph_;
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::mutable_graph() {
  ::inference::ModelOptimizationPolicy_Graph* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.graph)
  return _msg;
}
inline void ModelOptimizationPolicy::set_allocated_graph(::inference::ModelOptimizationPolicy_Graph* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.graph_;
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(graph);
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.graph)
}

// .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
inline void ModelOptimizationPolicy::clear_priority() {
  _impl_.priority_ = 0;
}
inline ::inference::ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::_internal_priority() const {
  return static_cast< ::inference::ModelOptimizationPolicy_ModelPriority >(_impl_.priority_);
}
inline ::inference::ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::priority() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.priority)
  return _internal_priority();
}
inline void ModelOptimizationPolicy::_internal_set_priority(::inference::ModelOptimizationPolicy_ModelPriority value) {
  
  _impl_.priority_ = value;
}
inline void ModelOptimizationPolicy::set_priority(::inference::ModelOptimizationPolicy_ModelPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.priority)
}

// .inference.ModelOptimizationPolicy.Cuda cuda = 3;
inline bool ModelOptimizationPolicy::_internal_has_cuda() const {
  return this != internal_default_instance() && _impl_.cuda_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_cuda() const {
  return _internal_has_cuda();
}
inline void ModelOptimizationPolicy::clear_cuda() {
  if (GetArenaForAllocation() == nullptr && _impl_.cuda_ != nullptr) {
    delete _impl_.cuda_;
  }
  _impl_.cuda_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_Cuda& ModelOptimizationPolicy::_internal_cuda() const {
  const ::inference::ModelOptimizationPolicy_Cuda* p = _impl_.cuda_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_Cuda&>(
      ::inference::_ModelOptimizationPolicy_Cuda_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_Cuda& ModelOptimizationPolicy::cuda() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.cuda)
  return _internal_cuda();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_cuda(
    ::inference::ModelOptimizationPolicy_Cuda* cuda) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cuda_);
  }
  _impl_.cuda_ = cuda;
  if (cuda) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.cuda)
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::release_cuda() {
  
  ::inference::ModelOptimizationPolicy_Cuda* temp = _impl_.cuda_;
  _impl_.cuda_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::unsafe_arena_release_cuda() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.cuda)
  
  ::inference::ModelOptimizationPolicy_Cuda* temp = _impl_.cuda_;
  _impl_.cuda_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::_internal_mutable_cuda() {
  
  if (_impl_.cuda_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda>(GetArenaForAllocation());
    _impl_.cuda_ = p;
  }
  return _impl_.cuda_;
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::mutable_cuda() {
  ::inference::ModelOptimizationPolicy_Cuda* _msg = _internal_mutable_cuda();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.cuda)
  return _msg;
}
inline void ModelOptimizationPolicy::set_allocated_cuda(::inference::ModelOptimizationPolicy_Cuda* cuda) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cuda_;
  }
  if (cuda) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cuda);
    if (message_arena != submessage_arena) {
      cuda = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cuda, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cuda_ = cuda;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.cuda)
}

// .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
inline bool ModelOptimizationPolicy::_internal_has_execution_accelerators() const {
  return this != internal_default_instance() && _impl_.execution_accelerators_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_execution_accelerators() const {
  return _internal_has_execution_accelerators();
}
inline void ModelOptimizationPolicy::clear_execution_accelerators() {
  if (GetArenaForAllocation() == nullptr && _impl_.execution_accelerators_ != nullptr) {
    delete _impl_.execution_accelerators_;
  }
  _impl_.execution_accelerators_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& ModelOptimizationPolicy::_internal_execution_accelerators() const {
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators* p = _impl_.execution_accelerators_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_ExecutionAccelerators&>(
      ::inference::_ModelOptimizationPolicy_ExecutionAccelerators_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& ModelOptimizationPolicy::execution_accelerators() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.execution_accelerators)
  return _internal_execution_accelerators();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_execution_accelerators(
    ::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.execution_accelerators_);
  }
  _impl_.execution_accelerators_ = execution_accelerators;
  if (execution_accelerators) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.execution_accelerators)
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::release_execution_accelerators() {
  
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* temp = _impl_.execution_accelerators_;
  _impl_.execution_accelerators_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::unsafe_arena_release_execution_accelerators() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.execution_accelerators)
  
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* temp = _impl_.execution_accelerators_;
  _impl_.execution_accelerators_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::_internal_mutable_execution_accelerators() {
  
  if (_impl_.execution_accelerators_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators>(GetArenaForAllocation());
    _impl_.execution_accelerators_ = p;
  }
  return _impl_.execution_accelerators_;
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::mutable_execution_accelerators() {
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* _msg = _internal_mutable_execution_accelerators();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.execution_accelerators)
  return _msg;
}
inline void ModelOptimizationPolicy::set_allocated_execution_accelerators(::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.execution_accelerators_;
  }
  if (execution_accelerators) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(execution_accelerators);
    if (message_arena != submessage_arena) {
      execution_accelerators = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_accelerators, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.execution_accelerators_ = execution_accelerators;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.execution_accelerators)
}

// .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
inline bool ModelOptimizationPolicy::_internal_has_input_pinned_memory() const {
  return this != internal_default_instance() && _impl_.input_pinned_memory_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_input_pinned_memory() const {
  return _internal_has_input_pinned_memory();
}
inline void ModelOptimizationPolicy::clear_input_pinned_memory() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_pinned_memory_ != nullptr) {
    delete _impl_.input_pinned_memory_;
  }
  _impl_.input_pinned_memory_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::_internal_input_pinned_memory() const {
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* p = _impl_.input_pinned_memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&>(
      ::inference::_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::input_pinned_memory() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.input_pinned_memory)
  return _internal_input_pinned_memory();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_input_pinned_memory(
    ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_pinned_memory_);
  }
  _impl_.input_pinned_memory_ = input_pinned_memory;
  if (input_pinned_memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.input_pinned_memory)
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::release_input_pinned_memory() {
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = _impl_.input_pinned_memory_;
  _impl_.input_pinned_memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::unsafe_arena_release_input_pinned_memory() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.input_pinned_memory)
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = _impl_.input_pinned_memory_;
  _impl_.input_pinned_memory_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::_internal_mutable_input_pinned_memory() {
  
  if (_impl_.input_pinned_memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_PinnedMemoryBuffer>(GetArenaForAllocation());
    _impl_.input_pinned_memory_ = p;
  }
  return _impl_.input_pinned_memory_;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::mutable_input_pinned_memory() {
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* _msg = _internal_mutable_input_pinned_memory();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.input_pinned_memory)
  return _msg;
}
inline void ModelOptimizationPolicy::set_allocated_input_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_pinned_memory_;
  }
  if (input_pinned_memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_pinned_memory);
    if (message_arena != submessage_arena) {
      input_pinned_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_pinned_memory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_pinned_memory_ = input_pinned_memory;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.input_pinned_memory)
}

// .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
inline bool ModelOptimizationPolicy::_internal_has_output_pinned_memory() const {
  return this != internal_default_instance() && _impl_.output_pinned_memory_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_output_pinned_memory() const {
  return _internal_has_output_pinned_memory();
}
inline void ModelOptimizationPolicy::clear_output_pinned_memory() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_pinned_memory_ != nullptr) {
    delete _impl_.output_pinned_memory_;
  }
  _impl_.output_pinned_memory_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::_internal_output_pinned_memory() const {
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* p = _impl_.output_pinned_memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&>(
      ::inference::_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::output_pinned_memory() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.output_pinned_memory)
  return _internal_output_pinned_memory();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_output_pinned_memory(
    ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_pinned_memory_);
  }
  _impl_.output_pinned_memory_ = output_pinned_memory;
  if (output_pinned_memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.output_pinned_memory)
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::release_output_pinned_memory() {
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = _impl_.output_pinned_memory_;
  _impl_.output_pinned_memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::unsafe_arena_release_output_pinned_memory() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.output_pinned_memory)
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = _impl_.output_pinned_memory_;
  _impl_.output_pinned_memory_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::_internal_mutable_output_pinned_memory() {
  
  if (_impl_.output_pinned_memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_PinnedMemoryBuffer>(GetArenaForAllocation());
    _impl_.output_pinned_memory_ = p;
  }
  return _impl_.output_pinned_memory_;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::mutable_output_pinned_memory() {
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* _msg = _internal_mutable_output_pinned_memory();
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.output_pinned_memory)
  return _msg;
}
inline void ModelOptimizationPolicy::set_allocated_output_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_pinned_memory_;
  }
  if (output_pinned_memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_pinned_memory);
    if (message_arena != submessage_arena) {
      output_pinned_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_pinned_memory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_pinned_memory_ = output_pinned_memory;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.output_pinned_memory)
}

// uint32 gather_kernel_buffer_threshold = 7;
inline void ModelOptimizationPolicy::clear_gather_kernel_buffer_threshold() {
  _impl_.gather_kernel_buffer_threshold_ = 0u;
}
inline uint32_t ModelOptimizationPolicy::_internal_gather_kernel_buffer_threshold() const {
  return _impl_.gather_kernel_buffer_threshold_;
}
inline uint32_t ModelOptimizationPolicy::gather_kernel_buffer_threshold() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.gather_kernel_buffer_threshold)
  return _internal_gather_kernel_buffer_threshold();
}
inline void ModelOptimizationPolicy::_internal_set_gather_kernel_buffer_threshold(uint32_t value) {
  
  _impl_.gather_kernel_buffer_threshold_ = value;
}
inline void ModelOptimizationPolicy::set_gather_kernel_buffer_threshold(uint32_t value) {
  _internal_set_gather_kernel_buffer_threshold(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.gather_kernel_buffer_threshold)
}

// bool eager_batching = 8;
inline void ModelOptimizationPolicy::clear_eager_batching() {
  _impl_.eager_batching_ = false;
}
inline bool ModelOptimizationPolicy::_internal_eager_batching() const {
  return _impl_.eager_batching_;
}
inline bool ModelOptimizationPolicy::eager_batching() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.eager_batching)
  return _internal_eager_batching();
}
inline void ModelOptimizationPolicy::_internal_set_eager_batching(bool value) {
  
  _impl_.eager_batching_ = value;
}
inline void ModelOptimizationPolicy::set_eager_batching(bool value) {
  _internal_set_eager_batching(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.eager_batching)
}

// -------------------------------------------------------------------

// ModelQueuePolicy

// .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
inline void ModelQueuePolicy::clear_timeout_action() {
  _impl_.timeout_action_ = 0;
}
inline ::inference::ModelQueuePolicy_TimeoutAction ModelQueuePolicy::_internal_timeout_action() const {
  return static_cast< ::inference::ModelQueuePolicy_TimeoutAction >(_impl_.timeout_action_);
}
inline ::inference::ModelQueuePolicy_TimeoutAction ModelQueuePolicy::timeout_action() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.timeout_action)
  return _internal_timeout_action();
}
inline void ModelQueuePolicy::_internal_set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value) {
  
  _impl_.timeout_action_ = value;
}
inline void ModelQueuePolicy::set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value) {
  _internal_set_timeout_action(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.timeout_action)
}

// uint64 default_timeout_microseconds = 2;
inline void ModelQueuePolicy::clear_default_timeout_microseconds() {
  _impl_.default_timeout_microseconds_ = uint64_t{0u};
}
inline uint64_t ModelQueuePolicy::_internal_default_timeout_microseconds() const {
  return _impl_.default_timeout_microseconds_;
}
inline uint64_t ModelQueuePolicy::default_timeout_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.default_timeout_microseconds)
  return _internal_default_timeout_microseconds();
}
inline void ModelQueuePolicy::_internal_set_default_timeout_microseconds(uint64_t value) {
  
  _impl_.default_timeout_microseconds_ = value;
}
inline void ModelQueuePolicy::set_default_timeout_microseconds(uint64_t value) {
  _internal_set_default_timeout_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.default_timeout_microseconds)
}

// bool allow_timeout_override = 3;
inline void ModelQueuePolicy::clear_allow_timeout_override() {
  _impl_.allow_timeout_override_ = false;
}
inline bool ModelQueuePolicy::_internal_allow_timeout_override() const {
  return _impl_.allow_timeout_override_;
}
inline bool ModelQueuePolicy::allow_timeout_override() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.allow_timeout_override)
  return _internal_allow_timeout_override();
}
inline void ModelQueuePolicy::_internal_set_allow_timeout_override(bool value) {
  
  _impl_.allow_timeout_override_ = value;
}
inline void ModelQueuePolicy::set_allow_timeout_override(bool value) {
  _internal_set_allow_timeout_override(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.allow_timeout_override)
}

// uint32 max_queue_size = 4;
inline void ModelQueuePolicy::clear_max_queue_size() {
  _impl_.max_queue_size_ = 0u;
}
inline uint32_t ModelQueuePolicy::_internal_max_queue_size() const {
  return _impl_.max_queue_size_;
}
inline uint32_t ModelQueuePolicy::max_queue_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.max_queue_size)
  return _internal_max_queue_size();
}
inline void ModelQueuePolicy::_internal_set_max_queue_size(uint32_t value) {
  
  _impl_.max_queue_size_ = value;
}
inline void ModelQueuePolicy::set_max_queue_size(uint32_t value) {
  _internal_set_max_queue_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.max_queue_size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelDynamicBatching

// repeated int32 preferred_batch_size = 1;
inline int ModelDynamicBatching::_internal_preferred_batch_size_size() const {
  return _impl_.preferred_batch_size_.size();
}
inline int ModelDynamicBatching::preferred_batch_size_size() const {
  return _internal_preferred_batch_size_size();
}
inline void ModelDynamicBatching::clear_preferred_batch_size() {
  _impl_.preferred_batch_size_.Clear();
}
inline int32_t ModelDynamicBatching::_internal_preferred_batch_size(int index) const {
  return _impl_.preferred_batch_size_.Get(index);
}
inline int32_t ModelDynamicBatching::preferred_batch_size(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.preferred_batch_size)
  return _internal_preferred_batch_size(index);
}
inline void ModelDynamicBatching::set_preferred_batch_size(int index, int32_t value) {
  _impl_.preferred_batch_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.preferred_batch_size)
}
inline void ModelDynamicBatching::_internal_add_preferred_batch_size(int32_t value) {
  _impl_.preferred_batch_size_.Add(value);
}
inline void ModelDynamicBatching::add_preferred_batch_size(int32_t value) {
  _internal_add_preferred_batch_size(value);
  // @@protoc_insertion_point(field_add:inference.ModelDynamicBatching.preferred_batch_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelDynamicBatching::_internal_preferred_batch_size() const {
  return _impl_.preferred_batch_size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelDynamicBatching::preferred_batch_size() const {
  // @@protoc_insertion_point(field_list:inference.ModelDynamicBatching.preferred_batch_size)
  return _internal_preferred_batch_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelDynamicBatching::_internal_mutable_preferred_batch_size() {
  return &_impl_.preferred_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelDynamicBatching::mutable_preferred_batch_size() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelDynamicBatching.preferred_batch_size)
  return _internal_mutable_preferred_batch_size();
}

// uint64 max_queue_delay_microseconds = 2;
inline void ModelDynamicBatching::clear_max_queue_delay_microseconds() {
  _impl_.max_queue_delay_microseconds_ = uint64_t{0u};
}
inline uint64_t ModelDynamicBatching::_internal_max_queue_delay_microseconds() const {
  return _impl_.max_queue_delay_microseconds_;
}
inline uint64_t ModelDynamicBatching::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.max_queue_delay_microseconds)
  return _internal_max_queue_delay_microseconds();
}
inline void ModelDynamicBatching::_internal_set_max_queue_delay_microseconds(uint64_t value) {
  
  _impl_.max_queue_delay_microseconds_ = value;
}
inline void ModelDynamicBatching::set_max_queue_delay_microseconds(uint64_t value) {
  _internal_set_max_queue_delay_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.max_queue_delay_microseconds)
}

// bool preserve_ordering = 3;
inline void ModelDynamicBatching::clear_preserve_ordering() {
  _impl_.preserve_ordering_ = false;
}
inline bool ModelDynamicBatching::_internal_preserve_ordering() const {
  return _impl_.preserve_ordering_;
}
inline bool ModelDynamicBatching::preserve_ordering() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.preserve_ordering)
  return _internal_preserve_ordering();
}
inline void ModelDynamicBatching::_internal_set_preserve_ordering(bool value) {
  
  _impl_.preserve_ordering_ = value;
}
inline void ModelDynamicBatching::set_preserve_ordering(bool value) {
  _internal_set_preserve_ordering(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.preserve_ordering)
}

// uint64 priority_levels = 4;
inline void ModelDynamicBatching::clear_priority_levels() {
  _impl_.priority_levels_ = uint64_t{0u};
}
inline uint64_t ModelDynamicBatching::_internal_priority_levels() const {
  return _impl_.priority_levels_;
}
inline uint64_t ModelDynamicBatching::priority_levels() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.priority_levels)
  return _internal_priority_levels();
}
inline void ModelDynamicBatching::_internal_set_priority_levels(uint64_t value) {
  
  _impl_.priority_levels_ = value;
}
inline void ModelDynamicBatching::set_priority_levels(uint64_t value) {
  _internal_set_priority_levels(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.priority_levels)
}

// uint64 default_priority_level = 5;
inline void ModelDynamicBatching::clear_default_priority_level() {
  _impl_.default_priority_level_ = uint64_t{0u};
}
inline uint64_t ModelDynamicBatching::_internal_default_priority_level() const {
  return _impl_.default_priority_level_;
}
inline uint64_t ModelDynamicBatching::default_priority_level() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.default_priority_level)
  return _internal_default_priority_level();
}
inline void ModelDynamicBatching::_internal_set_default_priority_level(uint64_t value) {
  
  _impl_.default_priority_level_ = value;
}
inline void ModelDynamicBatching::set_default_priority_level(uint64_t value) {
  _internal_set_default_priority_level(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.default_priority_level)
}

// .inference.ModelQueuePolicy default_queue_policy = 6;
inline bool ModelDynamicBatching::_internal_has_default_queue_policy() const {
  return this != internal_default_instance() && _impl_.default_queue_policy_ != nullptr;
}
inline bool ModelDynamicBatching::has_default_queue_policy() const {
  return _internal_has_default_queue_policy();
}
inline void ModelDynamicBatching::clear_default_queue_policy() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_queue_policy_ != nullptr) {
    delete _impl_.default_queue_policy_;
  }
  _impl_.default_queue_policy_ = nullptr;
}
inline const ::inference::ModelQueuePolicy& ModelDynamicBatching::_internal_default_queue_policy() const {
  const ::inference::ModelQueuePolicy* p = _impl_.default_queue_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelQueuePolicy&>(
      ::inference::_ModelQueuePolicy_default_instance_);
}
inline const ::inference::ModelQueuePolicy& ModelDynamicBatching::default_queue_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.default_queue_policy)
  return _internal_default_queue_policy();
}
inline void ModelDynamicBatching::unsafe_arena_set_allocated_default_queue_policy(
    ::inference::ModelQueuePolicy* default_queue_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_queue_policy_);
  }
  _impl_.default_queue_policy_ = default_queue_policy;
  if (default_queue_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelDynamicBatching.default_queue_policy)
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::release_default_queue_policy() {
  
  ::inference::ModelQueuePolicy* temp = _impl_.default_queue_policy_;
  _impl_.default_queue_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::unsafe_arena_release_default_queue_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelDynamicBatching.default_queue_policy)
  
  ::inference::ModelQueuePolicy* temp = _impl_.default_queue_policy_;
  _impl_.default_queue_policy_ = nullptr;
  return temp;
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::_internal_mutable_default_queue_policy() {
  
  if (_impl_.default_queue_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelQueuePolicy>(GetArenaForAllocation());
    _impl_.default_queue_policy_ = p;
  }
  return _impl_.default_queue_policy_;
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::mutable_default_queue_policy() {
  ::inference::ModelQueuePolicy* _msg = _internal_mutable_default_queue_policy();
  // @@protoc_insertion_point(field_mutable:inference.ModelDynamicBatching.default_queue_policy)
  return _msg;
}
inline void ModelDynamicBatching::set_allocated_default_queue_policy(::inference::ModelQueuePolicy* default_queue_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_queue_policy_;
  }
  if (default_queue_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_queue_policy);
    if (message_arena != submessage_arena) {
      default_queue_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_queue_policy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_queue_policy_ = default_queue_policy;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelDynamicBatching.default_queue_policy)
}

// map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
inline int ModelDynamicBatching::_internal_priority_queue_policy_size() const {
  return _impl_.priority_queue_policy_.size();
}
inline int ModelDynamicBatching::priority_queue_policy_size() const {
  return _internal_priority_queue_policy_size();
}
inline void ModelDynamicBatching::clear_priority_queue_policy() {
  _impl_.priority_queue_policy_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >&
ModelDynamicBatching::_internal_priority_queue_policy() const {
  return _impl_.priority_queue_policy_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >&
ModelDynamicBatching::priority_queue_policy() const {
  // @@protoc_insertion_point(field_map:inference.ModelDynamicBatching.priority_queue_policy)
  return _internal_priority_queue_policy();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >*
ModelDynamicBatching::_internal_mutable_priority_queue_policy() {
  return _impl_.priority_queue_policy_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >*
ModelDynamicBatching::mutable_priority_queue_policy() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelDynamicBatching.priority_queue_policy)
  return _internal_mutable_priority_queue_policy();
}

// -------------------------------------------------------------------

// ModelSequenceBatching_Control

// .inference.ModelSequenceBatching.Control.Kind kind = 1;
inline void ModelSequenceBatching_Control::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::inference::ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::_internal_kind() const {
  return static_cast< ::inference::ModelSequenceBatching_Control_Kind >(_impl_.kind_);
}
inline ::inference::ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::kind() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.kind)
  return _internal_kind();
}
inline void ModelSequenceBatching_Control::_internal_set_kind(::inference::ModelSequenceBatching_Control_Kind value) {
  
  _impl_.kind_ = value;
}
inline void ModelSequenceBatching_Control::set_kind(::inference::ModelSequenceBatching_Control_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.kind)
}

// repeated int32 int32_false_true = 2;
inline int ModelSequenceBatching_Control::_internal_int32_false_true_size() const {
  return _impl_.int32_false_true_.size();
}
inline int ModelSequenceBatching_Control::int32_false_true_size() const {
  return _internal_int32_false_true_size();
}
inline void ModelSequenceBatching_Control::clear_int32_false_true() {
  _impl_.int32_false_true_.Clear();
}
inline int32_t ModelSequenceBatching_Control::_internal_int32_false_true(int index) const {
  return _impl_.int32_false_true_.Get(index);
}
inline int32_t ModelSequenceBatching_Control::int32_false_true(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.int32_false_true)
  return _internal_int32_false_true(index);
}
inline void ModelSequenceBatching_Control::set_int32_false_true(int index, int32_t value) {
  _impl_.int32_false_true_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.int32_false_true)
}
inline void ModelSequenceBatching_Control::_internal_add_int32_false_true(int32_t value) {
  _impl_.int32_false_true_.Add(value);
}
inline void ModelSequenceBatching_Control::add_int32_false_true(int32_t value) {
  _internal_add_int32_false_true(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.Control.int32_false_true)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelSequenceBatching_Control::_internal_int32_false_true() const {
  return _impl_.int32_false_true_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelSequenceBatching_Control::int32_false_true() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.Control.int32_false_true)
  return _internal_int32_false_true();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelSequenceBatching_Control::_internal_mutable_int32_false_true() {
  return &_impl_.int32_false_true_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelSequenceBatching_Control::mutable_int32_false_true() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.Control.int32_false_true)
  return _internal_mutable_int32_false_true();
}

// repeated float fp32_false_true = 3;
inline int ModelSequenceBatching_Control::_internal_fp32_false_true_size() const {
  return _impl_.fp32_false_true_.size();
}
inline int ModelSequenceBatching_Control::fp32_false_true_size() const {
  return _internal_fp32_false_true_size();
}
inline void ModelSequenceBatching_Control::clear_fp32_false_true() {
  _impl_.fp32_false_true_.Clear();
}
inline float ModelSequenceBatching_Control::_internal_fp32_false_true(int index) const {
  return _impl_.fp32_false_true_.Get(index);
}
inline float ModelSequenceBatching_Control::fp32_false_true(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.fp32_false_true)
  return _internal_fp32_false_true(index);
}
inline void ModelSequenceBatching_Control::set_fp32_false_true(int index, float value) {
  _impl_.fp32_false_true_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.fp32_false_true)
}
inline void ModelSequenceBatching_Control::_internal_add_fp32_false_true(float value) {
  _impl_.fp32_false_true_.Add(value);
}
inline void ModelSequenceBatching_Control::add_fp32_false_true(float value) {
  _internal_add_fp32_false_true(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.Control.fp32_false_true)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ModelSequenceBatching_Control::_internal_fp32_false_true() const {
  return _impl_.fp32_false_true_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ModelSequenceBatching_Control::fp32_false_true() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.Control.fp32_false_true)
  return _internal_fp32_false_true();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ModelSequenceBatching_Control::_internal_mutable_fp32_false_true() {
  return &_impl_.fp32_false_true_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ModelSequenceBatching_Control::mutable_fp32_false_true() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.Control.fp32_false_true)
  return _internal_mutable_fp32_false_true();
}

// repeated bool bool_false_true = 5;
inline int ModelSequenceBatching_Control::_internal_bool_false_true_size() const {
  return _impl_.bool_false_true_.size();
}
inline int ModelSequenceBatching_Control::bool_false_true_size() const {
  return _internal_bool_false_true_size();
}
inline void ModelSequenceBatching_Control::clear_bool_false_true() {
  _impl_.bool_false_true_.Clear();
}
inline bool ModelSequenceBatching_Control::_internal_bool_false_true(int index) const {
  return _impl_.bool_false_true_.Get(index);
}
inline bool ModelSequenceBatching_Control::bool_false_true(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.bool_false_true)
  return _internal_bool_false_true(index);
}
inline void ModelSequenceBatching_Control::set_bool_false_true(int index, bool value) {
  _impl_.bool_false_true_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.bool_false_true)
}
inline void ModelSequenceBatching_Control::_internal_add_bool_false_true(bool value) {
  _impl_.bool_false_true_.Add(value);
}
inline void ModelSequenceBatching_Control::add_bool_false_true(bool value) {
  _internal_add_bool_false_true(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.Control.bool_false_true)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ModelSequenceBatching_Control::_internal_bool_false_true() const {
  return _impl_.bool_false_true_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ModelSequenceBatching_Control::bool_false_true() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.Control.bool_false_true)
  return _internal_bool_false_true();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ModelSequenceBatching_Control::_internal_mutable_bool_false_true() {
  return &_impl_.bool_false_true_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ModelSequenceBatching_Control::mutable_bool_false_true() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.Control.bool_false_true)
  return _internal_mutable_bool_false_true();
}

// .inference.DataType data_type = 4;
inline void ModelSequenceBatching_Control::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType ModelSequenceBatching_Control::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType ModelSequenceBatching_Control::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.data_type)
  return _internal_data_type();
}
inline void ModelSequenceBatching_Control::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void ModelSequenceBatching_Control::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.data_type)
}

// -------------------------------------------------------------------

// ModelSequenceBatching_ControlInput

// string name = 1;
inline void ModelSequenceBatching_ControlInput::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelSequenceBatching_ControlInput::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.ControlInput.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelSequenceBatching_ControlInput::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.ControlInput.name)
}
inline std::string* ModelSequenceBatching_ControlInput::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.ControlInput.name)
  return _s;
}
inline const std::string& ModelSequenceBatching_ControlInput::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelSequenceBatching_ControlInput::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_ControlInput::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_ControlInput::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.ControlInput.name)
  return _impl_.name_.Release();
}
inline void ModelSequenceBatching_ControlInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.ControlInput.name)
}

// repeated .inference.ModelSequenceBatching.Control control = 2;
inline int ModelSequenceBatching_ControlInput::_internal_control_size() const {
  return _impl_.control_.size();
}
inline int ModelSequenceBatching_ControlInput::control_size() const {
  return _internal_control_size();
}
inline void ModelSequenceBatching_ControlInput::clear_control() {
  _impl_.control_.Clear();
}
inline ::inference::ModelSequenceBatching_Control* ModelSequenceBatching_ControlInput::mutable_control(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.ControlInput.control)
  return _impl_.control_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >*
ModelSequenceBatching_ControlInput::mutable_control() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.ControlInput.control)
  return &_impl_.control_;
}
inline const ::inference::ModelSequenceBatching_Control& ModelSequenceBatching_ControlInput::_internal_control(int index) const {
  return _impl_.control_.Get(index);
}
inline const ::inference::ModelSequenceBatching_Control& ModelSequenceBatching_ControlInput::control(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.ControlInput.control)
  return _internal_control(index);
}
inline ::inference::ModelSequenceBatching_Control* ModelSequenceBatching_ControlInput::_internal_add_control() {
  return _impl_.control_.Add();
}
inline ::inference::ModelSequenceBatching_Control* ModelSequenceBatching_ControlInput::add_control() {
  ::inference::ModelSequenceBatching_Control* _add = _internal_add_control();
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.ControlInput.control)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >&
ModelSequenceBatching_ControlInput::control() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.ControlInput.control)
  return _impl_.control_;
}

// -------------------------------------------------------------------

// ModelSequenceBatching_InitialState

// .inference.DataType data_type = 1;
inline void ModelSequenceBatching_InitialState::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType ModelSequenceBatching_InitialState::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType ModelSequenceBatching_InitialState::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.InitialState.data_type)
  return _internal_data_type();
}
inline void ModelSequenceBatching_InitialState::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void ModelSequenceBatching_InitialState::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.InitialState.data_type)
}

// repeated int64 dims = 2;
inline int ModelSequenceBatching_InitialState::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int ModelSequenceBatching_InitialState::dims_size() const {
  return _internal_dims_size();
}
inline void ModelSequenceBatching_InitialState::clear_dims() {
  _impl_.dims_.Clear();
}
inline int64_t ModelSequenceBatching_InitialState::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int64_t ModelSequenceBatching_InitialState::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.InitialState.dims)
  return _internal_dims(index);
}
inline void ModelSequenceBatching_InitialState::set_dims(int index, int64_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.InitialState.dims)
}
inline void ModelSequenceBatching_InitialState::_internal_add_dims(int64_t value) {
  _impl_.dims_.Add(value);
}
inline void ModelSequenceBatching_InitialState::add_dims(int64_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.InitialState.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelSequenceBatching_InitialState::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelSequenceBatching_InitialState::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.InitialState.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelSequenceBatching_InitialState::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelSequenceBatching_InitialState::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.InitialState.dims)
  return _internal_mutable_dims();
}

// bool zero_data = 3;
inline bool ModelSequenceBatching_InitialState::_internal_has_zero_data() const {
  return state_data_case() == kZeroData;
}
inline bool ModelSequenceBatching_InitialState::has_zero_data() const {
  return _internal_has_zero_data();
}
inline void ModelSequenceBatching_InitialState::set_has_zero_data() {
  _impl_._oneof_case_[0] = kZeroData;
}
inline void ModelSequenceBatching_InitialState::clear_zero_data() {
  if (_internal_has_zero_data()) {
    _impl_.state_data_.zero_data_ = false;
    clear_has_state_data();
  }
}
inline bool ModelSequenceBatching_InitialState::_internal_zero_data() const {
  if (_internal_has_zero_data()) {
    return _impl_.state_data_.zero_data_;
  }
  return false;
}
inline void ModelSequenceBatching_InitialState::_internal_set_zero_data(bool value) {
  if (!_internal_has_zero_data()) {
    clear_state_data();
    set_has_zero_data();
  }
  _impl_.state_data_.zero_data_ = value;
}
inline bool ModelSequenceBatching_InitialState::zero_data() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.InitialState.zero_data)
  return _internal_zero_data();
}
inline void ModelSequenceBatching_InitialState::set_zero_data(bool value) {
  _internal_set_zero_data(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.InitialState.zero_data)
}

// string data_file = 4;
inline bool ModelSequenceBatching_InitialState::_internal_has_data_file() const {
  return state_data_case() == kDataFile;
}
inline bool ModelSequenceBatching_InitialState::has_data_file() const {
  return _internal_has_data_file();
}
inline void ModelSequenceBatching_InitialState::set_has_data_file() {
  _impl_._oneof_case_[0] = kDataFile;
}
inline void ModelSequenceBatching_InitialState::clear_data_file() {
  if (_internal_has_data_file()) {
    _impl_.state_data_.data_file_.Destroy();
    clear_has_state_data();
  }
}
inline const std::string& ModelSequenceBatching_InitialState::data_file() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.InitialState.data_file)
  return _internal_data_file();
}
template <typename ArgT0, typename... ArgT>
inline void ModelSequenceBatching_InitialState::set_data_file(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_data_file()) {
    clear_state_data();
    set_has_data_file();
    _impl_.state_data_.data_file_.InitDefault();
  }
  _impl_.state_data_.data_file_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.InitialState.data_file)
}
inline std::string* ModelSequenceBatching_InitialState::mutable_data_file() {
  std::string* _s = _internal_mutable_data_file();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.InitialState.data_file)
  return _s;
}
inline const std::string& ModelSequenceBatching_InitialState::_internal_data_file() const {
  if (_internal_has_data_file()) {
    return _impl_.state_data_.data_file_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ModelSequenceBatching_InitialState::_internal_set_data_file(const std::string& value) {
  if (!_internal_has_data_file()) {
    clear_state_data();
    set_has_data_file();
    _impl_.state_data_.data_file_.InitDefault();
  }
  _impl_.state_data_.data_file_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_InitialState::_internal_mutable_data_file() {
  if (!_internal_has_data_file()) {
    clear_state_data();
    set_has_data_file();
    _impl_.state_data_.data_file_.InitDefault();
  }
  return _impl_.state_data_.data_file_.Mutable(      GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_InitialState::release_data_file() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.InitialState.data_file)
  if (_internal_has_data_file()) {
    clear_has_state_data();
    return _impl_.state_data_.data_file_.Release();
  } else {
    return nullptr;
  }
}
inline void ModelSequenceBatching_InitialState::set_allocated_data_file(std::string* data_file) {
  if (has_state_data()) {
    clear_state_data();
  }
  if (data_file != nullptr) {
    set_has_data_file();
    _impl_.state_data_.data_file_.InitAllocated(data_file, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.InitialState.data_file)
}

// string name = 5;
inline void ModelSequenceBatching_InitialState::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelSequenceBatching_InitialState::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.InitialState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelSequenceBatching_InitialState::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.InitialState.name)
}
inline std::string* ModelSequenceBatching_InitialState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.InitialState.name)
  return _s;
}
inline const std::string& ModelSequenceBatching_InitialState::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelSequenceBatching_InitialState::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_InitialState::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_InitialState::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.InitialState.name)
  return _impl_.name_.Release();
}
inline void ModelSequenceBatching_InitialState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.InitialState.name)
}

inline bool ModelSequenceBatching_InitialState::has_state_data() const {
  return state_data_case() != STATE_DATA_NOT_SET;
}
inline void ModelSequenceBatching_InitialState::clear_has_state_data() {
  _impl_._oneof_case_[0] = STATE_DATA_NOT_SET;
}
inline ModelSequenceBatching_InitialState::StateDataCase ModelSequenceBatching_InitialState::state_data_case() const {
  return ModelSequenceBatching_InitialState::StateDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ModelSequenceBatching_State

// string input_name = 1;
inline void ModelSequenceBatching_State::clear_input_name() {
  _impl_.input_name_.ClearToEmpty();
}
inline const std::string& ModelSequenceBatching_State::input_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.input_name)
  return _internal_input_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelSequenceBatching_State::set_input_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.input_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.State.input_name)
}
inline std::string* ModelSequenceBatching_State::mutable_input_name() {
  std::string* _s = _internal_mutable_input_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.State.input_name)
  return _s;
}
inline const std::string& ModelSequenceBatching_State::_internal_input_name() const {
  return _impl_.input_name_.Get();
}
inline void ModelSequenceBatching_State::_internal_set_input_name(const std::string& value) {
  
  _impl_.input_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_State::_internal_mutable_input_name() {
  
  return _impl_.input_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_State::release_input_name() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.State.input_name)
  return _impl_.input_name_.Release();
}
inline void ModelSequenceBatching_State::set_allocated_input_name(std::string* input_name) {
  if (input_name != nullptr) {
    
  } else {
    
  }
  _impl_.input_name_.SetAllocated(input_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.input_name_.IsDefault()) {
    _impl_.input_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.State.input_name)
}

// string output_name = 2;
inline void ModelSequenceBatching_State::clear_output_name() {
  _impl_.output_name_.ClearToEmpty();
}
inline const std::string& ModelSequenceBatching_State::output_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.output_name)
  return _internal_output_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelSequenceBatching_State::set_output_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.State.output_name)
}
inline std::string* ModelSequenceBatching_State::mutable_output_name() {
  std::string* _s = _internal_mutable_output_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.State.output_name)
  return _s;
}
inline const std::string& ModelSequenceBatching_State::_internal_output_name() const {
  return _impl_.output_name_.Get();
}
inline void ModelSequenceBatching_State::_internal_set_output_name(const std::string& value) {
  
  _impl_.output_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_State::_internal_mutable_output_name() {
  
  return _impl_.output_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelSequenceBatching_State::release_output_name() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.State.output_name)
  return _impl_.output_name_.Release();
}
inline void ModelSequenceBatching_State::set_allocated_output_name(std::string* output_name) {
  if (output_name != nullptr) {
    
  } else {
    
  }
  _impl_.output_name_.SetAllocated(output_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_name_.IsDefault()) {
    _impl_.output_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.State.output_name)
}

// .inference.DataType data_type = 3;
inline void ModelSequenceBatching_State::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType ModelSequenceBatching_State::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType ModelSequenceBatching_State::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.data_type)
  return _internal_data_type();
}
inline void ModelSequenceBatching_State::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void ModelSequenceBatching_State::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.State.data_type)
}

// repeated int64 dims = 4;
inline int ModelSequenceBatching_State::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int ModelSequenceBatching_State::dims_size() const {
  return _internal_dims_size();
}
inline void ModelSequenceBatching_State::clear_dims() {
  _impl_.dims_.Clear();
}
inline int64_t ModelSequenceBatching_State::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int64_t ModelSequenceBatching_State::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.dims)
  return _internal_dims(index);
}
inline void ModelSequenceBatching_State::set_dims(int index, int64_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.State.dims)
}
inline void ModelSequenceBatching_State::_internal_add_dims(int64_t value) {
  _impl_.dims_.Add(value);
}
inline void ModelSequenceBatching_State::add_dims(int64_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.State.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelSequenceBatching_State::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelSequenceBatching_State::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.State.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelSequenceBatching_State::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelSequenceBatching_State::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.State.dims)
  return _internal_mutable_dims();
}

// repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
inline int ModelSequenceBatching_State::_internal_initial_state_size() const {
  return _impl_.initial_state_.size();
}
inline int ModelSequenceBatching_State::initial_state_size() const {
  return _internal_initial_state_size();
}
inline void ModelSequenceBatching_State::clear_initial_state() {
  _impl_.initial_state_.Clear();
}
inline ::inference::ModelSequenceBatching_InitialState* ModelSequenceBatching_State::mutable_initial_state(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.State.initial_state)
  return _impl_.initial_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_InitialState >*
ModelSequenceBatching_State::mutable_initial_state() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.State.initial_state)
  return &_impl_.initial_state_;
}
inline const ::inference::ModelSequenceBatching_InitialState& ModelSequenceBatching_State::_internal_initial_state(int index) const {
  return _impl_.initial_state_.Get(index);
}
inline const ::inference::ModelSequenceBatching_InitialState& ModelSequenceBatching_State::initial_state(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.initial_state)
  return _internal_initial_state(index);
}
inline ::inference::ModelSequenceBatching_InitialState* ModelSequenceBatching_State::_internal_add_initial_state() {
  return _impl_.initial_state_.Add();
}
inline ::inference::ModelSequenceBatching_InitialState* ModelSequenceBatching_State::add_initial_state() {
  ::inference::ModelSequenceBatching_InitialState* _add = _internal_add_initial_state();
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.State.initial_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_InitialState >&
ModelSequenceBatching_State::initial_state() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.State.initial_state)
  return _impl_.initial_state_;
}

// bool use_same_buffer_for_input_output = 6;
inline void ModelSequenceBatching_State::clear_use_same_buffer_for_input_output() {
  _impl_.use_same_buffer_for_input_output_ = false;
}
inline bool ModelSequenceBatching_State::_internal_use_same_buffer_for_input_output() const {
  return _impl_.use_same_buffer_for_input_output_;
}
inline bool ModelSequenceBatching_State::use_same_buffer_for_input_output() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.use_same_buffer_for_input_output)
  return _internal_use_same_buffer_for_input_output();
}
inline void ModelSequenceBatching_State::_internal_set_use_same_buffer_for_input_output(bool value) {
  
  _impl_.use_same_buffer_for_input_output_ = value;
}
inline void ModelSequenceBatching_State::set_use_same_buffer_for_input_output(bool value) {
  _internal_set_use_same_buffer_for_input_output(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.State.use_same_buffer_for_input_output)
}

// bool use_growable_memory = 7;
inline void ModelSequenceBatching_State::clear_use_growable_memory() {
  _impl_.use_growable_memory_ = false;
}
inline bool ModelSequenceBatching_State::_internal_use_growable_memory() const {
  return _impl_.use_growable_memory_;
}
inline bool ModelSequenceBatching_State::use_growable_memory() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.State.use_growable_memory)
  return _internal_use_growable_memory();
}
inline void ModelSequenceBatching_State::_internal_set_use_growable_memory(bool value) {
  
  _impl_.use_growable_memory_ = value;
}
inline void ModelSequenceBatching_State::set_use_growable_memory(bool value) {
  _internal_set_use_growable_memory(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.State.use_growable_memory)
}

// -------------------------------------------------------------------

// ModelSequenceBatching_StrategyDirect

// uint64 max_queue_delay_microseconds = 1;
inline void ModelSequenceBatching_StrategyDirect::clear_max_queue_delay_microseconds() {
  _impl_.max_queue_delay_microseconds_ = uint64_t{0u};
}
inline uint64_t ModelSequenceBatching_StrategyDirect::_internal_max_queue_delay_microseconds() const {
  return _impl_.max_queue_delay_microseconds_;
}
inline uint64_t ModelSequenceBatching_StrategyDirect::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyDirect.max_queue_delay_microseconds)
  return _internal_max_queue_delay_microseconds();
}
inline void ModelSequenceBatching_StrategyDirect::_internal_set_max_queue_delay_microseconds(uint64_t value) {
  
  _impl_.max_queue_delay_microseconds_ = value;
}
inline void ModelSequenceBatching_StrategyDirect::set_max_queue_delay_microseconds(uint64_t value) {
  _internal_set_max_queue_delay_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyDirect.max_queue_delay_microseconds)
}

// float minimum_slot_utilization = 2;
inline void ModelSequenceBatching_StrategyDirect::clear_minimum_slot_utilization() {
  _impl_.minimum_slot_utilization_ = 0;
}
inline float ModelSequenceBatching_StrategyDirect::_internal_minimum_slot_utilization() const {
  return _impl_.minimum_slot_utilization_;
}
inline float ModelSequenceBatching_StrategyDirect::minimum_slot_utilization() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyDirect.minimum_slot_utilization)
  return _internal_minimum_slot_utilization();
}
inline void ModelSequenceBatching_StrategyDirect::_internal_set_minimum_slot_utilization(float value) {
  
  _impl_.minimum_slot_utilization_ = value;
}
inline void ModelSequenceBatching_StrategyDirect::set_minimum_slot_utilization(float value) {
  _internal_set_minimum_slot_utilization(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyDirect.minimum_slot_utilization)
}

// -------------------------------------------------------------------

// ModelSequenceBatching_StrategyOldest

// int32 max_candidate_sequences = 1;
inline void ModelSequenceBatching_StrategyOldest::clear_max_candidate_sequences() {
  _impl_.max_candidate_sequences_ = 0;
}
inline int32_t ModelSequenceBatching_StrategyOldest::_internal_max_candidate_sequences() const {
  return _impl_.max_candidate_sequences_;
}
inline int32_t ModelSequenceBatching_StrategyOldest::max_candidate_sequences() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.max_candidate_sequences)
  return _internal_max_candidate_sequences();
}
inline void ModelSequenceBatching_StrategyOldest::_internal_set_max_candidate_sequences(int32_t value) {
  
  _impl_.max_candidate_sequences_ = value;
}
inline void ModelSequenceBatching_StrategyOldest::set_max_candidate_sequences(int32_t value) {
  _internal_set_max_candidate_sequences(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.max_candidate_sequences)
}

// repeated int32 preferred_batch_size = 2;
inline int ModelSequenceBatching_StrategyOldest::_internal_preferred_batch_size_size() const {
  return _impl_.preferred_batch_size_.size();
}
inline int ModelSequenceBatching_StrategyOldest::preferred_batch_size_size() const {
  return _internal_preferred_batch_size_size();
}
inline void ModelSequenceBatching_StrategyOldest::clear_preferred_batch_size() {
  _impl_.preferred_batch_size_.Clear();
}
inline int32_t ModelSequenceBatching_StrategyOldest::_internal_preferred_batch_size(int index) const {
  return _impl_.preferred_batch_size_.Get(index);
}
inline int32_t ModelSequenceBatching_StrategyOldest::preferred_batch_size(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
  return _internal_preferred_batch_size(index);
}
inline void ModelSequenceBatching_StrategyOldest::set_preferred_batch_size(int index, int32_t value) {
  _impl_.preferred_batch_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
}
inline void ModelSequenceBatching_StrategyOldest::_internal_add_preferred_batch_size(int32_t value) {
  _impl_.preferred_batch_size_.Add(value);
}
inline void ModelSequenceBatching_StrategyOldest::add_preferred_batch_size(int32_t value) {
  _internal_add_preferred_batch_size(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelSequenceBatching_StrategyOldest::_internal_preferred_batch_size() const {
  return _impl_.preferred_batch_size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ModelSequenceBatching_StrategyOldest::preferred_batch_size() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
  return _internal_preferred_batch_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelSequenceBatching_StrategyOldest::_internal_mutable_preferred_batch_size() {
  return &_impl_.preferred_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ModelSequenceBatching_StrategyOldest::mutable_preferred_batch_size() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
  return _internal_mutable_preferred_batch_size();
}

// uint64 max_queue_delay_microseconds = 3;
inline void ModelSequenceBatching_StrategyOldest::clear_max_queue_delay_microseconds() {
  _impl_.max_queue_delay_microseconds_ = uint64_t{0u};
}
inline uint64_t ModelSequenceBatching_StrategyOldest::_internal_max_queue_delay_microseconds() const {
  return _impl_.max_queue_delay_microseconds_;
}
inline uint64_t ModelSequenceBatching_StrategyOldest::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.max_queue_delay_microseconds)
  return _internal_max_queue_delay_microseconds();
}
inline void ModelSequenceBatching_StrategyOldest::_internal_set_max_queue_delay_microseconds(uint64_t value) {
  
  _impl_.max_queue_delay_microseconds_ = value;
}
inline void ModelSequenceBatching_StrategyOldest::set_max_queue_delay_microseconds(uint64_t value) {
  _internal_set_max_queue_delay_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.max_queue_delay_microseconds)
}

// bool preserve_ordering = 4;
inline void ModelSequenceBatching_StrategyOldest::clear_preserve_ordering() {
  _impl_.preserve_ordering_ = false;
}
inline bool ModelSequenceBatching_StrategyOldest::_internal_preserve_ordering() const {
  return _impl_.preserve_ordering_;
}
inline bool ModelSequenceBatching_StrategyOldest::preserve_ordering() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.preserve_ordering)
  return _internal_preserve_ordering();
}
inline void ModelSequenceBatching_StrategyOldest::_internal_set_preserve_ordering(bool value) {
  
  _impl_.preserve_ordering_ = value;
}
inline void ModelSequenceBatching_StrategyOldest::set_preserve_ordering(bool value) {
  _internal_set_preserve_ordering(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.preserve_ordering)
}

// -------------------------------------------------------------------

// ModelSequenceBatching

// .inference.ModelSequenceBatching.StrategyDirect direct = 3;
inline bool ModelSequenceBatching::_internal_has_direct() const {
  return strategy_choice_case() == kDirect;
}
inline bool ModelSequenceBatching::has_direct() const {
  return _internal_has_direct();
}
inline void ModelSequenceBatching::set_has_direct() {
  _impl_._oneof_case_[0] = kDirect;
}
inline void ModelSequenceBatching::clear_direct() {
  if (_internal_has_direct()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_choice_.direct_;
    }
    clear_has_strategy_choice();
  }
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::release_direct() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.direct)
  if (_internal_has_direct()) {
    clear_has_strategy_choice();
    ::inference::ModelSequenceBatching_StrategyDirect* temp = _impl_.strategy_choice_.direct_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_choice_.direct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelSequenceBatching_StrategyDirect& ModelSequenceBatching::_internal_direct() const {
  return _internal_has_direct()
      ? *_impl_.strategy_choice_.direct_
      : reinterpret_cast< ::inference::ModelSequenceBatching_StrategyDirect&>(::inference::_ModelSequenceBatching_StrategyDirect_default_instance_);
}
inline const ::inference::ModelSequenceBatching_StrategyDirect& ModelSequenceBatching::direct() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.direct)
  return _internal_direct();
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::unsafe_arena_release_direct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelSequenceBatching.direct)
  if (_internal_has_direct()) {
    clear_has_strategy_choice();
    ::inference::ModelSequenceBatching_StrategyDirect* temp = _impl_.strategy_choice_.direct_;
    _impl_.strategy_choice_.direct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelSequenceBatching::unsafe_arena_set_allocated_direct(::inference::ModelSequenceBatching_StrategyDirect* direct) {
  clear_strategy_choice();
  if (direct) {
    set_has_direct();
    _impl_.strategy_choice_.direct_ = direct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelSequenceBatching.direct)
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::_internal_mutable_direct() {
  if (!_internal_has_direct()) {
    clear_strategy_choice();
    set_has_direct();
    _impl_.strategy_choice_.direct_ = CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyDirect >(GetArenaForAllocation());
  }
  return _impl_.strategy_choice_.direct_;
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::mutable_direct() {
  ::inference::ModelSequenceBatching_StrategyDirect* _msg = _internal_mutable_direct();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.direct)
  return _msg;
}

// .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
inline bool ModelSequenceBatching::_internal_has_oldest() const {
  return strategy_choice_case() == kOldest;
}
inline bool ModelSequenceBatching::has_oldest() const {
  return _internal_has_oldest();
}
inline void ModelSequenceBatching::set_has_oldest() {
  _impl_._oneof_case_[0] = kOldest;
}
inline void ModelSequenceBatching::clear_oldest() {
  if (_internal_has_oldest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_choice_.oldest_;
    }
    clear_has_strategy_choice();
  }
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::release_oldest() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.oldest)
  if (_internal_has_oldest()) {
    clear_has_strategy_choice();
    ::inference::ModelSequenceBatching_StrategyOldest* temp = _impl_.strategy_choice_.oldest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_choice_.oldest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelSequenceBatching_StrategyOldest& ModelSequenceBatching::_internal_oldest() const {
  return _internal_has_oldest()
      ? *_impl_.strategy_choice_.oldest_
      : reinterpret_cast< ::inference::ModelSequenceBatching_StrategyOldest&>(::inference::_ModelSequenceBatching_StrategyOldest_default_instance_);
}
inline const ::inference::ModelSequenceBatching_StrategyOldest& ModelSequenceBatching::oldest() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.oldest)
  return _internal_oldest();
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::unsafe_arena_release_oldest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelSequenceBatching.oldest)
  if (_internal_has_oldest()) {
    clear_has_strategy_choice();
    ::inference::ModelSequenceBatching_StrategyOldest* temp = _impl_.strategy_choice_.oldest_;
    _impl_.strategy_choice_.oldest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelSequenceBatching::unsafe_arena_set_allocated_oldest(::inference::ModelSequenceBatching_StrategyOldest* oldest) {
  clear_strategy_choice();
  if (oldest) {
    set_has_oldest();
    _impl_.strategy_choice_.oldest_ = oldest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelSequenceBatching.oldest)
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::_internal_mutable_oldest() {
  if (!_internal_has_oldest()) {
    clear_strategy_choice();
    set_has_oldest();
    _impl_.strategy_choice_.oldest_ = CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyOldest >(GetArenaForAllocation());
  }
  return _impl_.strategy_choice_.oldest_;
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::mutable_oldest() {
  ::inference::ModelSequenceBatching_StrategyOldest* _msg = _internal_mutable_oldest();
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.oldest)
  return _msg;
}

// uint64 max_sequence_idle_microseconds = 1;
inline void ModelSequenceBatching::clear_max_sequence_idle_microseconds() {
  _impl_.max_sequence_idle_microseconds_ = uint64_t{0u};
}
inline uint64_t ModelSequenceBatching::_internal_max_sequence_idle_microseconds() const {
  return _impl_.max_sequence_idle_microseconds_;
}
inline uint64_t ModelSequenceBatching::max_sequence_idle_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.max_sequence_idle_microseconds)
  return _internal_max_sequence_idle_microseconds();
}
inline void ModelSequenceBatching::_internal_set_max_sequence_idle_microseconds(uint64_t value) {
  
  _impl_.max_sequence_idle_microseconds_ = value;
}
inline void ModelSequenceBatching::set_max_sequence_idle_microseconds(uint64_t value) {
  _internal_set_max_sequence_idle_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.max_sequence_idle_microseconds)
}

// repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
inline int ModelSequenceBatching::_internal_control_input_size() const {
  return _impl_.control_input_.size();
}
inline int ModelSequenceBatching::control_input_size() const {
  return _internal_control_input_size();
}
inline void ModelSequenceBatching::clear_control_input() {
  _impl_.control_input_.Clear();
}
inline ::inference::ModelSequenceBatching_ControlInput* ModelSequenceBatching::mutable_control_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.control_input)
  return _impl_.control_input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >*
ModelSequenceBatching::mutable_control_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.control_input)
  return &_impl_.control_input_;
}
inline const ::inference::ModelSequenceBatching_ControlInput& ModelSequenceBatching::_internal_control_input(int index) const {
  return _impl_.control_input_.Get(index);
}
inline const ::inference::ModelSequenceBatching_ControlInput& ModelSequenceBatching::control_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.control_input)
  return _internal_control_input(index);
}
inline ::inference::ModelSequenceBatching_ControlInput* ModelSequenceBatching::_internal_add_control_input() {
  return _impl_.control_input_.Add();
}
inline ::inference::ModelSequenceBatching_ControlInput* ModelSequenceBatching::add_control_input() {
  ::inference::ModelSequenceBatching_ControlInput* _add = _internal_add_control_input();
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.control_input)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >&
ModelSequenceBatching::control_input() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.control_input)
  return _impl_.control_input_;
}

// repeated .inference.ModelSequenceBatching.State state = 5;
inline int ModelSequenceBatching::_internal_state_size() const {
  return _impl_.state_.size();
}
inline int ModelSequenceBatching::state_size() const {
  return _internal_state_size();
}
inline void ModelSequenceBatching::clear_state() {
  _impl_.state_.Clear();
}
inline ::inference::ModelSequenceBatching_State* ModelSequenceBatching::mutable_state(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.state)
  return _impl_.state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_State >*
ModelSequenceBatching::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.state)
  return &_impl_.state_;
}
inline const ::inference::ModelSequenceBatching_State& ModelSequenceBatching::_internal_state(int index) const {
  return _impl_.state_.Get(index);
}
inline const ::inference::ModelSequenceBatching_State& ModelSequenceBatching::state(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.state)
  return _internal_state(index);
}
inline ::inference::ModelSequenceBatching_State* ModelSequenceBatching::_internal_add_state() {
  return _impl_.state_.Add();
}
inline ::inference::ModelSequenceBatching_State* ModelSequenceBatching::add_state() {
  ::inference::ModelSequenceBatching_State* _add = _internal_add_state();
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_State >&
ModelSequenceBatching::state() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.state)
  return _impl_.state_;
}

// bool iterative_sequence = 6;
inline void ModelSequenceBatching::clear_iterative_sequence() {
  _impl_.iterative_sequence_ = false;
}
inline bool ModelSequenceBatching::_internal_iterative_sequence() const {
  return _impl_.iterative_sequence_;
}
inline bool ModelSequenceBatching::iterative_sequence() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.iterative_sequence)
  return _internal_iterative_sequence();
}
inline void ModelSequenceBatching::_internal_set_iterative_sequence(bool value) {
  
  _impl_.iterative_sequence_ = value;
}
inline void ModelSequenceBatching::set_iterative_sequence(bool value) {
  _internal_set_iterative_sequence(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.iterative_sequence)
}

inline bool ModelSequenceBatching::has_strategy_choice() const {
  return strategy_choice_case() != STRATEGY_CHOICE_NOT_SET;
}
inline void ModelSequenceBatching::clear_has_strategy_choice() {
  _impl_._oneof_case_[0] = STRATEGY_CHOICE_NOT_SET;
}
inline ModelSequenceBatching::StrategyChoiceCase ModelSequenceBatching::strategy_choice_case() const {
  return ModelSequenceBatching::StrategyChoiceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelEnsembling_Step

// string model_name = 1;
inline void ModelEnsembling_Step::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelEnsembling_Step::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.Step.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelEnsembling_Step::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelEnsembling.Step.model_name)
}
inline std::string* ModelEnsembling_Step::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelEnsembling.Step.model_name)
  return _s;
}
inline const std::string& ModelEnsembling_Step::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelEnsembling_Step::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelEnsembling_Step::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelEnsembling_Step::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelEnsembling.Step.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelEnsembling_Step::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelEnsembling.Step.model_name)
}

// int64 model_version = 2;
inline void ModelEnsembling_Step::clear_model_version() {
  _impl_.model_version_ = int64_t{0};
}
inline int64_t ModelEnsembling_Step::_internal_model_version() const {
  return _impl_.model_version_;
}
inline int64_t ModelEnsembling_Step::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.Step.model_version)
  return _internal_model_version();
}
inline void ModelEnsembling_Step::_internal_set_model_version(int64_t value) {
  
  _impl_.model_version_ = value;
}
inline void ModelEnsembling_Step::set_model_version(int64_t value) {
  _internal_set_model_version(value);
  // @@protoc_insertion_point(field_set:inference.ModelEnsembling.Step.model_version)
}

// map<string, string> input_map = 3;
inline int ModelEnsembling_Step::_internal_input_map_size() const {
  return _impl_.input_map_.size();
}
inline int ModelEnsembling_Step::input_map_size() const {
  return _internal_input_map_size();
}
inline void ModelEnsembling_Step::clear_input_map() {
  _impl_.input_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::_internal_input_map() const {
  return _impl_.input_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::input_map() const {
  // @@protoc_insertion_point(field_map:inference.ModelEnsembling.Step.input_map)
  return _internal_input_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::_internal_mutable_input_map() {
  return _impl_.input_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::mutable_input_map() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelEnsembling.Step.input_map)
  return _internal_mutable_input_map();
}

// map<string, string> output_map = 4;
inline int ModelEnsembling_Step::_internal_output_map_size() const {
  return _impl_.output_map_.size();
}
inline int ModelEnsembling_Step::output_map_size() const {
  return _internal_output_map_size();
}
inline void ModelEnsembling_Step::clear_output_map() {
  _impl_.output_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::_internal_output_map() const {
  return _impl_.output_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::output_map() const {
  // @@protoc_insertion_point(field_map:inference.ModelEnsembling.Step.output_map)
  return _internal_output_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::_internal_mutable_output_map() {
  return _impl_.output_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::mutable_output_map() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelEnsembling.Step.output_map)
  return _internal_mutable_output_map();
}

// string model_namespace = 5;
inline void ModelEnsembling_Step::clear_model_namespace() {
  _impl_.model_namespace_.ClearToEmpty();
}
inline const std::string& ModelEnsembling_Step::model_namespace() const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.Step.model_namespace)
  return _internal_model_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelEnsembling_Step::set_model_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelEnsembling.Step.model_namespace)
}
inline std::string* ModelEnsembling_Step::mutable_model_namespace() {
  std::string* _s = _internal_mutable_model_namespace();
  // @@protoc_insertion_point(field_mutable:inference.ModelEnsembling.Step.model_namespace)
  return _s;
}
inline const std::string& ModelEnsembling_Step::_internal_model_namespace() const {
  return _impl_.model_namespace_.Get();
}
inline void ModelEnsembling_Step::_internal_set_model_namespace(const std::string& value) {
  
  _impl_.model_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelEnsembling_Step::_internal_mutable_model_namespace() {
  
  return _impl_.model_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelEnsembling_Step::release_model_namespace() {
  // @@protoc_insertion_point(field_release:inference.ModelEnsembling.Step.model_namespace)
  return _impl_.model_namespace_.Release();
}
inline void ModelEnsembling_Step::set_allocated_model_namespace(std::string* model_namespace) {
  if (model_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.model_namespace_.SetAllocated(model_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_namespace_.IsDefault()) {
    _impl_.model_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelEnsembling.Step.model_namespace)
}

// -------------------------------------------------------------------

// ModelEnsembling

// repeated .inference.ModelEnsembling.Step step = 1;
inline int ModelEnsembling::_internal_step_size() const {
  return _impl_.step_.size();
}
inline int ModelEnsembling::step_size() const {
  return _internal_step_size();
}
inline void ModelEnsembling::clear_step() {
  _impl_.step_.Clear();
}
inline ::inference::ModelEnsembling_Step* ModelEnsembling::mutable_step(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelEnsembling.step)
  return _impl_.step_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >*
ModelEnsembling::mutable_step() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelEnsembling.step)
  return &_impl_.step_;
}
inline const ::inference::ModelEnsembling_Step& ModelEnsembling::_internal_step(int index) const {
  return _impl_.step_.Get(index);
}
inline const ::inference::ModelEnsembling_Step& ModelEnsembling::step(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.step)
  return _internal_step(index);
}
inline ::inference::ModelEnsembling_Step* ModelEnsembling::_internal_add_step() {
  return _impl_.step_.Add();
}
inline ::inference::ModelEnsembling_Step* ModelEnsembling::add_step() {
  ::inference::ModelEnsembling_Step* _add = _internal_add_step();
  // @@protoc_insertion_point(field_add:inference.ModelEnsembling.step)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >&
ModelEnsembling::step() const {
  // @@protoc_insertion_point(field_list:inference.ModelEnsembling.step)
  return _impl_.step_;
}

// -------------------------------------------------------------------

// ModelParameter

// string string_value = 1;
inline void ModelParameter::clear_string_value() {
  _impl_.string_value_.ClearToEmpty();
}
inline const std::string& ModelParameter::string_value() const {
  // @@protoc_insertion_point(field_get:inference.ModelParameter.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelParameter::set_string_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.string_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelParameter.string_value)
}
inline std::string* ModelParameter::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:inference.ModelParameter.string_value)
  return _s;
}
inline const std::string& ModelParameter::_internal_string_value() const {
  return _impl_.string_value_.Get();
}
inline void ModelParameter::_internal_set_string_value(const std::string& value) {
  
  _impl_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelParameter::_internal_mutable_string_value() {
  
  return _impl_.string_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelParameter::release_string_value() {
  // @@protoc_insertion_point(field_release:inference.ModelParameter.string_value)
  return _impl_.string_value_.Release();
}
inline void ModelParameter::set_allocated_string_value(std::string* string_value) {
  if (string_value != nullptr) {
    
  } else {
    
  }
  _impl_.string_value_.SetAllocated(string_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_value_.IsDefault()) {
    _impl_.string_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelParameter.string_value)
}

// -------------------------------------------------------------------

// ModelWarmup_Input

// .inference.DataType data_type = 1;
inline void ModelWarmup_Input::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::inference::DataType ModelWarmup_Input::_internal_data_type() const {
  return static_cast< ::inference::DataType >(_impl_.data_type_);
}
inline ::inference::DataType ModelWarmup_Input::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.data_type)
  return _internal_data_type();
}
inline void ModelWarmup_Input::_internal_set_data_type(::inference::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void ModelWarmup_Input::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.data_type)
}

// repeated int64 dims = 2;
inline int ModelWarmup_Input::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int ModelWarmup_Input::dims_size() const {
  return _internal_dims_size();
}
inline void ModelWarmup_Input::clear_dims() {
  _impl_.dims_.Clear();
}
inline int64_t ModelWarmup_Input::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int64_t ModelWarmup_Input::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.dims)
  return _internal_dims(index);
}
inline void ModelWarmup_Input::set_dims(int index, int64_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.dims)
}
inline void ModelWarmup_Input::_internal_add_dims(int64_t value) {
  _impl_.dims_.Add(value);
}
inline void ModelWarmup_Input::add_dims(int64_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelWarmup.Input.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelWarmup_Input::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelWarmup_Input::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelWarmup.Input.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelWarmup_Input::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelWarmup_Input::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelWarmup.Input.dims)
  return _internal_mutable_dims();
}

// bool zero_data = 3;
inline bool ModelWarmup_Input::_internal_has_zero_data() const {
  return input_data_type_case() == kZeroData;
}
inline bool ModelWarmup_Input::has_zero_data() const {
  return _internal_has_zero_data();
}
inline void ModelWarmup_Input::set_has_zero_data() {
  _impl_._oneof_case_[0] = kZeroData;
}
inline void ModelWarmup_Input::clear_zero_data() {
  if (_internal_has_zero_data()) {
    _impl_.input_data_type_.zero_data_ = false;
    clear_has_input_data_type();
  }
}
inline bool ModelWarmup_Input::_internal_zero_data() const {
  if (_internal_has_zero_data()) {
    return _impl_.input_data_type_.zero_data_;
  }
  return false;
}
inline void ModelWarmup_Input::_internal_set_zero_data(bool value) {
  if (!_internal_has_zero_data()) {
    clear_input_data_type();
    set_has_zero_data();
  }
  _impl_.input_data_type_.zero_data_ = value;
}
inline bool ModelWarmup_Input::zero_data() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.zero_data)
  return _internal_zero_data();
}
inline void ModelWarmup_Input::set_zero_data(bool value) {
  _internal_set_zero_data(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.zero_data)
}

// bool random_data = 4;
inline bool ModelWarmup_Input::_internal_has_random_data() const {
  return input_data_type_case() == kRandomData;
}
inline bool ModelWarmup_Input::has_random_data() const {
  return _internal_has_random_data();
}
inline void ModelWarmup_Input::set_has_random_data() {
  _impl_._oneof_case_[0] = kRandomData;
}
inline void ModelWarmup_Input::clear_random_data() {
  if (_internal_has_random_data()) {
    _impl_.input_data_type_.random_data_ = false;
    clear_has_input_data_type();
  }
}
inline bool ModelWarmup_Input::_internal_random_data() const {
  if (_internal_has_random_data()) {
    return _impl_.input_data_type_.random_data_;
  }
  return false;
}
inline void ModelWarmup_Input::_internal_set_random_data(bool value) {
  if (!_internal_has_random_data()) {
    clear_input_data_type();
    set_has_random_data();
  }
  _impl_.input_data_type_.random_data_ = value;
}
inline bool ModelWarmup_Input::random_data() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.random_data)
  return _internal_random_data();
}
inline void ModelWarmup_Input::set_random_data(bool value) {
  _internal_set_random_data(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.random_data)
}

// string input_data_file = 5;
inline bool ModelWarmup_Input::_internal_has_input_data_file() const {
  return input_data_type_case() == kInputDataFile;
}
inline bool ModelWarmup_Input::has_input_data_file() const {
  return _internal_has_input_data_file();
}
inline void ModelWarmup_Input::set_has_input_data_file() {
  _impl_._oneof_case_[0] = kInputDataFile;
}
inline void ModelWarmup_Input::clear_input_data_file() {
  if (_internal_has_input_data_file()) {
    _impl_.input_data_type_.input_data_file_.Destroy();
    clear_has_input_data_type();
  }
}
inline const std::string& ModelWarmup_Input::input_data_file() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.input_data_file)
  return _internal_input_data_file();
}
template <typename ArgT0, typename... ArgT>
inline void ModelWarmup_Input::set_input_data_file(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    _impl_.input_data_type_.input_data_file_.InitDefault();
  }
  _impl_.input_data_type_.input_data_file_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.input_data_file)
}
inline std::string* ModelWarmup_Input::mutable_input_data_file() {
  std::string* _s = _internal_mutable_input_data_file();
  // @@protoc_insertion_point(field_mutable:inference.ModelWarmup.Input.input_data_file)
  return _s;
}
inline const std::string& ModelWarmup_Input::_internal_input_data_file() const {
  if (_internal_has_input_data_file()) {
    return _impl_.input_data_type_.input_data_file_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ModelWarmup_Input::_internal_set_input_data_file(const std::string& value) {
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    _impl_.input_data_type_.input_data_file_.InitDefault();
  }
  _impl_.input_data_type_.input_data_file_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelWarmup_Input::_internal_mutable_input_data_file() {
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    _impl_.input_data_type_.input_data_file_.InitDefault();
  }
  return _impl_.input_data_type_.input_data_file_.Mutable(      GetArenaForAllocation());
}
inline std::string* ModelWarmup_Input::release_input_data_file() {
  // @@protoc_insertion_point(field_release:inference.ModelWarmup.Input.input_data_file)
  if (_internal_has_input_data_file()) {
    clear_has_input_data_type();
    return _impl_.input_data_type_.input_data_file_.Release();
  } else {
    return nullptr;
  }
}
inline void ModelWarmup_Input::set_allocated_input_data_file(std::string* input_data_file) {
  if (has_input_data_type()) {
    clear_input_data_type();
  }
  if (input_data_file != nullptr) {
    set_has_input_data_file();
    _impl_.input_data_type_.input_data_file_.InitAllocated(input_data_file, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelWarmup.Input.input_data_file)
}

inline bool ModelWarmup_Input::has_input_data_type() const {
  return input_data_type_case() != INPUT_DATA_TYPE_NOT_SET;
}
inline void ModelWarmup_Input::clear_has_input_data_type() {
  _impl_._oneof_case_[0] = INPUT_DATA_TYPE_NOT_SET;
}
inline ModelWarmup_Input::InputDataTypeCase ModelWarmup_Input::input_data_type_case() const {
  return ModelWarmup_Input::InputDataTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelWarmup

// string name = 1;
inline void ModelWarmup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelWarmup::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelWarmup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.name)
}
inline std::string* ModelWarmup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelWarmup.name)
  return _s;
}
inline const std::string& ModelWarmup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelWarmup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelWarmup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelWarmup::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelWarmup.name)
  return _impl_.name_.Release();
}
inline void ModelWarmup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelWarmup.name)
}

// uint32 batch_size = 2;
inline void ModelWarmup::clear_batch_size() {
  _impl_.batch_size_ = 0u;
}
inline uint32_t ModelWarmup::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline uint32_t ModelWarmup::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.batch_size)
  return _internal_batch_size();
}
inline void ModelWarmup::_internal_set_batch_size(uint32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void ModelWarmup::set_batch_size(uint32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.batch_size)
}

// map<string, .inference.ModelWarmup.Input> inputs = 3;
inline int ModelWarmup::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int ModelWarmup::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelWarmup::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
ModelWarmup::_internal_inputs() const {
  return _impl_.inputs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
ModelWarmup::inputs() const {
  // @@protoc_insertion_point(field_map:inference.ModelWarmup.inputs)
  return _internal_inputs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
ModelWarmup::_internal_mutable_inputs() {
  return _impl_.inputs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
ModelWarmup::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelWarmup.inputs)
  return _internal_mutable_inputs();
}

// uint32 count = 4;
inline void ModelWarmup::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t ModelWarmup::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t ModelWarmup::count() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.count)
  return _internal_count();
}
inline void ModelWarmup::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void ModelWarmup::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.count)
}

// -------------------------------------------------------------------

// ModelOperations

// repeated string op_library_filename = 1;
inline int ModelOperations::_internal_op_library_filename_size() const {
  return _impl_.op_library_filename_.size();
}
inline int ModelOperations::op_library_filename_size() const {
  return _internal_op_library_filename_size();
}
inline void ModelOperations::clear_op_library_filename() {
  _impl_.op_library_filename_.Clear();
}
inline std::string* ModelOperations::add_op_library_filename() {
  std::string* _s = _internal_add_op_library_filename();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelOperations.op_library_filename)
  return _s;
}
inline const std::string& ModelOperations::_internal_op_library_filename(int index) const {
  return _impl_.op_library_filename_.Get(index);
}
inline const std::string& ModelOperations::op_library_filename(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOperations.op_library_filename)
  return _internal_op_library_filename(index);
}
inline std::string* ModelOperations::mutable_op_library_filename(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOperations.op_library_filename)
  return _impl_.op_library_filename_.Mutable(index);
}
inline void ModelOperations::set_op_library_filename(int index, const std::string& value) {
  _impl_.op_library_filename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::set_op_library_filename(int index, std::string&& value) {
  _impl_.op_library_filename_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::set_op_library_filename(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.op_library_filename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::set_op_library_filename(int index, const char* value, size_t size) {
  _impl_.op_library_filename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelOperations.op_library_filename)
}
inline std::string* ModelOperations::_internal_add_op_library_filename() {
  return _impl_.op_library_filename_.Add();
}
inline void ModelOperations::add_op_library_filename(const std::string& value) {
  _impl_.op_library_filename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::add_op_library_filename(std::string&& value) {
  _impl_.op_library_filename_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::add_op_library_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.op_library_filename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::add_op_library_filename(const char* value, size_t size) {
  _impl_.op_library_filename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelOperations.op_library_filename)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelOperations::op_library_filename() const {
  // @@protoc_insertion_point(field_list:inference.ModelOperations.op_library_filename)
  return _impl_.op_library_filename_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelOperations::mutable_op_library_filename() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOperations.op_library_filename)
  return &_impl_.op_library_filename_;
}

// -------------------------------------------------------------------

// ModelTransactionPolicy

// bool decoupled = 1;
inline void ModelTransactionPolicy::clear_decoupled() {
  _impl_.decoupled_ = false;
}
inline bool ModelTransactionPolicy::_internal_decoupled() const {
  return _impl_.decoupled_;
}
inline bool ModelTransactionPolicy::decoupled() const {
  // @@protoc_insertion_point(field_get:inference.ModelTransactionPolicy.decoupled)
  return _internal_decoupled();
}
inline void ModelTransactionPolicy::_internal_set_decoupled(bool value) {
  
  _impl_.decoupled_ = value;
}
inline void ModelTransactionPolicy::set_decoupled(bool value) {
  _internal_set_decoupled(value);
  // @@protoc_insertion_point(field_set:inference.ModelTransactionPolicy.decoupled)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelRepositoryAgents_Agent

// string name = 1;
inline void ModelRepositoryAgents_Agent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelRepositoryAgents_Agent::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelRepositoryAgents.Agent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelRepositoryAgents_Agent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelRepositoryAgents.Agent.name)
}
inline std::string* ModelRepositoryAgents_Agent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelRepositoryAgents.Agent.name)
  return _s;
}
inline const std::string& ModelRepositoryAgents_Agent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelRepositoryAgents_Agent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelRepositoryAgents_Agent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelRepositoryAgents_Agent::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelRepositoryAgents.Agent.name)
  return _impl_.name_.Release();
}
inline void ModelRepositoryAgents_Agent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelRepositoryAgents.Agent.name)
}

// map<string, string> parameters = 2;
inline int ModelRepositoryAgents_Agent::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelRepositoryAgents_Agent::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelRepositoryAgents_Agent::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelRepositoryAgents_Agent::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelRepositoryAgents_Agent::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelRepositoryAgents.Agent.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelRepositoryAgents_Agent::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelRepositoryAgents_Agent::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelRepositoryAgents.Agent.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// ModelRepositoryAgents

// repeated .inference.ModelRepositoryAgents.Agent agents = 1;
inline int ModelRepositoryAgents::_internal_agents_size() const {
  return _impl_.agents_.size();
}
inline int ModelRepositoryAgents::agents_size() const {
  return _internal_agents_size();
}
inline void ModelRepositoryAgents::clear_agents() {
  _impl_.agents_.Clear();
}
inline ::inference::ModelRepositoryAgents_Agent* ModelRepositoryAgents::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelRepositoryAgents.agents)
  return _impl_.agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRepositoryAgents_Agent >*
ModelRepositoryAgents::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelRepositoryAgents.agents)
  return &_impl_.agents_;
}
inline const ::inference::ModelRepositoryAgents_Agent& ModelRepositoryAgents::_internal_agents(int index) const {
  return _impl_.agents_.Get(index);
}
inline const ::inference::ModelRepositoryAgents_Agent& ModelRepositoryAgents::agents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelRepositoryAgents.agents)
  return _internal_agents(index);
}
inline ::inference::ModelRepositoryAgents_Agent* ModelRepositoryAgents::_internal_add_agents() {
  return _impl_.agents_.Add();
}
inline ::inference::ModelRepositoryAgents_Agent* ModelRepositoryAgents::add_agents() {
  ::inference::ModelRepositoryAgents_Agent* _add = _internal_add_agents();
  // @@protoc_insertion_point(field_add:inference.ModelRepositoryAgents.agents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRepositoryAgents_Agent >&
ModelRepositoryAgents::agents() const {
  // @@protoc_insertion_point(field_list:inference.ModelRepositoryAgents.agents)
  return _impl_.agents_;
}

// -------------------------------------------------------------------

// ModelResponseCache

// bool enable = 1;
inline void ModelResponseCache::clear_enable() {
  _impl_.enable_ = false;
}
inline bool ModelResponseCache::_internal_enable() const {
  return _impl_.enable_;
}
inline bool ModelResponseCache::enable() const {
  // @@protoc_insertion_point(field_get:inference.ModelResponseCache.enable)
  return _internal_enable();
}
inline void ModelResponseCache::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void ModelResponseCache::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:inference.ModelResponseCache.enable)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelConfig

// string name = 1;
inline void ModelConfig::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelConfig::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfig.name)
}
inline std::string* ModelConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.name)
  return _s;
}
inline const std::string& ModelConfig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelConfig::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfig::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfig::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.name)
  return _impl_.name_.Release();
}
inline void ModelConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.name)
}

// string platform = 2;
inline void ModelConfig::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& ModelConfig::platform() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfig::set_platform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfig.platform)
}
inline std::string* ModelConfig::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.platform)
  return _s;
}
inline const std::string& ModelConfig::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void ModelConfig::_internal_set_platform(const std::string& value) {
  
  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfig::_internal_mutable_platform() {
  
  return _impl_.platform_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfig::release_platform() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.platform)
  return _impl_.platform_.Release();
}
inline void ModelConfig::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  _impl_.platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.platform)
}

// string backend = 17;
inline void ModelConfig::clear_backend() {
  _impl_.backend_.ClearToEmpty();
}
inline const std::string& ModelConfig::backend() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.backend)
  return _internal_backend();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfig::set_backend(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backend_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfig.backend)
}
inline std::string* ModelConfig::mutable_backend() {
  std::string* _s = _internal_mutable_backend();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.backend)
  return _s;
}
inline const std::string& ModelConfig::_internal_backend() const {
  return _impl_.backend_.Get();
}
inline void ModelConfig::_internal_set_backend(const std::string& value) {
  
  _impl_.backend_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfig::_internal_mutable_backend() {
  
  return _impl_.backend_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfig::release_backend() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.backend)
  return _impl_.backend_.Release();
}
inline void ModelConfig::set_allocated_backend(std::string* backend) {
  if (backend != nullptr) {
    
  } else {
    
  }
  _impl_.backend_.SetAllocated(backend, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backend_.IsDefault()) {
    _impl_.backend_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.backend)
}

// string runtime = 25;
inline void ModelConfig::clear_runtime() {
  _impl_.runtime_.ClearToEmpty();
}
inline const std::string& ModelConfig::runtime() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.runtime)
  return _internal_runtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfig::set_runtime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.runtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfig.runtime)
}
inline std::string* ModelConfig::mutable_runtime() {
  std::string* _s = _internal_mutable_runtime();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.runtime)
  return _s;
}
inline const std::string& ModelConfig::_internal_runtime() const {
  return _impl_.runtime_.Get();
}
inline void ModelConfig::_internal_set_runtime(const std::string& value) {
  
  _impl_.runtime_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfig::_internal_mutable_runtime() {
  
  return _impl_.runtime_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfig::release_runtime() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.runtime)
  return _impl_.runtime_.Release();
}
inline void ModelConfig::set_allocated_runtime(std::string* runtime) {
  if (runtime != nullptr) {
    
  } else {
    
  }
  _impl_.runtime_.SetAllocated(runtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.runtime_.IsDefault()) {
    _impl_.runtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.runtime)
}

// .inference.ModelVersionPolicy version_policy = 3;
inline bool ModelConfig::_internal_has_version_policy() const {
  return this != internal_default_instance() && _impl_.version_policy_ != nullptr;
}
inline bool ModelConfig::has_version_policy() const {
  return _internal_has_version_policy();
}
inline void ModelConfig::clear_version_policy() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_policy_ != nullptr) {
    delete _impl_.version_policy_;
  }
  _impl_.version_policy_ = nullptr;
}
inline const ::inference::ModelVersionPolicy& ModelConfig::_internal_version_policy() const {
  const ::inference::ModelVersionPolicy* p = _impl_.version_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelVersionPolicy&>(
      ::inference::_ModelVersionPolicy_default_instance_);
}
inline const ::inference::ModelVersionPolicy& ModelConfig::version_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.version_policy)
  return _internal_version_policy();
}
inline void ModelConfig::unsafe_arena_set_allocated_version_policy(
    ::inference::ModelVersionPolicy* version_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_policy_);
  }
  _impl_.version_policy_ = version_policy;
  if (version_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.version_policy)
}
inline ::inference::ModelVersionPolicy* ModelConfig::release_version_policy() {
  
  ::inference::ModelVersionPolicy* temp = _impl_.version_policy_;
  _impl_.version_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelVersionPolicy* ModelConfig::unsafe_arena_release_version_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.version_policy)
  
  ::inference::ModelVersionPolicy* temp = _impl_.version_policy_;
  _impl_.version_policy_ = nullptr;
  return temp;
}
inline ::inference::ModelVersionPolicy* ModelConfig::_internal_mutable_version_policy() {
  
  if (_impl_.version_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelVersionPolicy>(GetArenaForAllocation());
    _impl_.version_policy_ = p;
  }
  return _impl_.version_policy_;
}
inline ::inference::ModelVersionPolicy* ModelConfig::mutable_version_policy() {
  ::inference::ModelVersionPolicy* _msg = _internal_mutable_version_policy();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.version_policy)
  return _msg;
}
inline void ModelConfig::set_allocated_version_policy(::inference::ModelVersionPolicy* version_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_policy_;
  }
  if (version_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version_policy);
    if (message_arena != submessage_arena) {
      version_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version_policy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_policy_ = version_policy;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.version_policy)
}

// int32 max_batch_size = 4;
inline void ModelConfig::clear_max_batch_size() {
  _impl_.max_batch_size_ = 0;
}
inline int32_t ModelConfig::_internal_max_batch_size() const {
  return _impl_.max_batch_size_;
}
inline int32_t ModelConfig::max_batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.max_batch_size)
  return _internal_max_batch_size();
}
inline void ModelConfig::_internal_set_max_batch_size(int32_t value) {
  
  _impl_.max_batch_size_ = value;
}
inline void ModelConfig::set_max_batch_size(int32_t value) {
  _internal_set_max_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelConfig.max_batch_size)
}

// repeated .inference.ModelInput input = 5;
inline int ModelConfig::_internal_input_size() const {
  return _impl_.input_.size();
}
inline int ModelConfig::input_size() const {
  return _internal_input_size();
}
inline void ModelConfig::clear_input() {
  _impl_.input_.Clear();
}
inline ::inference::ModelInput* ModelConfig::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.input)
  return _impl_.input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >*
ModelConfig::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.input)
  return &_impl_.input_;
}
inline const ::inference::ModelInput& ModelConfig::_internal_input(int index) const {
  return _impl_.input_.Get(index);
}
inline const ::inference::ModelInput& ModelConfig::input(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.input)
  return _internal_input(index);
}
inline ::inference::ModelInput* ModelConfig::_internal_add_input() {
  return _impl_.input_.Add();
}
inline ::inference::ModelInput* ModelConfig::add_input() {
  ::inference::ModelInput* _add = _internal_add_input();
  // @@protoc_insertion_point(field_add:inference.ModelConfig.input)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >&
ModelConfig::input() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.input)
  return _impl_.input_;
}

// repeated .inference.ModelOutput output = 6;
inline int ModelConfig::_internal_output_size() const {
  return _impl_.output_.size();
}
inline int ModelConfig::output_size() const {
  return _internal_output_size();
}
inline void ModelConfig::clear_output() {
  _impl_.output_.Clear();
}
inline ::inference::ModelOutput* ModelConfig::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.output)
  return _impl_.output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >*
ModelConfig::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.output)
  return &_impl_.output_;
}
inline const ::inference::ModelOutput& ModelConfig::_internal_output(int index) const {
  return _impl_.output_.Get(index);
}
inline const ::inference::ModelOutput& ModelConfig::output(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.output)
  return _internal_output(index);
}
inline ::inference::ModelOutput* ModelConfig::_internal_add_output() {
  return _impl_.output_.Add();
}
inline ::inference::ModelOutput* ModelConfig::add_output() {
  ::inference::ModelOutput* _add = _internal_add_output();
  // @@protoc_insertion_point(field_add:inference.ModelConfig.output)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >&
ModelConfig::output() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.output)
  return _impl_.output_;
}

// repeated .inference.BatchInput batch_input = 20;
inline int ModelConfig::_internal_batch_input_size() const {
  return _impl_.batch_input_.size();
}
inline int ModelConfig::batch_input_size() const {
  return _internal_batch_input_size();
}
inline void ModelConfig::clear_batch_input() {
  _impl_.batch_input_.Clear();
}
inline ::inference::BatchInput* ModelConfig::mutable_batch_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.batch_input)
  return _impl_.batch_input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >*
ModelConfig::mutable_batch_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.batch_input)
  return &_impl_.batch_input_;
}
inline const ::inference::BatchInput& ModelConfig::_internal_batch_input(int index) const {
  return _impl_.batch_input_.Get(index);
}
inline const ::inference::BatchInput& ModelConfig::batch_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.batch_input)
  return _internal_batch_input(index);
}
inline ::inference::BatchInput* ModelConfig::_internal_add_batch_input() {
  return _impl_.batch_input_.Add();
}
inline ::inference::BatchInput* ModelConfig::add_batch_input() {
  ::inference::BatchInput* _add = _internal_add_batch_input();
  // @@protoc_insertion_point(field_add:inference.ModelConfig.batch_input)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >&
ModelConfig::batch_input() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.batch_input)
  return _impl_.batch_input_;
}

// repeated .inference.BatchOutput batch_output = 21;
inline int ModelConfig::_internal_batch_output_size() const {
  return _impl_.batch_output_.size();
}
inline int ModelConfig::batch_output_size() const {
  return _internal_batch_output_size();
}
inline void ModelConfig::clear_batch_output() {
  _impl_.batch_output_.Clear();
}
inline ::inference::BatchOutput* ModelConfig::mutable_batch_output(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.batch_output)
  return _impl_.batch_output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >*
ModelConfig::mutable_batch_output() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.batch_output)
  return &_impl_.batch_output_;
}
inline const ::inference::BatchOutput& ModelConfig::_internal_batch_output(int index) const {
  return _impl_.batch_output_.Get(index);
}
inline const ::inference::BatchOutput& ModelConfig::batch_output(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.batch_output)
  return _internal_batch_output(index);
}
inline ::inference::BatchOutput* ModelConfig::_internal_add_batch_output() {
  return _impl_.batch_output_.Add();
}
inline ::inference::BatchOutput* ModelConfig::add_batch_output() {
  ::inference::BatchOutput* _add = _internal_add_batch_output();
  // @@protoc_insertion_point(field_add:inference.ModelConfig.batch_output)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >&
ModelConfig::batch_output() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.batch_output)
  return _impl_.batch_output_;
}

// .inference.ModelOptimizationPolicy optimization = 12;
inline bool ModelConfig::_internal_has_optimization() const {
  return this != internal_default_instance() && _impl_.optimization_ != nullptr;
}
inline bool ModelConfig::has_optimization() const {
  return _internal_has_optimization();
}
inline void ModelConfig::clear_optimization() {
  if (GetArenaForAllocation() == nullptr && _impl_.optimization_ != nullptr) {
    delete _impl_.optimization_;
  }
  _impl_.optimization_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy& ModelConfig::_internal_optimization() const {
  const ::inference::ModelOptimizationPolicy* p = _impl_.optimization_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy&>(
      ::inference::_ModelOptimizationPolicy_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy& ModelConfig::optimization() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.optimization)
  return _internal_optimization();
}
inline void ModelConfig::unsafe_arena_set_allocated_optimization(
    ::inference::ModelOptimizationPolicy* optimization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optimization_);
  }
  _impl_.optimization_ = optimization;
  if (optimization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.optimization)
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::release_optimization() {
  
  ::inference::ModelOptimizationPolicy* temp = _impl_.optimization_;
  _impl_.optimization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::unsafe_arena_release_optimization() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.optimization)
  
  ::inference::ModelOptimizationPolicy* temp = _impl_.optimization_;
  _impl_.optimization_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::_internal_mutable_optimization() {
  
  if (_impl_.optimization_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy>(GetArenaForAllocation());
    _impl_.optimization_ = p;
  }
  return _impl_.optimization_;
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::mutable_optimization() {
  ::inference::ModelOptimizationPolicy* _msg = _internal_mutable_optimization();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.optimization)
  return _msg;
}
inline void ModelConfig::set_allocated_optimization(::inference::ModelOptimizationPolicy* optimization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optimization_;
  }
  if (optimization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optimization);
    if (message_arena != submessage_arena) {
      optimization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optimization, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.optimization_ = optimization;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.optimization)
}

// .inference.ModelDynamicBatching dynamic_batching = 11;
inline bool ModelConfig::_internal_has_dynamic_batching() const {
  return scheduling_choice_case() == kDynamicBatching;
}
inline bool ModelConfig::has_dynamic_batching() const {
  return _internal_has_dynamic_batching();
}
inline void ModelConfig::set_has_dynamic_batching() {
  _impl_._oneof_case_[0] = kDynamicBatching;
}
inline void ModelConfig::clear_dynamic_batching() {
  if (_internal_has_dynamic_batching()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scheduling_choice_.dynamic_batching_;
    }
    clear_has_scheduling_choice();
  }
}
inline ::inference::ModelDynamicBatching* ModelConfig::release_dynamic_batching() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.dynamic_batching)
  if (_internal_has_dynamic_batching()) {
    clear_has_scheduling_choice();
    ::inference::ModelDynamicBatching* temp = _impl_.scheduling_choice_.dynamic_batching_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scheduling_choice_.dynamic_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelDynamicBatching& ModelConfig::_internal_dynamic_batching() const {
  return _internal_has_dynamic_batching()
      ? *_impl_.scheduling_choice_.dynamic_batching_
      : reinterpret_cast< ::inference::ModelDynamicBatching&>(::inference::_ModelDynamicBatching_default_instance_);
}
inline const ::inference::ModelDynamicBatching& ModelConfig::dynamic_batching() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.dynamic_batching)
  return _internal_dynamic_batching();
}
inline ::inference::ModelDynamicBatching* ModelConfig::unsafe_arena_release_dynamic_batching() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelConfig.dynamic_batching)
  if (_internal_has_dynamic_batching()) {
    clear_has_scheduling_choice();
    ::inference::ModelDynamicBatching* temp = _impl_.scheduling_choice_.dynamic_batching_;
    _impl_.scheduling_choice_.dynamic_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelConfig::unsafe_arena_set_allocated_dynamic_batching(::inference::ModelDynamicBatching* dynamic_batching) {
  clear_scheduling_choice();
  if (dynamic_batching) {
    set_has_dynamic_batching();
    _impl_.scheduling_choice_.dynamic_batching_ = dynamic_batching;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.dynamic_batching)
}
inline ::inference::ModelDynamicBatching* ModelConfig::_internal_mutable_dynamic_batching() {
  if (!_internal_has_dynamic_batching()) {
    clear_scheduling_choice();
    set_has_dynamic_batching();
    _impl_.scheduling_choice_.dynamic_batching_ = CreateMaybeMessage< ::inference::ModelDynamicBatching >(GetArenaForAllocation());
  }
  return _impl_.scheduling_choice_.dynamic_batching_;
}
inline ::inference::ModelDynamicBatching* ModelConfig::mutable_dynamic_batching() {
  ::inference::ModelDynamicBatching* _msg = _internal_mutable_dynamic_batching();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.dynamic_batching)
  return _msg;
}

// .inference.ModelSequenceBatching sequence_batching = 13;
inline bool ModelConfig::_internal_has_sequence_batching() const {
  return scheduling_choice_case() == kSequenceBatching;
}
inline bool ModelConfig::has_sequence_batching() const {
  return _internal_has_sequence_batching();
}
inline void ModelConfig::set_has_sequence_batching() {
  _impl_._oneof_case_[0] = kSequenceBatching;
}
inline void ModelConfig::clear_sequence_batching() {
  if (_internal_has_sequence_batching()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scheduling_choice_.sequence_batching_;
    }
    clear_has_scheduling_choice();
  }
}
inline ::inference::ModelSequenceBatching* ModelConfig::release_sequence_batching() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.sequence_batching)
  if (_internal_has_sequence_batching()) {
    clear_has_scheduling_choice();
    ::inference::ModelSequenceBatching* temp = _impl_.scheduling_choice_.sequence_batching_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scheduling_choice_.sequence_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelSequenceBatching& ModelConfig::_internal_sequence_batching() const {
  return _internal_has_sequence_batching()
      ? *_impl_.scheduling_choice_.sequence_batching_
      : reinterpret_cast< ::inference::ModelSequenceBatching&>(::inference::_ModelSequenceBatching_default_instance_);
}
inline const ::inference::ModelSequenceBatching& ModelConfig::sequence_batching() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.sequence_batching)
  return _internal_sequence_batching();
}
inline ::inference::ModelSequenceBatching* ModelConfig::unsafe_arena_release_sequence_batching() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelConfig.sequence_batching)
  if (_internal_has_sequence_batching()) {
    clear_has_scheduling_choice();
    ::inference::ModelSequenceBatching* temp = _impl_.scheduling_choice_.sequence_batching_;
    _impl_.scheduling_choice_.sequence_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelConfig::unsafe_arena_set_allocated_sequence_batching(::inference::ModelSequenceBatching* sequence_batching) {
  clear_scheduling_choice();
  if (sequence_batching) {
    set_has_sequence_batching();
    _impl_.scheduling_choice_.sequence_batching_ = sequence_batching;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.sequence_batching)
}
inline ::inference::ModelSequenceBatching* ModelConfig::_internal_mutable_sequence_batching() {
  if (!_internal_has_sequence_batching()) {
    clear_scheduling_choice();
    set_has_sequence_batching();
    _impl_.scheduling_choice_.sequence_batching_ = CreateMaybeMessage< ::inference::ModelSequenceBatching >(GetArenaForAllocation());
  }
  return _impl_.scheduling_choice_.sequence_batching_;
}
inline ::inference::ModelSequenceBatching* ModelConfig::mutable_sequence_batching() {
  ::inference::ModelSequenceBatching* _msg = _internal_mutable_sequence_batching();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.sequence_batching)
  return _msg;
}

// .inference.ModelEnsembling ensemble_scheduling = 15;
inline bool ModelConfig::_internal_has_ensemble_scheduling() const {
  return scheduling_choice_case() == kEnsembleScheduling;
}
inline bool ModelConfig::has_ensemble_scheduling() const {
  return _internal_has_ensemble_scheduling();
}
inline void ModelConfig::set_has_ensemble_scheduling() {
  _impl_._oneof_case_[0] = kEnsembleScheduling;
}
inline void ModelConfig::clear_ensemble_scheduling() {
  if (_internal_has_ensemble_scheduling()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scheduling_choice_.ensemble_scheduling_;
    }
    clear_has_scheduling_choice();
  }
}
inline ::inference::ModelEnsembling* ModelConfig::release_ensemble_scheduling() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.ensemble_scheduling)
  if (_internal_has_ensemble_scheduling()) {
    clear_has_scheduling_choice();
    ::inference::ModelEnsembling* temp = _impl_.scheduling_choice_.ensemble_scheduling_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scheduling_choice_.ensemble_scheduling_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelEnsembling& ModelConfig::_internal_ensemble_scheduling() const {
  return _internal_has_ensemble_scheduling()
      ? *_impl_.scheduling_choice_.ensemble_scheduling_
      : reinterpret_cast< ::inference::ModelEnsembling&>(::inference::_ModelEnsembling_default_instance_);
}
inline const ::inference::ModelEnsembling& ModelConfig::ensemble_scheduling() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.ensemble_scheduling)
  return _internal_ensemble_scheduling();
}
inline ::inference::ModelEnsembling* ModelConfig::unsafe_arena_release_ensemble_scheduling() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelConfig.ensemble_scheduling)
  if (_internal_has_ensemble_scheduling()) {
    clear_has_scheduling_choice();
    ::inference::ModelEnsembling* temp = _impl_.scheduling_choice_.ensemble_scheduling_;
    _impl_.scheduling_choice_.ensemble_scheduling_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelConfig::unsafe_arena_set_allocated_ensemble_scheduling(::inference::ModelEnsembling* ensemble_scheduling) {
  clear_scheduling_choice();
  if (ensemble_scheduling) {
    set_has_ensemble_scheduling();
    _impl_.scheduling_choice_.ensemble_scheduling_ = ensemble_scheduling;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.ensemble_scheduling)
}
inline ::inference::ModelEnsembling* ModelConfig::_internal_mutable_ensemble_scheduling() {
  if (!_internal_has_ensemble_scheduling()) {
    clear_scheduling_choice();
    set_has_ensemble_scheduling();
    _impl_.scheduling_choice_.ensemble_scheduling_ = CreateMaybeMessage< ::inference::ModelEnsembling >(GetArenaForAllocation());
  }
  return _impl_.scheduling_choice_.ensemble_scheduling_;
}
inline ::inference::ModelEnsembling* ModelConfig::mutable_ensemble_scheduling() {
  ::inference::ModelEnsembling* _msg = _internal_mutable_ensemble_scheduling();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.ensemble_scheduling)
  return _msg;
}

// repeated .inference.ModelInstanceGroup instance_group = 7;
inline int ModelConfig::_internal_instance_group_size() const {
  return _impl_.instance_group_.size();
}
inline int ModelConfig::instance_group_size() const {
  return _internal_instance_group_size();
}
inline void ModelConfig::clear_instance_group() {
  _impl_.instance_group_.Clear();
}
inline ::inference::ModelInstanceGroup* ModelConfig::mutable_instance_group(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.instance_group)
  return _impl_.instance_group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >*
ModelConfig::mutable_instance_group() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.instance_group)
  return &_impl_.instance_group_;
}
inline const ::inference::ModelInstanceGroup& ModelConfig::_internal_instance_group(int index) const {
  return _impl_.instance_group_.Get(index);
}
inline const ::inference::ModelInstanceGroup& ModelConfig::instance_group(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.instance_group)
  return _internal_instance_group(index);
}
inline ::inference::ModelInstanceGroup* ModelConfig::_internal_add_instance_group() {
  return _impl_.instance_group_.Add();
}
inline ::inference::ModelInstanceGroup* ModelConfig::add_instance_group() {
  ::inference::ModelInstanceGroup* _add = _internal_add_instance_group();
  // @@protoc_insertion_point(field_add:inference.ModelConfig.instance_group)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >&
ModelConfig::instance_group() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.instance_group)
  return _impl_.instance_group_;
}

// string default_model_filename = 8;
inline void ModelConfig::clear_default_model_filename() {
  _impl_.default_model_filename_.ClearToEmpty();
}
inline const std::string& ModelConfig::default_model_filename() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.default_model_filename)
  return _internal_default_model_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfig::set_default_model_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_model_filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfig.default_model_filename)
}
inline std::string* ModelConfig::mutable_default_model_filename() {
  std::string* _s = _internal_mutable_default_model_filename();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.default_model_filename)
  return _s;
}
inline const std::string& ModelConfig::_internal_default_model_filename() const {
  return _impl_.default_model_filename_.Get();
}
inline void ModelConfig::_internal_set_default_model_filename(const std::string& value) {
  
  _impl_.default_model_filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfig::_internal_mutable_default_model_filename() {
  
  return _impl_.default_model_filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfig::release_default_model_filename() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.default_model_filename)
  return _impl_.default_model_filename_.Release();
}
inline void ModelConfig::set_allocated_default_model_filename(std::string* default_model_filename) {
  if (default_model_filename != nullptr) {
    
  } else {
    
  }
  _impl_.default_model_filename_.SetAllocated(default_model_filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_model_filename_.IsDefault()) {
    _impl_.default_model_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.default_model_filename)
}

// map<string, string> cc_model_filenames = 9;
inline int ModelConfig::_internal_cc_model_filenames_size() const {
  return _impl_.cc_model_filenames_.size();
}
inline int ModelConfig::cc_model_filenames_size() const {
  return _internal_cc_model_filenames_size();
}
inline void ModelConfig::clear_cc_model_filenames() {
  _impl_.cc_model_filenames_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::_internal_cc_model_filenames() const {
  return _impl_.cc_model_filenames_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::cc_model_filenames() const {
  // @@protoc_insertion_point(field_map:inference.ModelConfig.cc_model_filenames)
  return _internal_cc_model_filenames();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::_internal_mutable_cc_model_filenames() {
  return _impl_.cc_model_filenames_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::mutable_cc_model_filenames() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelConfig.cc_model_filenames)
  return _internal_mutable_cc_model_filenames();
}

// map<string, string> metric_tags = 10;
inline int ModelConfig::_internal_metric_tags_size() const {
  return _impl_.metric_tags_.size();
}
inline int ModelConfig::metric_tags_size() const {
  return _internal_metric_tags_size();
}
inline void ModelConfig::clear_metric_tags() {
  _impl_.metric_tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::_internal_metric_tags() const {
  return _impl_.metric_tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::metric_tags() const {
  // @@protoc_insertion_point(field_map:inference.ModelConfig.metric_tags)
  return _internal_metric_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::_internal_mutable_metric_tags() {
  return _impl_.metric_tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::mutable_metric_tags() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelConfig.metric_tags)
  return _internal_mutable_metric_tags();
}

// map<string, .inference.ModelParameter> parameters = 14;
inline int ModelConfig::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelConfig::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelConfig::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
ModelConfig::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
ModelConfig::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelConfig.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
ModelConfig::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
ModelConfig::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelConfig.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.ModelWarmup model_warmup = 16;
inline int ModelConfig::_internal_model_warmup_size() const {
  return _impl_.model_warmup_.size();
}
inline int ModelConfig::model_warmup_size() const {
  return _internal_model_warmup_size();
}
inline void ModelConfig::clear_model_warmup() {
  _impl_.model_warmup_.Clear();
}
inline ::inference::ModelWarmup* ModelConfig::mutable_model_warmup(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_warmup)
  return _impl_.model_warmup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >*
ModelConfig::mutable_model_warmup() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.model_warmup)
  return &_impl_.model_warmup_;
}
inline const ::inference::ModelWarmup& ModelConfig::_internal_model_warmup(int index) const {
  return _impl_.model_warmup_.Get(index);
}
inline const ::inference::ModelWarmup& ModelConfig::model_warmup(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_warmup)
  return _internal_model_warmup(index);
}
inline ::inference::ModelWarmup* ModelConfig::_internal_add_model_warmup() {
  return _impl_.model_warmup_.Add();
}
inline ::inference::ModelWarmup* ModelConfig::add_model_warmup() {
  ::inference::ModelWarmup* _add = _internal_add_model_warmup();
  // @@protoc_insertion_point(field_add:inference.ModelConfig.model_warmup)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >&
ModelConfig::model_warmup() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.model_warmup)
  return _impl_.model_warmup_;
}

// .inference.ModelOperations model_operations = 18;
inline bool ModelConfig::_internal_has_model_operations() const {
  return this != internal_default_instance() && _impl_.model_operations_ != nullptr;
}
inline bool ModelConfig::has_model_operations() const {
  return _internal_has_model_operations();
}
inline void ModelConfig::clear_model_operations() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_operations_ != nullptr) {
    delete _impl_.model_operations_;
  }
  _impl_.model_operations_ = nullptr;
}
inline const ::inference::ModelOperations& ModelConfig::_internal_model_operations() const {
  const ::inference::ModelOperations* p = _impl_.model_operations_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOperations&>(
      ::inference::_ModelOperations_default_instance_);
}
inline const ::inference::ModelOperations& ModelConfig::model_operations() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_operations)
  return _internal_model_operations();
}
inline void ModelConfig::unsafe_arena_set_allocated_model_operations(
    ::inference::ModelOperations* model_operations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_operations_);
  }
  _impl_.model_operations_ = model_operations;
  if (model_operations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.model_operations)
}
inline ::inference::ModelOperations* ModelConfig::release_model_operations() {
  
  ::inference::ModelOperations* temp = _impl_.model_operations_;
  _impl_.model_operations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelOperations* ModelConfig::unsafe_arena_release_model_operations() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.model_operations)
  
  ::inference::ModelOperations* temp = _impl_.model_operations_;
  _impl_.model_operations_ = nullptr;
  return temp;
}
inline ::inference::ModelOperations* ModelConfig::_internal_mutable_model_operations() {
  
  if (_impl_.model_operations_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOperations>(GetArenaForAllocation());
    _impl_.model_operations_ = p;
  }
  return _impl_.model_operations_;
}
inline ::inference::ModelOperations* ModelConfig::mutable_model_operations() {
  ::inference::ModelOperations* _msg = _internal_mutable_model_operations();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_operations)
  return _msg;
}
inline void ModelConfig::set_allocated_model_operations(::inference::ModelOperations* model_operations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_operations_;
  }
  if (model_operations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_operations);
    if (message_arena != submessage_arena) {
      model_operations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_operations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_operations_ = model_operations;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.model_operations)
}

// .inference.ModelTransactionPolicy model_transaction_policy = 19;
inline bool ModelConfig::_internal_has_model_transaction_policy() const {
  return this != internal_default_instance() && _impl_.model_transaction_policy_ != nullptr;
}
inline bool ModelConfig::has_model_transaction_policy() const {
  return _internal_has_model_transaction_policy();
}
inline void ModelConfig::clear_model_transaction_policy() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_transaction_policy_ != nullptr) {
    delete _impl_.model_transaction_policy_;
  }
  _impl_.model_transaction_policy_ = nullptr;
}
inline const ::inference::ModelTransactionPolicy& ModelConfig::_internal_model_transaction_policy() const {
  const ::inference::ModelTransactionPolicy* p = _impl_.model_transaction_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelTransactionPolicy&>(
      ::inference::_ModelTransactionPolicy_default_instance_);
}
inline const ::inference::ModelTransactionPolicy& ModelConfig::model_transaction_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_transaction_policy)
  return _internal_model_transaction_policy();
}
inline void ModelConfig::unsafe_arena_set_allocated_model_transaction_policy(
    ::inference::ModelTransactionPolicy* model_transaction_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_transaction_policy_);
  }
  _impl_.model_transaction_policy_ = model_transaction_policy;
  if (model_transaction_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.model_transaction_policy)
}
inline ::inference::ModelTransactionPolicy* ModelConfig::release_model_transaction_policy() {
  
  ::inference::ModelTransactionPolicy* temp = _impl_.model_transaction_policy_;
  _impl_.model_transaction_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelTransactionPolicy* ModelConfig::unsafe_arena_release_model_transaction_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.model_transaction_policy)
  
  ::inference::ModelTransactionPolicy* temp = _impl_.model_transaction_policy_;
  _impl_.model_transaction_policy_ = nullptr;
  return temp;
}
inline ::inference::ModelTransactionPolicy* ModelConfig::_internal_mutable_model_transaction_policy() {
  
  if (_impl_.model_transaction_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelTransactionPolicy>(GetArenaForAllocation());
    _impl_.model_transaction_policy_ = p;
  }
  return _impl_.model_transaction_policy_;
}
inline ::inference::ModelTransactionPolicy* ModelConfig::mutable_model_transaction_policy() {
  ::inference::ModelTransactionPolicy* _msg = _internal_mutable_model_transaction_policy();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_transaction_policy)
  return _msg;
}
inline void ModelConfig::set_allocated_model_transaction_policy(::inference::ModelTransactionPolicy* model_transaction_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_transaction_policy_;
  }
  if (model_transaction_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_transaction_policy);
    if (message_arena != submessage_arena) {
      model_transaction_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_transaction_policy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_transaction_policy_ = model_transaction_policy;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.model_transaction_policy)
}

// .inference.ModelRepositoryAgents model_repository_agents = 23;
inline bool ModelConfig::_internal_has_model_repository_agents() const {
  return this != internal_default_instance() && _impl_.model_repository_agents_ != nullptr;
}
inline bool ModelConfig::has_model_repository_agents() const {
  return _internal_has_model_repository_agents();
}
inline void ModelConfig::clear_model_repository_agents() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_repository_agents_ != nullptr) {
    delete _impl_.model_repository_agents_;
  }
  _impl_.model_repository_agents_ = nullptr;
}
inline const ::inference::ModelRepositoryAgents& ModelConfig::_internal_model_repository_agents() const {
  const ::inference::ModelRepositoryAgents* p = _impl_.model_repository_agents_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelRepositoryAgents&>(
      ::inference::_ModelRepositoryAgents_default_instance_);
}
inline const ::inference::ModelRepositoryAgents& ModelConfig::model_repository_agents() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_repository_agents)
  return _internal_model_repository_agents();
}
inline void ModelConfig::unsafe_arena_set_allocated_model_repository_agents(
    ::inference::ModelRepositoryAgents* model_repository_agents) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_repository_agents_);
  }
  _impl_.model_repository_agents_ = model_repository_agents;
  if (model_repository_agents) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.model_repository_agents)
}
inline ::inference::ModelRepositoryAgents* ModelConfig::release_model_repository_agents() {
  
  ::inference::ModelRepositoryAgents* temp = _impl_.model_repository_agents_;
  _impl_.model_repository_agents_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelRepositoryAgents* ModelConfig::unsafe_arena_release_model_repository_agents() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.model_repository_agents)
  
  ::inference::ModelRepositoryAgents* temp = _impl_.model_repository_agents_;
  _impl_.model_repository_agents_ = nullptr;
  return temp;
}
inline ::inference::ModelRepositoryAgents* ModelConfig::_internal_mutable_model_repository_agents() {
  
  if (_impl_.model_repository_agents_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelRepositoryAgents>(GetArenaForAllocation());
    _impl_.model_repository_agents_ = p;
  }
  return _impl_.model_repository_agents_;
}
inline ::inference::ModelRepositoryAgents* ModelConfig::mutable_model_repository_agents() {
  ::inference::ModelRepositoryAgents* _msg = _internal_mutable_model_repository_agents();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_repository_agents)
  return _msg;
}
inline void ModelConfig::set_allocated_model_repository_agents(::inference::ModelRepositoryAgents* model_repository_agents) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_repository_agents_;
  }
  if (model_repository_agents) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_repository_agents);
    if (message_arena != submessage_arena) {
      model_repository_agents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_repository_agents, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_repository_agents_ = model_repository_agents;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.model_repository_agents)
}

// .inference.ModelResponseCache response_cache = 24;
inline bool ModelConfig::_internal_has_response_cache() const {
  return this != internal_default_instance() && _impl_.response_cache_ != nullptr;
}
inline bool ModelConfig::has_response_cache() const {
  return _internal_has_response_cache();
}
inline void ModelConfig::clear_response_cache() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_cache_ != nullptr) {
    delete _impl_.response_cache_;
  }
  _impl_.response_cache_ = nullptr;
}
inline const ::inference::ModelResponseCache& ModelConfig::_internal_response_cache() const {
  const ::inference::ModelResponseCache* p = _impl_.response_cache_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelResponseCache&>(
      ::inference::_ModelResponseCache_default_instance_);
}
inline const ::inference::ModelResponseCache& ModelConfig::response_cache() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.response_cache)
  return _internal_response_cache();
}
inline void ModelConfig::unsafe_arena_set_allocated_response_cache(
    ::inference::ModelResponseCache* response_cache) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_cache_);
  }
  _impl_.response_cache_ = response_cache;
  if (response_cache) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.response_cache)
}
inline ::inference::ModelResponseCache* ModelConfig::release_response_cache() {
  
  ::inference::ModelResponseCache* temp = _impl_.response_cache_;
  _impl_.response_cache_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inference::ModelResponseCache* ModelConfig::unsafe_arena_release_response_cache() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.response_cache)
  
  ::inference::ModelResponseCache* temp = _impl_.response_cache_;
  _impl_.response_cache_ = nullptr;
  return temp;
}
inline ::inference::ModelResponseCache* ModelConfig::_internal_mutable_response_cache() {
  
  if (_impl_.response_cache_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelResponseCache>(GetArenaForAllocation());
    _impl_.response_cache_ = p;
  }
  return _impl_.response_cache_;
}
inline ::inference::ModelResponseCache* ModelConfig::mutable_response_cache() {
  ::inference::ModelResponseCache* _msg = _internal_mutable_response_cache();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.response_cache)
  return _msg;
}
inline void ModelConfig::set_allocated_response_cache(::inference::ModelResponseCache* response_cache) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_cache_;
  }
  if (response_cache) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_cache);
    if (message_arena != submessage_arena) {
      response_cache = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_cache, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_cache_ = response_cache;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.response_cache)
}

inline bool ModelConfig::has_scheduling_choice() const {
  return scheduling_choice_case() != SCHEDULING_CHOICE_NOT_SET;
}
inline void ModelConfig::clear_has_scheduling_choice() {
  _impl_._oneof_case_[0] = SCHEDULING_CHOICE_NOT_SET;
}
inline ModelConfig::SchedulingChoiceCase ModelConfig::scheduling_choice_case() const {
  return ModelConfig::SchedulingChoiceCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace inference

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind>() {
  return ::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelInstanceGroup_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelInstanceGroup_Kind>() {
  return ::inference::ModelInstanceGroup_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelInput_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelInput_Format>() {
  return ::inference::ModelInput_Format_descriptor();
}
template <> struct is_proto_enum< ::inference::BatchInput_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::BatchInput_Kind>() {
  return ::inference::BatchInput_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::BatchOutput_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::BatchOutput_Kind>() {
  return ::inference::BatchOutput_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelOptimizationPolicy_ModelPriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelOptimizationPolicy_ModelPriority>() {
  return ::inference::ModelOptimizationPolicy_ModelPriority_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelQueuePolicy_TimeoutAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelQueuePolicy_TimeoutAction>() {
  return ::inference::ModelQueuePolicy_TimeoutAction_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelSequenceBatching_Control_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelSequenceBatching_Control_Kind>() {
  return ::inference::ModelSequenceBatching_Control_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::DataType>() {
  return ::inference::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_model_5fconfig_2eproto
